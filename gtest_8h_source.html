<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ZNC: gtest.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ZNC
   &#160;<span id="projectnumber">trunk</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">gtest.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="gtest_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Copyright 2005, Google Inc.</span>
<a name="l00002"></a>00002 <span class="comment">// All rights reserved.</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">// Redistribution and use in source and binary forms, with or without</span>
<a name="l00005"></a>00005 <span class="comment">// modification, are permitted provided that the following conditions are</span>
<a name="l00006"></a>00006 <span class="comment">// met:</span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment">//     * Redistributions of source code must retain the above copyright</span>
<a name="l00009"></a>00009 <span class="comment">// notice, this list of conditions and the following disclaimer.</span>
<a name="l00010"></a>00010 <span class="comment">//     * Redistributions in binary form must reproduce the above</span>
<a name="l00011"></a>00011 <span class="comment">// copyright notice, this list of conditions and the following disclaimer</span>
<a name="l00012"></a>00012 <span class="comment">// in the documentation and/or other materials provided with the</span>
<a name="l00013"></a>00013 <span class="comment">// distribution.</span>
<a name="l00014"></a>00014 <span class="comment">//     * Neither the name of Google Inc. nor the names of its</span>
<a name="l00015"></a>00015 <span class="comment">// contributors may be used to endorse or promote products derived from</span>
<a name="l00016"></a>00016 <span class="comment">// this software without specific prior written permission.</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00019"></a>00019 <span class="comment">// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00020"></a>00020 <span class="comment">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00021"></a>00021 <span class="comment">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00022"></a>00022 <span class="comment">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00023"></a>00023 <span class="comment">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00024"></a>00024 <span class="comment">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00025"></a>00025 <span class="comment">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00026"></a>00026 <span class="comment">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00027"></a>00027 <span class="comment">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<a name="l00028"></a>00028 <span class="comment">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00029"></a>00029 <span class="comment">//</span>
<a name="l00030"></a>00030 <span class="comment">// Author: wan@google.com (Zhanyong Wan)</span>
<a name="l00031"></a>00031 <span class="comment">//</span>
<a name="l00032"></a>00032 <span class="comment">// The Google C++ Testing Framework (Google Test)</span>
<a name="l00033"></a>00033 <span class="comment">//</span>
<a name="l00034"></a>00034 <span class="comment">// This header file defines the public API for Google Test.  It should be</span>
<a name="l00035"></a>00035 <span class="comment">// included by any test program that uses Google Test.</span>
<a name="l00036"></a>00036 <span class="comment">//</span>
<a name="l00037"></a>00037 <span class="comment">// IMPORTANT NOTE: Due to limitation of the C++ language, we have to</span>
<a name="l00038"></a>00038 <span class="comment">// leave some internal implementation details in this header file.</span>
<a name="l00039"></a>00039 <span class="comment">// They are clearly marked by comments like this:</span>
<a name="l00040"></a>00040 <span class="comment">//</span>
<a name="l00041"></a>00041 <span class="comment">//   // INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l00042"></a>00042 <span class="comment">//</span>
<a name="l00043"></a>00043 <span class="comment">// Such code is NOT meant to be used by a user directly, and is subject</span>
<a name="l00044"></a>00044 <span class="comment">// to CHANGE WITHOUT NOTICE.  Therefore DO NOT DEPEND ON IT in a user</span>
<a name="l00045"></a>00045 <span class="comment">// program!</span>
<a name="l00046"></a>00046 <span class="comment">//</span>
<a name="l00047"></a>00047 <span class="comment">// Acknowledgment: Google Test borrowed the idea of automatic test</span>
<a name="l00048"></a>00048 <span class="comment">// registration from Barthelemy Dagenais&#39; (barthelemy@prologique.com)</span>
<a name="l00049"></a>00049 <span class="comment">// easyUnit framework.</span>
<a name="l00050"></a>00050 
<a name="l00051"></a>00051 <span class="preprocessor">#ifndef GTEST_INCLUDE_GTEST_GTEST_H_</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span><span class="preprocessor">#define GTEST_INCLUDE_GTEST_GTEST_H_</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="preprocessor">#include &lt;limits&gt;</span>
<a name="l00055"></a>00055 <span class="preprocessor">#include &lt;ostream&gt;</span>
<a name="l00056"></a>00056 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="preprocessor">#include &quot;<a class="code" href="gtest-internal_8h.html">gtest/internal/gtest-internal.h</a>&quot;</span>
<a name="l00059"></a>00059 <span class="preprocessor">#include &quot;<a class="code" href="gtest-string_8h.html">gtest/internal/gtest-string.h</a>&quot;</span>
<a name="l00060"></a>00060 <span class="preprocessor">#include &quot;<a class="code" href="gtest-death-test_8h.html">gtest/gtest-death-test.h</a>&quot;</span>
<a name="l00061"></a>00061 <span class="preprocessor">#include &quot;<a class="code" href="gtest-message_8h.html">gtest/gtest-message.h</a>&quot;</span>
<a name="l00062"></a>00062 <span class="preprocessor">#include &quot;<a class="code" href="gtest-param-test_8h.html">gtest/gtest-param-test.h</a>&quot;</span>
<a name="l00063"></a>00063 <span class="preprocessor">#include &quot;<a class="code" href="gtest-printers_8h.html">gtest/gtest-printers.h</a>&quot;</span>
<a name="l00064"></a>00064 <span class="preprocessor">#include &quot;<a class="code" href="gtest__prod_8h.html">gtest/gtest_prod.h</a>&quot;</span>
<a name="l00065"></a>00065 <span class="preprocessor">#include &quot;<a class="code" href="gtest-test-part_8h.html">gtest/gtest-test-part.h</a>&quot;</span>
<a name="l00066"></a>00066 <span class="preprocessor">#include &quot;<a class="code" href="gtest-typed-test_8h.html">gtest/gtest-typed-test.h</a>&quot;</span>
<a name="l00067"></a>00067 
<a name="l00068"></a>00068 <span class="comment">// Depending on the platform, different string classes are available.</span>
<a name="l00069"></a>00069 <span class="comment">// On Linux, in addition to ::std::string, Google also makes use of</span>
<a name="l00070"></a>00070 <span class="comment">// class ::string, which has the same interface as ::std::string, but</span>
<a name="l00071"></a>00071 <span class="comment">// has a different implementation.</span>
<a name="l00072"></a>00072 <span class="comment">//</span>
<a name="l00073"></a>00073 <span class="comment">// You can define GTEST_HAS_GLOBAL_STRING to 1 to indicate that</span>
<a name="l00074"></a>00074 <span class="comment">// ::string is available AND is a distinct type to ::std::string, or</span>
<a name="l00075"></a>00075 <span class="comment">// define it to 0 to indicate otherwise.</span>
<a name="l00076"></a>00076 <span class="comment">//</span>
<a name="l00077"></a>00077 <span class="comment">// If ::std::string and ::string are the same class on your platform</span>
<a name="l00078"></a>00078 <span class="comment">// due to aliasing, you should define GTEST_HAS_GLOBAL_STRING to 0.</span>
<a name="l00079"></a>00079 <span class="comment">//</span>
<a name="l00080"></a>00080 <span class="comment">// If you do not define GTEST_HAS_GLOBAL_STRING, it is defined</span>
<a name="l00081"></a>00081 <span class="comment">// heuristically.</span>
<a name="l00082"></a>00082 
<a name="l00083"></a>00083 <span class="keyword">namespace </span>testing {
<a name="l00084"></a>00084 
<a name="l00085"></a>00085 <span class="comment">// Declares the flags.</span>
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="comment">// This flag temporary enables the disabled tests.</span>
<a name="l00088"></a>00088 <a class="code" href="namespacetesting.html#a4c08ba9fcb0581c61e25968e520efa48">GTEST_DECLARE_bool_</a>(also_run_disabled_tests);
<a name="l00089"></a>00089 
<a name="l00090"></a>00090 <span class="comment">// This flag brings the debugger on an assertion failure.</span>
<a name="l00091"></a>00091 <a class="code" href="namespacetesting.html#a4c08ba9fcb0581c61e25968e520efa48">GTEST_DECLARE_bool_</a>(break_on_failure);
<a name="l00092"></a>00092 
<a name="l00093"></a>00093 <span class="comment">// This flag controls whether Google Test catches all test-thrown exceptions</span>
<a name="l00094"></a>00094 <span class="comment">// and logs them as failures.</span>
<a name="l00095"></a>00095 <a class="code" href="namespacetesting.html#a4c08ba9fcb0581c61e25968e520efa48">GTEST_DECLARE_bool_</a>(catch_exceptions);
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">// This flag enables using colors in terminal output. Available values are</span>
<a name="l00098"></a>00098 <span class="comment">// &quot;yes&quot; to enable colors, &quot;no&quot; (disable colors), or &quot;auto&quot; (the default)</span>
<a name="l00099"></a>00099 <span class="comment">// to let Google Test decide.</span>
<a name="l00100"></a>00100 <a class="code" href="namespacetesting.html#a37b7e87f0a5f502c6918f37d1768c1f3">GTEST_DECLARE_string_</a>(color);
<a name="l00101"></a>00101 
<a name="l00102"></a>00102 <span class="comment">// This flag sets up the filter to select by name using a glob pattern</span>
<a name="l00103"></a>00103 <span class="comment">// the tests to run. If the filter is not given all tests are executed.</span>
<a name="l00104"></a>00104 <a class="code" href="namespacetesting.html#a37b7e87f0a5f502c6918f37d1768c1f3">GTEST_DECLARE_string_</a>(filter);
<a name="l00105"></a>00105 
<a name="l00106"></a>00106 <span class="comment">// This flag causes the Google Test to list tests. None of the tests listed</span>
<a name="l00107"></a>00107 <span class="comment">// are actually run if the flag is provided.</span>
<a name="l00108"></a>00108 <a class="code" href="namespacetesting.html#a4c08ba9fcb0581c61e25968e520efa48">GTEST_DECLARE_bool_</a>(list_tests);
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="comment">// This flag controls whether Google Test emits a detailed XML report to a file</span>
<a name="l00111"></a>00111 <span class="comment">// in addition to its normal textual output.</span>
<a name="l00112"></a>00112 <a class="code" href="namespacetesting.html#a37b7e87f0a5f502c6918f37d1768c1f3">GTEST_DECLARE_string_</a>(output);
<a name="l00113"></a>00113 
<a name="l00114"></a>00114 <span class="comment">// This flags control whether Google Test prints the elapsed time for each</span>
<a name="l00115"></a>00115 <span class="comment">// test.</span>
<a name="l00116"></a>00116 <a class="code" href="namespacetesting.html#a4c08ba9fcb0581c61e25968e520efa48">GTEST_DECLARE_bool_</a>(print_time);
<a name="l00117"></a>00117 
<a name="l00118"></a>00118 <span class="comment">// This flag specifies the random number seed.</span>
<a name="l00119"></a>00119 <a class="code" href="namespacetesting.html#ae754999b59509808254d39e3a3cf38e0">GTEST_DECLARE_int32_</a>(random_seed);
<a name="l00120"></a>00120 
<a name="l00121"></a>00121 <span class="comment">// This flag sets how many times the tests are repeated. The default value</span>
<a name="l00122"></a>00122 <span class="comment">// is 1. If the value is -1 the tests are repeating forever.</span>
<a name="l00123"></a>00123 <a class="code" href="namespacetesting.html#ae754999b59509808254d39e3a3cf38e0">GTEST_DECLARE_int32_</a>(repeat);
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">// This flag controls whether Google Test includes Google Test internal</span>
<a name="l00126"></a>00126 <span class="comment">// stack frames in failure stack traces.</span>
<a name="l00127"></a>00127 <a class="code" href="namespacetesting.html#a4c08ba9fcb0581c61e25968e520efa48">GTEST_DECLARE_bool_</a>(show_internal_stack_frames);
<a name="l00128"></a>00128 
<a name="l00129"></a>00129 <span class="comment">// When this flag is specified, tests&#39; order is randomized on every iteration.</span>
<a name="l00130"></a>00130 <a class="code" href="namespacetesting.html#a4c08ba9fcb0581c61e25968e520efa48">GTEST_DECLARE_bool_</a>(shuffle);
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 <span class="comment">// This flag specifies the maximum number of stack frames to be</span>
<a name="l00133"></a>00133 <span class="comment">// printed in a failure message.</span>
<a name="l00134"></a>00134 <a class="code" href="namespacetesting.html#ae754999b59509808254d39e3a3cf38e0">GTEST_DECLARE_int32_</a>(stack_trace_depth);
<a name="l00135"></a>00135 
<a name="l00136"></a>00136 <span class="comment">// When this flag is specified, a failed assertion will throw an</span>
<a name="l00137"></a>00137 <span class="comment">// exception if exceptions are enabled, or exit the program with a</span>
<a name="l00138"></a>00138 <span class="comment">// non-zero code otherwise.</span>
<a name="l00139"></a>00139 <a class="code" href="namespacetesting.html#a4c08ba9fcb0581c61e25968e520efa48">GTEST_DECLARE_bool_</a>(throw_on_failure);
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="comment">// When this flag is set with a &quot;host:port&quot; string, on supported</span>
<a name="l00142"></a>00142 <span class="comment">// platforms test results are streamed to the specified port on</span>
<a name="l00143"></a>00143 <span class="comment">// the specified host machine.</span>
<a name="l00144"></a>00144 <a class="code" href="namespacetesting.html#a37b7e87f0a5f502c6918f37d1768c1f3">GTEST_DECLARE_string_</a>(stream_result_to);
<a name="l00145"></a>00145 
<a name="l00146"></a>00146 <span class="comment">// The upper limit for valid stack trace depths.</span>
<a name="l00147"></a><a class="code" href="namespacetesting.html#ae605f2ccac04616bb7812ca72e517082">00147</a> <span class="keyword">const</span> <span class="keywordtype">int</span> <a class="code" href="namespacetesting.html#ae605f2ccac04616bb7812ca72e517082">kMaxStackTraceDepth</a> = 100;
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="keyword">namespace </span>internal {
<a name="l00150"></a>00150 
<a name="l00151"></a>00151 <span class="keyword">class </span>AssertHelper;
<a name="l00152"></a>00152 <span class="keyword">class </span>DefaultGlobalTestPartResultReporter;
<a name="l00153"></a>00153 <span class="keyword">class </span>ExecDeathTest;
<a name="l00154"></a>00154 <span class="keyword">class </span>NoExecDeathTest;
<a name="l00155"></a>00155 <span class="keyword">class </span>FinalSuccessChecker;
<a name="l00156"></a>00156 <span class="keyword">class </span>GTestFlagSaver;
<a name="l00157"></a>00157 <span class="keyword">class </span>StreamingListenerTest;
<a name="l00158"></a>00158 <span class="keyword">class </span>TestResultAccessor;
<a name="l00159"></a>00159 <span class="keyword">class </span>TestEventListenersAccessor;
<a name="l00160"></a>00160 <span class="keyword">class </span>TestEventRepeater;
<a name="l00161"></a>00161 <span class="keyword">class </span>UnitTestRecordPropertyTestHelper;
<a name="l00162"></a>00162 <span class="keyword">class </span>WindowsDeathTest;
<a name="l00163"></a>00163 <span class="keyword">class </span>UnitTestImpl* <a class="code" href="namespacetesting_1_1internal.html#a9bd0caf5d16512de38b39599c13ee634">GetUnitTestImpl</a>();
<a name="l00164"></a>00164 <span class="keywordtype">void</span> <a class="code" href="namespacetesting_1_1internal.html#a85f6ff0e40f9a5f10af66a73cf1364fa">ReportFailureInUnknownLocation</a>(<a class="code" href="classtesting_1_1TestPartResult.html#a65ae656b33fdfdfffaf34858778a52d5">TestPartResult::Type</a> result_type,
<a name="l00165"></a>00165                                     <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; message);
<a name="l00166"></a>00166 
<a name="l00167"></a>00167 }  <span class="comment">// namespace internal</span>
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="comment">// The friend relationship of some of these classes is cyclic.</span>
<a name="l00170"></a>00170 <span class="comment">// If we don&#39;t forward declare them the compiler might confuse the classes</span>
<a name="l00171"></a>00171 <span class="comment">// in friendship clauses with same named classes on the scope.</span>
<a name="l00172"></a>00172 <span class="keyword">class </span>Test;
<a name="l00173"></a>00173 <span class="keyword">class </span>TestCase;
<a name="l00174"></a>00174 <span class="keyword">class </span>TestInfo;
<a name="l00175"></a>00175 <span class="keyword">class </span>UnitTest;
<a name="l00176"></a>00176 
<a name="l00177"></a>00177 <span class="comment">// A class for indicating whether an assertion was successful.  When</span>
<a name="l00178"></a>00178 <span class="comment">// the assertion wasn&#39;t successful, the AssertionResult object</span>
<a name="l00179"></a>00179 <span class="comment">// remembers a non-empty message that describes how it failed.</span>
<a name="l00180"></a>00180 <span class="comment">//</span>
<a name="l00181"></a>00181 <span class="comment">// To create an instance of this class, use one of the factory functions</span>
<a name="l00182"></a>00182 <span class="comment">// (AssertionSuccess() and AssertionFailure()).</span>
<a name="l00183"></a>00183 <span class="comment">//</span>
<a name="l00184"></a>00184 <span class="comment">// This class is useful for two purposes:</span>
<a name="l00185"></a>00185 <span class="comment">//   1. Defining predicate functions to be used with Boolean test assertions</span>
<a name="l00186"></a>00186 <span class="comment">//      EXPECT_TRUE/EXPECT_FALSE and their ASSERT_ counterparts</span>
<a name="l00187"></a>00187 <span class="comment">//   2. Defining predicate-format functions to be</span>
<a name="l00188"></a>00188 <span class="comment">//      used with predicate assertions (ASSERT_PRED_FORMAT*, etc).</span>
<a name="l00189"></a>00189 <span class="comment">//</span>
<a name="l00190"></a>00190 <span class="comment">// For example, if you define IsEven predicate:</span>
<a name="l00191"></a>00191 <span class="comment">//</span>
<a name="l00192"></a>00192 <span class="comment">//   testing::AssertionResult IsEven(int n) {</span>
<a name="l00193"></a>00193 <span class="comment">//     if ((n % 2) == 0)</span>
<a name="l00194"></a>00194 <span class="comment">//       return testing::AssertionSuccess();</span>
<a name="l00195"></a>00195 <span class="comment">//     else</span>
<a name="l00196"></a>00196 <span class="comment">//       return testing::AssertionFailure() &lt;&lt; n &lt;&lt; &quot; is odd&quot;;</span>
<a name="l00197"></a>00197 <span class="comment">//   }</span>
<a name="l00198"></a>00198 <span class="comment">//</span>
<a name="l00199"></a>00199 <span class="comment">// Then the failed expectation EXPECT_TRUE(IsEven(Fib(5)))</span>
<a name="l00200"></a>00200 <span class="comment">// will print the message</span>
<a name="l00201"></a>00201 <span class="comment">//</span>
<a name="l00202"></a>00202 <span class="comment">//   Value of: IsEven(Fib(5))</span>
<a name="l00203"></a>00203 <span class="comment">//     Actual: false (5 is odd)</span>
<a name="l00204"></a>00204 <span class="comment">//   Expected: true</span>
<a name="l00205"></a>00205 <span class="comment">//</span>
<a name="l00206"></a>00206 <span class="comment">// instead of a more opaque</span>
<a name="l00207"></a>00207 <span class="comment">//</span>
<a name="l00208"></a>00208 <span class="comment">//   Value of: IsEven(Fib(5))</span>
<a name="l00209"></a>00209 <span class="comment">//     Actual: false</span>
<a name="l00210"></a>00210 <span class="comment">//   Expected: true</span>
<a name="l00211"></a>00211 <span class="comment">//</span>
<a name="l00212"></a>00212 <span class="comment">// in case IsEven is a simple Boolean predicate.</span>
<a name="l00213"></a>00213 <span class="comment">//</span>
<a name="l00214"></a>00214 <span class="comment">// If you expect your predicate to be reused and want to support informative</span>
<a name="l00215"></a>00215 <span class="comment">// messages in EXPECT_FALSE and ASSERT_FALSE (negative assertions show up</span>
<a name="l00216"></a>00216 <span class="comment">// about half as often as positive ones in our tests), supply messages for</span>
<a name="l00217"></a>00217 <span class="comment">// both success and failure cases:</span>
<a name="l00218"></a>00218 <span class="comment">//</span>
<a name="l00219"></a>00219 <span class="comment">//   testing::AssertionResult IsEven(int n) {</span>
<a name="l00220"></a>00220 <span class="comment">//     if ((n % 2) == 0)</span>
<a name="l00221"></a>00221 <span class="comment">//       return testing::AssertionSuccess() &lt;&lt; n &lt;&lt; &quot; is even&quot;;</span>
<a name="l00222"></a>00222 <span class="comment">//     else</span>
<a name="l00223"></a>00223 <span class="comment">//       return testing::AssertionFailure() &lt;&lt; n &lt;&lt; &quot; is odd&quot;;</span>
<a name="l00224"></a>00224 <span class="comment">//   }</span>
<a name="l00225"></a>00225 <span class="comment">//</span>
<a name="l00226"></a>00226 <span class="comment">// Then a statement EXPECT_FALSE(IsEven(Fib(6))) will print</span>
<a name="l00227"></a>00227 <span class="comment">//</span>
<a name="l00228"></a>00228 <span class="comment">//   Value of: IsEven(Fib(6))</span>
<a name="l00229"></a>00229 <span class="comment">//     Actual: true (8 is even)</span>
<a name="l00230"></a>00230 <span class="comment">//   Expected: false</span>
<a name="l00231"></a>00231 <span class="comment">//</span>
<a name="l00232"></a>00232 <span class="comment">// NB: Predicates that support negative Boolean assertions have reduced</span>
<a name="l00233"></a>00233 <span class="comment">// performance in positive ones so be careful not to use them in tests</span>
<a name="l00234"></a>00234 <span class="comment">// that have lots (tens of thousands) of positive Boolean assertions.</span>
<a name="l00235"></a>00235 <span class="comment">//</span>
<a name="l00236"></a>00236 <span class="comment">// To use this class with EXPECT_PRED_FORMAT assertions such as:</span>
<a name="l00237"></a>00237 <span class="comment">//</span>
<a name="l00238"></a>00238 <span class="comment">//   // Verifies that Foo() returns an even number.</span>
<a name="l00239"></a>00239 <span class="comment">//   EXPECT_PRED_FORMAT1(IsEven, Foo());</span>
<a name="l00240"></a>00240 <span class="comment">//</span>
<a name="l00241"></a>00241 <span class="comment">// you need to define:</span>
<a name="l00242"></a>00242 <span class="comment">//</span>
<a name="l00243"></a>00243 <span class="comment">//   testing::AssertionResult IsEven(const char* expr, int n) {</span>
<a name="l00244"></a>00244 <span class="comment">//     if ((n % 2) == 0)</span>
<a name="l00245"></a>00245 <span class="comment">//       return testing::AssertionSuccess();</span>
<a name="l00246"></a>00246 <span class="comment">//     else</span>
<a name="l00247"></a>00247 <span class="comment">//       return testing::AssertionFailure()</span>
<a name="l00248"></a>00248 <span class="comment">//         &lt;&lt; &quot;Expected: &quot; &lt;&lt; expr &lt;&lt; &quot; is even\n  Actual: it&#39;s &quot; &lt;&lt; n;</span>
<a name="l00249"></a>00249 <span class="comment">//   }</span>
<a name="l00250"></a>00250 <span class="comment">//</span>
<a name="l00251"></a>00251 <span class="comment">// If Foo() returns 5, you will see the following message:</span>
<a name="l00252"></a>00252 <span class="comment">//</span>
<a name="l00253"></a>00253 <span class="comment">//   Expected: Foo() is even</span>
<a name="l00254"></a>00254 <span class="comment">//     Actual: it&#39;s 5</span>
<a name="l00255"></a>00255 <span class="comment">//</span>
<a name="l00256"></a><a class="code" href="classtesting_1_1AssertionResult.html">00256</a> <span class="keyword">class </span><a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> {
<a name="l00257"></a>00257  <span class="keyword">public</span>:
<a name="l00258"></a>00258   <span class="comment">// Copy constructor.</span>
<a name="l00259"></a>00259   <span class="comment">// Used in EXPECT_TRUE/FALSE(assertion_result).</span>
<a name="l00260"></a>00260   <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a>&amp; other);
<a name="l00261"></a>00261 
<a name="l00262"></a>00262   <a class="code" href="gtest-port_8h.html#a86994cc68e844d8b82089c70408dfc61">GTEST_DISABLE_MSC_WARNINGS_PUSH_</a>(4800 <span class="comment">/* forcing value to bool */</span>)
<a name="l00263"></a>00263 
<a name="l00264"></a>00264   <span class="comment">// Used in the EXPECT_TRUE/FALSE(bool_expression).</span>
<a name="l00265"></a>00265   <span class="comment">//</span>
<a name="l00266"></a>00266   <span class="comment">// T must be contextually convertible to bool.</span>
<a name="l00267"></a>00267   <span class="comment">//</span>
<a name="l00268"></a>00268   <span class="comment">// The second parameter prevents this overload from being considered if</span>
<a name="l00269"></a>00269   <span class="comment">// the argument is implicitly convertible to AssertionResult. In that case</span>
<a name="l00270"></a>00270   <span class="comment">// we want AssertionResult&#39;s copy constructor to be used.</span>
<a name="l00271"></a>00271   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00272"></a><a class="code" href="classtesting_1_1AssertionResult.html#a9b8d1d6d0a979d0769ed4ff97d06c4e3">00272</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a>(
<a name="l00273"></a>00273       <span class="keyword">const</span> T&amp; success,
<a name="l00274"></a>00274       <span class="keyword">typename</span> internal::EnableIf&lt;
<a name="l00275"></a>00275           !<a class="code" href="classtesting_1_1internal_1_1ImplicitlyConvertible.html">internal::ImplicitlyConvertible&lt;T, AssertionResult&gt;::value</a>&gt;::type*
<a name="l00276"></a>00276           <span class="comment">/*enabler*/</span> = NULL)
<a name="l00277"></a>00277       : success_(success) {}
<a name="l00278"></a>00278 
<a name="l00279"></a>00279   <a class="code" href="gtest-port_8h.html#ab4c44546d6d9aced68993b87b608fc06">GTEST_DISABLE_MSC_WARNINGS_POP_</a>()
<a name="l00280"></a>00280 
<a name="l00281"></a>00281   <span class="comment">// Assignment operator.</span>
<a name="l00282"></a><a class="code" href="classtesting_1_1AssertionResult.html#aad9274c7b69eda67eb9306963a790839">00282</a>   <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a>&amp; operator=(<a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> other) {
<a name="l00283"></a>00283     swap(other);
<a name="l00284"></a>00284     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00285"></a>00285   }
<a name="l00286"></a>00286 
<a name="l00287"></a>00287   <span class="comment">// Returns true iff the assertion succeeded.</span>
<a name="l00288"></a><a class="code" href="classtesting_1_1AssertionResult.html#af85b7852e6399467cd74df539810abcd">00288</a>   <a class="code" href="classtesting_1_1AssertionResult.html#af85b7852e6399467cd74df539810abcd">operator bool</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> success_; }  <span class="comment">// NOLINT</span>
<a name="l00289"></a>00289 
<a name="l00290"></a>00290   <span class="comment">// Returns the assertion&#39;s negation. Used with EXPECT/ASSERT_FALSE.</span>
<a name="l00291"></a>00291   <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> operator!() <span class="keyword">const</span>;
<a name="l00292"></a>00292 
<a name="l00293"></a>00293   <span class="comment">// Returns the text streamed into this AssertionResult. Test assertions</span>
<a name="l00294"></a>00294   <span class="comment">// use it when they fail (i.e., the predicate&#39;s outcome doesn&#39;t match the</span>
<a name="l00295"></a>00295   <span class="comment">// assertion&#39;s expectation). When nothing has been streamed into the</span>
<a name="l00296"></a>00296   <span class="comment">// object, returns an empty string.</span>
<a name="l00297"></a><a class="code" href="classtesting_1_1AssertionResult.html#ab20c91eba13e20f1b4ad89e3d15f69a8">00297</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1AssertionResult.html#ab20c91eba13e20f1b4ad89e3d15f69a8">message</a>()<span class="keyword"> const </span>{
<a name="l00298"></a>00298     <span class="keywordflow">return</span> message_.get() != NULL ?  message_-&gt;c_str() : <span class="stringliteral">&quot;&quot;</span>;
<a name="l00299"></a>00299   }
<a name="l00300"></a>00300   <span class="comment">// TODO(vladl@google.com): Remove this after making sure no clients use it.</span>
<a name="l00301"></a>00301   <span class="comment">// Deprecated; please use message() instead.</span>
<a name="l00302"></a><a class="code" href="classtesting_1_1AssertionResult.html#ae54fa82506c507a9dbc0f85d2cec652a">00302</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1AssertionResult.html#ae54fa82506c507a9dbc0f85d2cec652a">failure_message</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> message(); }
<a name="l00303"></a>00303 
<a name="l00304"></a>00304   <span class="comment">// Streams a custom failure message into this object.</span>
<a name="l00305"></a><a class="code" href="classtesting_1_1AssertionResult.html#a3230efa81aafe7c61f5fb878cfa39e91">00305</a>   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a>&amp; <a class="code" href="classtesting_1_1AssertionResult.html#a3230efa81aafe7c61f5fb878cfa39e91">operator&lt;&lt;</a>(<span class="keyword">const</span> T&amp; value) {
<a name="l00306"></a>00306     AppendMessage(<a class="code" href="classtesting_1_1Message.html">Message</a>() &lt;&lt; value);
<a name="l00307"></a>00307     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00308"></a>00308   }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310   <span class="comment">// Allows streaming basic output manipulators such as endl or flush into</span>
<a name="l00311"></a>00311   <span class="comment">// this object.</span>
<a name="l00312"></a><a class="code" href="classtesting_1_1AssertionResult.html#a43ae8a260843ce2ff3dc9af262672b8b">00312</a>   <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a>&amp; <a class="code" href="namespacetesting.html#a7b802e532fd68749765cb7dc156130db">operator&lt;&lt;</a>(
<a name="l00313"></a>00313       ::std::ostream&amp; (*basic_manipulator)(::std::ostream&amp; stream)) {
<a name="l00314"></a>00314     AppendMessage(<a class="code" href="classtesting_1_1Message.html">Message</a>() &lt;&lt; basic_manipulator);
<a name="l00315"></a>00315     <span class="keywordflow">return</span> *<span class="keyword">this</span>;
<a name="l00316"></a>00316   }
<a name="l00317"></a>00317 
<a name="l00318"></a>00318  <span class="keyword">private</span>:
<a name="l00319"></a>00319   <span class="comment">// Appends the contents of message to message_.</span>
<a name="l00320"></a>00320   <span class="keywordtype">void</span> AppendMessage(<span class="keyword">const</span> <a class="code" href="classtesting_1_1Message.html">Message</a>&amp; a_message) {
<a name="l00321"></a>00321     <span class="keywordflow">if</span> (message_.get() == NULL)
<a name="l00322"></a>00322       message_.reset(<a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">new ::std::string</a>);
<a name="l00323"></a>00323     message_-&gt;append(a_message.<a class="code" href="classtesting_1_1Message.html#abe8c1b7584aa670dd0e2413e8317a937">GetString</a>().c_str());
<a name="l00324"></a>00324   }
<a name="l00325"></a>00325 
<a name="l00326"></a>00326   <span class="comment">// Swap the contents of this AssertionResult with other.</span>
<a name="l00327"></a>00327   <span class="keywordtype">void</span> swap(AssertionResult&amp; other);
<a name="l00328"></a>00328 
<a name="l00329"></a>00329   <span class="comment">// Stores result of the assertion predicate.</span>
<a name="l00330"></a>00330   <span class="keywordtype">bool</span> success_;
<a name="l00331"></a>00331   <span class="comment">// Stores the message describing the condition in case the expectation</span>
<a name="l00332"></a>00332   <span class="comment">// construct is not satisfied with the predicate&#39;s outcome.</span>
<a name="l00333"></a>00333   <span class="comment">// Referenced via a pointer to avoid taking too much stack frame space</span>
<a name="l00334"></a>00334   <span class="comment">// with test assertions.</span>
<a name="l00335"></a>00335   internal::scoped_ptr&lt; ::std::string&gt; message_;
<a name="l00336"></a>00336 };
<a name="l00337"></a>00337 
<a name="l00338"></a>00338 <span class="comment">// Makes a successful assertion result.</span>
<a name="l00339"></a>00339 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#a74a3d26c1286bd4d7c189c5dff2483ab">AssertionSuccess</a>();
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 <span class="comment">// Makes a failed assertion result.</span>
<a name="l00342"></a>00342 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#a8d91083190a5914bfe8c5666e2dbca9b">AssertionFailure</a>();
<a name="l00343"></a>00343 
<a name="l00344"></a>00344 <span class="comment">// Makes a failed assertion result with the given failure message.</span>
<a name="l00345"></a>00345 <span class="comment">// Deprecated; use AssertionFailure() &lt;&lt; msg.</span>
<a name="l00346"></a>00346 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#a8d91083190a5914bfe8c5666e2dbca9b">AssertionFailure</a>(<span class="keyword">const</span> Message&amp; msg);
<a name="l00347"></a>00347 
<a name="l00348"></a>00348 <span class="comment">// The abstract class that all tests inherit from.</span>
<a name="l00349"></a>00349 <span class="comment">//</span>
<a name="l00350"></a>00350 <span class="comment">// In Google Test, a unit test program contains one or many TestCases, and</span>
<a name="l00351"></a>00351 <span class="comment">// each TestCase contains one or many Tests.</span>
<a name="l00352"></a>00352 <span class="comment">//</span>
<a name="l00353"></a>00353 <span class="comment">// When you define a test using the TEST macro, you don&#39;t need to</span>
<a name="l00354"></a>00354 <span class="comment">// explicitly derive from Test - the TEST macro automatically does</span>
<a name="l00355"></a>00355 <span class="comment">// this for you.</span>
<a name="l00356"></a>00356 <span class="comment">//</span>
<a name="l00357"></a>00357 <span class="comment">// The only time you derive from Test is when defining a test fixture</span>
<a name="l00358"></a>00358 <span class="comment">// to be used a TEST_F.  For example:</span>
<a name="l00359"></a>00359 <span class="comment">//</span>
<a name="l00360"></a>00360 <span class="comment">//   class FooTest : public testing::Test {</span>
<a name="l00361"></a>00361 <span class="comment">//    protected:</span>
<a name="l00362"></a>00362 <span class="comment">//     void SetUp() override { ... }</span>
<a name="l00363"></a>00363 <span class="comment">//     void TearDown() override { ... }</span>
<a name="l00364"></a>00364 <span class="comment">//     ...</span>
<a name="l00365"></a>00365 <span class="comment">//   };</span>
<a name="l00366"></a>00366 <span class="comment">//</span>
<a name="l00367"></a>00367 <span class="comment">//   TEST_F(FooTest, Bar) { ... }</span>
<a name="l00368"></a>00368 <span class="comment">//   TEST_F(FooTest, Baz) { ... }</span>
<a name="l00369"></a>00369 <span class="comment">//</span>
<a name="l00370"></a>00370 <span class="comment">// Test is not copyable.</span>
<a name="l00371"></a><a class="code" href="classtesting_1_1Test.html">00371</a> <span class="keyword">class </span><a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> <a class="code" href="classtesting_1_1Test.html">Test</a> {
<a name="l00372"></a>00372  <span class="keyword">public</span>:
<a name="l00373"></a><a class="code" href="classtesting_1_1Test.html#a4c49c2cdb6c328e6b709b4542f23de3c">00373</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>;
<a name="l00374"></a>00374 
<a name="l00375"></a>00375   <span class="comment">// Defines types for pointers to functions that set up and tear down</span>
<a name="l00376"></a>00376   <span class="comment">// a test case.</span>
<a name="l00377"></a><a class="code" href="classtesting_1_1Test.html#a5f2a051d1d99c9b784c666c586186cf9">00377</a>   <span class="keyword">typedef</span> <a class="code" href="namespacetesting_1_1internal.html#ada14d66b5460b20e09071f51b9885c8d">internal::SetUpTestCaseFunc</a> <a class="code" href="classtesting_1_1Test.html#a5f2a051d1d99c9b784c666c586186cf9">SetUpTestCaseFunc</a>;
<a name="l00378"></a><a class="code" href="classtesting_1_1Test.html#aa0f532e93b9f3500144c53f31466976c">00378</a>   <span class="keyword">typedef</span> <a class="code" href="namespacetesting_1_1internal.html#aad40244621b68546f3b830696225bf9b">internal::TearDownTestCaseFunc</a> <a class="code" href="classtesting_1_1Test.html#aa0f532e93b9f3500144c53f31466976c">TearDownTestCaseFunc</a>;
<a name="l00379"></a>00379 
<a name="l00380"></a>00380   <span class="comment">// The d&#39;tor is virtual as we intend to inherit from Test.</span>
<a name="l00381"></a>00381   <span class="keyword">virtual</span> ~<a class="code" href="classtesting_1_1Test.html">Test</a>();
<a name="l00382"></a>00382 
<a name="l00383"></a>00383   <span class="comment">// Sets up the stuff shared by all tests in this test case.</span>
<a name="l00384"></a>00384   <span class="comment">//</span>
<a name="l00385"></a>00385   <span class="comment">// Google Test will call Foo::SetUpTestCase() before running the first</span>
<a name="l00386"></a>00386   <span class="comment">// test in test case Foo.  Hence a sub-class can define its own</span>
<a name="l00387"></a>00387   <span class="comment">// SetUpTestCase() method to shadow the one defined in the super</span>
<a name="l00388"></a>00388   <span class="comment">// class.</span>
<a name="l00389"></a><a class="code" href="classtesting_1_1Test.html#a5ccbac42fee8c5b00b0bfe89b6c49d79">00389</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Test.html#a5ccbac42fee8c5b00b0bfe89b6c49d79">SetUpTestCase</a>() {}
<a name="l00390"></a>00390 
<a name="l00391"></a>00391   <span class="comment">// Tears down the stuff shared by all tests in this test case.</span>
<a name="l00392"></a>00392   <span class="comment">//</span>
<a name="l00393"></a>00393   <span class="comment">// Google Test will call Foo::TearDownTestCase() after running the last</span>
<a name="l00394"></a>00394   <span class="comment">// test in test case Foo.  Hence a sub-class can define its own</span>
<a name="l00395"></a>00395   <span class="comment">// TearDownTestCase() method to shadow the one defined in the super</span>
<a name="l00396"></a>00396   <span class="comment">// class.</span>
<a name="l00397"></a><a class="code" href="classtesting_1_1Test.html#af374706cbaf0ffc460f4fd04e7c150f1">00397</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Test.html#af374706cbaf0ffc460f4fd04e7c150f1">TearDownTestCase</a>() {}
<a name="l00398"></a>00398 
<a name="l00399"></a>00399   <span class="comment">// Returns true iff the current test has a fatal failure.</span>
<a name="l00400"></a>00400   <span class="keyword">static</span> <span class="keywordtype">bool</span> HasFatalFailure();
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   <span class="comment">// Returns true iff the current test has a non-fatal failure.</span>
<a name="l00403"></a>00403   <span class="keyword">static</span> <span class="keywordtype">bool</span> HasNonfatalFailure();
<a name="l00404"></a>00404 
<a name="l00405"></a>00405   <span class="comment">// Returns true iff the current test has a (either fatal or</span>
<a name="l00406"></a>00406   <span class="comment">// non-fatal) failure.</span>
<a name="l00407"></a><a class="code" href="classtesting_1_1Test.html#a7a00be7dd0a6bfdc8d47a1b784623613">00407</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1Test.html#a7a00be7dd0a6bfdc8d47a1b784623613">HasFailure</a>() { <span class="keywordflow">return</span> HasFatalFailure() || HasNonfatalFailure(); }
<a name="l00408"></a>00408 
<a name="l00409"></a>00409   <span class="comment">// Logs a property for the current test, test case, or for the entire</span>
<a name="l00410"></a>00410   <span class="comment">// invocation of the test program when used outside of the context of a</span>
<a name="l00411"></a>00411   <span class="comment">// test case.  Only the last value for a given key is remembered.  These</span>
<a name="l00412"></a>00412   <span class="comment">// are public static so they can be called from utility functions that are</span>
<a name="l00413"></a>00413   <span class="comment">// not members of the test fixture.  Calls to RecordProperty made during</span>
<a name="l00414"></a>00414   <span class="comment">// lifespan of the test (from the moment its constructor starts to the</span>
<a name="l00415"></a>00415   <span class="comment">// moment its destructor finishes) will be output in XML as attributes of</span>
<a name="l00416"></a>00416   <span class="comment">// the &lt;testcase&gt; element.  Properties recorded from fixture&#39;s</span>
<a name="l00417"></a>00417   <span class="comment">// SetUpTestCase or TearDownTestCase are logged as attributes of the</span>
<a name="l00418"></a>00418   <span class="comment">// corresponding &lt;testsuite&gt; element.  Calls to RecordProperty made in the</span>
<a name="l00419"></a>00419   <span class="comment">// global context (before or after invocation of RUN_ALL_TESTS and from</span>
<a name="l00420"></a>00420   <span class="comment">// SetUp/TearDown method of Environment objects registered with Google</span>
<a name="l00421"></a>00421   <span class="comment">// Test) will be output as attributes of the &lt;testsuites&gt; element.</span>
<a name="l00422"></a>00422   <span class="keyword">static</span> <span class="keywordtype">void</span> RecordProperty(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; key, <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; value);
<a name="l00423"></a>00423   <span class="keyword">static</span> <span class="keywordtype">void</span> RecordProperty(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; key, <span class="keywordtype">int</span> value);
<a name="l00424"></a>00424 
<a name="l00425"></a>00425  <span class="keyword">protected</span>:
<a name="l00426"></a>00426   <span class="comment">// Creates a Test object.</span>
<a name="l00427"></a>00427   <a class="code" href="classtesting_1_1Test.html">Test</a>();
<a name="l00428"></a>00428 
<a name="l00429"></a>00429   <span class="comment">// Sets up the test fixture.</span>
<a name="l00430"></a>00430   <span class="keyword">virtual</span> <span class="keywordtype">void</span> SetUp();
<a name="l00431"></a>00431 
<a name="l00432"></a>00432   <span class="comment">// Tears down the test fixture.</span>
<a name="l00433"></a>00433   <span class="keyword">virtual</span> <span class="keywordtype">void</span> TearDown();
<a name="l00434"></a>00434 
<a name="l00435"></a>00435  <span class="keyword">private</span>:
<a name="l00436"></a>00436   <span class="comment">// Returns true iff the current test has the same fixture class as</span>
<a name="l00437"></a>00437   <span class="comment">// the first test in the current test case.</span>
<a name="l00438"></a>00438   <span class="keyword">static</span> <span class="keywordtype">bool</span> HasSameFixtureClass();
<a name="l00439"></a>00439 
<a name="l00440"></a>00440   <span class="comment">// Runs the test after the test fixture has been set up.</span>
<a name="l00441"></a>00441   <span class="comment">//</span>
<a name="l00442"></a>00442   <span class="comment">// A sub-class must implement this to define the test logic.</span>
<a name="l00443"></a>00443   <span class="comment">//</span>
<a name="l00444"></a>00444   <span class="comment">// DO NOT OVERRIDE THIS FUNCTION DIRECTLY IN A USER PROGRAM.</span>
<a name="l00445"></a>00445   <span class="comment">// Instead, use the TEST or TEST_F macro.</span>
<a name="l00446"></a>00446   <span class="keyword">virtual</span> <span class="keywordtype">void</span> TestBody() = 0;
<a name="l00447"></a>00447 
<a name="l00448"></a>00448   <span class="comment">// Sets up, executes, and tears down the test.</span>
<a name="l00449"></a>00449   <span class="keywordtype">void</span> Run();
<a name="l00450"></a>00450 
<a name="l00451"></a>00451   <span class="comment">// Deletes self.  We deliberately pick an unusual name for this</span>
<a name="l00452"></a>00452   <span class="comment">// internal method to avoid clashing with names used in user TESTs.</span>
<a name="l00453"></a>00453   <span class="keywordtype">void</span> DeleteSelf_() { <span class="keyword">delete</span> <span class="keyword">this</span>; }
<a name="l00454"></a>00454 
<a name="l00455"></a>00455   <span class="keyword">const</span> internal::scoped_ptr&lt; GTEST_FLAG_SAVER_ &gt; gtest_flag_saver_;
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   <span class="comment">// Often a user misspells SetUp() as Setup() and spends a long time</span>
<a name="l00458"></a>00458   <span class="comment">// wondering why it is never called by Google Test.  The declaration of</span>
<a name="l00459"></a>00459   <span class="comment">// the following method is solely for catching such an error at</span>
<a name="l00460"></a>00460   <span class="comment">// compile time:</span>
<a name="l00461"></a>00461   <span class="comment">//</span>
<a name="l00462"></a>00462   <span class="comment">//   - The return type is deliberately chosen to be not void, so it</span>
<a name="l00463"></a>00463   <span class="comment">//   will be a conflict if void Setup() is declared in the user&#39;s</span>
<a name="l00464"></a>00464   <span class="comment">//   test fixture.</span>
<a name="l00465"></a>00465   <span class="comment">//</span>
<a name="l00466"></a>00466   <span class="comment">//   - This method is private, so it will be another compiler error</span>
<a name="l00467"></a>00467   <span class="comment">//   if the method is called from the user&#39;s test fixture.</span>
<a name="l00468"></a>00468   <span class="comment">//</span>
<a name="l00469"></a>00469   <span class="comment">// DO NOT OVERRIDE THIS FUNCTION.</span>
<a name="l00470"></a>00470   <span class="comment">//</span>
<a name="l00471"></a>00471   <span class="comment">// If you see an error about overriding the following function or</span>
<a name="l00472"></a>00472   <span class="comment">// about it being private, you have mis-spelled SetUp() as Setup().</span>
<a name="l00473"></a>00473   <span class="keyword">struct </span>Setup_should_be_spelled_SetUp {};
<a name="l00474"></a>00474   <span class="keyword">virtual</span> Setup_should_be_spelled_SetUp* Setup() { <span class="keywordflow">return</span> NULL; }
<a name="l00475"></a>00475 
<a name="l00476"></a>00476   <span class="comment">// We disallow copying Tests.</span>
<a name="l00477"></a>00477   <a class="code" href="gtest-port_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(Test);
<a name="l00478"></a>00478 };
<a name="l00479"></a>00479 
<a name="l00480"></a><a class="code" href="namespacetesting.html#a992de1d091ce660f451d1e8b3ce30fd6">00480</a> <span class="keyword">typedef</span> <a class="code" href="namespacetesting_1_1internal.html#a66a845df404b38fe85c5e14a069f255a">internal::TimeInMillis</a> <a class="code" href="namespacetesting.html#a992de1d091ce660f451d1e8b3ce30fd6">TimeInMillis</a>;
<a name="l00481"></a>00481 
<a name="l00482"></a>00482 <span class="comment">// A copyable object representing a user specified test property which can be</span>
<a name="l00483"></a>00483 <span class="comment">// output as a key/value string pair.</span>
<a name="l00484"></a>00484 <span class="comment">//</span>
<a name="l00485"></a>00485 <span class="comment">// Don&#39;t inherit from TestProperty as its destructor is not virtual.</span>
<a name="l00486"></a><a class="code" href="classtesting_1_1TestProperty.html">00486</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1TestProperty.html">TestProperty</a> {
<a name="l00487"></a>00487  <span class="keyword">public</span>:
<a name="l00488"></a>00488   <span class="comment">// C&#39;tor.  TestProperty does NOT have a default constructor.</span>
<a name="l00489"></a>00489   <span class="comment">// Always use this constructor (with parameters) to create a</span>
<a name="l00490"></a>00490   <span class="comment">// TestProperty object.</span>
<a name="l00491"></a><a class="code" href="classtesting_1_1TestProperty.html#a25a0ccf1c75a92af46a48d3c2a873e6d">00491</a>   <a class="code" href="classtesting_1_1TestProperty.html#a25a0ccf1c75a92af46a48d3c2a873e6d">TestProperty</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; a_key, <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; a_value) :
<a name="l00492"></a>00492     key_(a_key), value_(a_value) {
<a name="l00493"></a>00493   }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495   <span class="comment">// Gets the user supplied key.</span>
<a name="l00496"></a><a class="code" href="classtesting_1_1TestProperty.html#a2c569d47685b89aa64e737fb11df3aba">00496</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestProperty.html#a2c569d47685b89aa64e737fb11df3aba">key</a>()<span class="keyword"> const </span>{
<a name="l00497"></a>00497     <span class="keywordflow">return</span> key_.c_str();
<a name="l00498"></a>00498   }
<a name="l00499"></a>00499 
<a name="l00500"></a>00500   <span class="comment">// Gets the user supplied value.</span>
<a name="l00501"></a><a class="code" href="classtesting_1_1TestProperty.html#ad46323c18491f365d72d8a4288f54bd6">00501</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestProperty.html#ad46323c18491f365d72d8a4288f54bd6">value</a>()<span class="keyword"> const </span>{
<a name="l00502"></a>00502     <span class="keywordflow">return</span> value_.c_str();
<a name="l00503"></a>00503   }
<a name="l00504"></a>00504 
<a name="l00505"></a>00505   <span class="comment">// Sets a new value, overriding the one supplied in the constructor.</span>
<a name="l00506"></a><a class="code" href="classtesting_1_1TestProperty.html#a377245335d9f614cd06d1650e3358e1d">00506</a>   <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestProperty.html#a377245335d9f614cd06d1650e3358e1d">SetValue</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; new_value) {
<a name="l00507"></a>00507     value_ = new_value;
<a name="l00508"></a>00508   }
<a name="l00509"></a>00509 
<a name="l00510"></a>00510  <span class="keyword">private</span>:
<a name="l00511"></a>00511   <span class="comment">// The key supplied by the user.</span>
<a name="l00512"></a>00512   <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a> key_;
<a name="l00513"></a>00513   <span class="comment">// The value supplied by the user.</span>
<a name="l00514"></a>00514   <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a> value_;
<a name="l00515"></a>00515 };
<a name="l00516"></a>00516 
<a name="l00517"></a>00517 <span class="comment">// The result of a single Test.  This includes a list of</span>
<a name="l00518"></a>00518 <span class="comment">// TestPartResults, a list of TestProperties, a count of how many</span>
<a name="l00519"></a>00519 <span class="comment">// death tests there are in the Test, and how much time it took to run</span>
<a name="l00520"></a>00520 <span class="comment">// the Test.</span>
<a name="l00521"></a>00521 <span class="comment">//</span>
<a name="l00522"></a>00522 <span class="comment">// TestResult is not copyable.</span>
<a name="l00523"></a><a class="code" href="classtesting_1_1TestResult.html">00523</a> <span class="keyword">class </span><a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> <a class="code" href="classtesting_1_1TestResult.html">TestResult</a> {
<a name="l00524"></a>00524  <span class="keyword">public</span>:
<a name="l00525"></a>00525   <span class="comment">// Creates an empty TestResult.</span>
<a name="l00526"></a>00526   <a class="code" href="classtesting_1_1TestResult.html">TestResult</a>();
<a name="l00527"></a>00527 
<a name="l00528"></a>00528   <span class="comment">// D&#39;tor.  Do not inherit from TestResult.</span>
<a name="l00529"></a>00529   ~<a class="code" href="classtesting_1_1TestResult.html">TestResult</a>();
<a name="l00530"></a>00530 
<a name="l00531"></a>00531   <span class="comment">// Gets the number of all test parts.  This is the sum of the number</span>
<a name="l00532"></a>00532   <span class="comment">// of successful test parts and the number of failed test parts.</span>
<a name="l00533"></a>00533   <span class="keywordtype">int</span> total_part_count() <span class="keyword">const</span>;
<a name="l00534"></a>00534 
<a name="l00535"></a>00535   <span class="comment">// Returns the number of the test properties.</span>
<a name="l00536"></a>00536   <span class="keywordtype">int</span> test_property_count() <span class="keyword">const</span>;
<a name="l00537"></a>00537 
<a name="l00538"></a>00538   <span class="comment">// Returns true iff the test passed (i.e. no test part failed).</span>
<a name="l00539"></a><a class="code" href="classtesting_1_1TestResult.html#aa46a04342f02ec297357f47288da3ef3">00539</a>   <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1TestResult.html#aa46a04342f02ec297357f47288da3ef3">Passed</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !Failed(); }
<a name="l00540"></a>00540 
<a name="l00541"></a>00541   <span class="comment">// Returns true iff the test failed.</span>
<a name="l00542"></a>00542   <span class="keywordtype">bool</span> Failed() <span class="keyword">const</span>;
<a name="l00543"></a>00543 
<a name="l00544"></a>00544   <span class="comment">// Returns true iff the test fatally failed.</span>
<a name="l00545"></a>00545   <span class="keywordtype">bool</span> HasFatalFailure() <span class="keyword">const</span>;
<a name="l00546"></a>00546 
<a name="l00547"></a>00547   <span class="comment">// Returns true iff the test has a non-fatal failure.</span>
<a name="l00548"></a>00548   <span class="keywordtype">bool</span> HasNonfatalFailure() <span class="keyword">const</span>;
<a name="l00549"></a>00549 
<a name="l00550"></a>00550   <span class="comment">// Returns the elapsed time, in milliseconds.</span>
<a name="l00551"></a><a class="code" href="classtesting_1_1TestResult.html#a582f6383265d0619df812b75499d0616">00551</a>   <a class="code" href="namespacetesting.html#a992de1d091ce660f451d1e8b3ce30fd6">TimeInMillis</a> <a class="code" href="classtesting_1_1TestResult.html#a582f6383265d0619df812b75499d0616">elapsed_time</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> elapsed_time_; }
<a name="l00552"></a>00552 
<a name="l00553"></a>00553   <span class="comment">// Returns the i-th test part result among all the results. i can range</span>
<a name="l00554"></a>00554   <span class="comment">// from 0 to test_property_count() - 1. If i is not in that range, aborts</span>
<a name="l00555"></a>00555   <span class="comment">// the program.</span>
<a name="l00556"></a>00556   <span class="keyword">const</span> <a class="code" href="classtesting_1_1TestPartResult.html">TestPartResult</a>&amp; GetTestPartResult(<span class="keywordtype">int</span> i) <span class="keyword">const</span>;
<a name="l00557"></a>00557 
<a name="l00558"></a>00558   <span class="comment">// Returns the i-th test property. i can range from 0 to</span>
<a name="l00559"></a>00559   <span class="comment">// test_property_count() - 1. If i is not in that range, aborts the</span>
<a name="l00560"></a>00560   <span class="comment">// program.</span>
<a name="l00561"></a>00561   <span class="keyword">const</span> <a class="code" href="classtesting_1_1TestProperty.html">TestProperty</a>&amp; GetTestProperty(<span class="keywordtype">int</span> i) <span class="keyword">const</span>;
<a name="l00562"></a>00562 
<a name="l00563"></a>00563  <span class="keyword">private</span>:
<a name="l00564"></a><a class="code" href="classtesting_1_1TestResult.html#a4c49c2cdb6c328e6b709b4542f23de3c">00564</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>;
<a name="l00565"></a><a class="code" href="classtesting_1_1TestResult.html#aff779e55b06adfa7c0088bd10253f0f0">00565</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1TestCase.html">TestCase</a>;
<a name="l00566"></a><a class="code" href="classtesting_1_1TestResult.html#a832b4d233efee1a32feb0f4190b30d39">00566</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>;
<a name="l00567"></a><a class="code" href="classtesting_1_1TestResult.html#abae39633da9932847b41cb80efd62115">00567</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1DefaultGlobalTestPartResultReporter.html">internal::DefaultGlobalTestPartResultReporter</a>;
<a name="l00568"></a><a class="code" href="classtesting_1_1TestResult.html#adf5553cae6aea6f8648d47e299237e34">00568</a>   <span class="keyword">friend</span> <span class="keyword">class </span>internal::ExecDeathTest;
<a name="l00569"></a><a class="code" href="classtesting_1_1TestResult.html#ae762da04e74a0d3b0daded3c5bd4a8e8">00569</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1TestResultAccessor.html">internal::TestResultAccessor</a>;
<a name="l00570"></a><a class="code" href="classtesting_1_1TestResult.html#acc0a5e7573fd6ae7ad1878613bb86853">00570</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1UnitTestImpl.html">internal::UnitTestImpl</a>;
<a name="l00571"></a><a class="code" href="classtesting_1_1TestResult.html#a6aeedc04a0590fcc1b3c5f687dbb0f9f">00571</a>   <span class="keyword">friend</span> <span class="keyword">class </span>internal::WindowsDeathTest;
<a name="l00572"></a>00572 
<a name="l00573"></a>00573   <span class="comment">// Gets the vector of TestPartResults.</span>
<a name="l00574"></a>00574   <span class="keyword">const</span> std::vector&lt;TestPartResult&gt;&amp; test_part_results()<span class="keyword"> const </span>{
<a name="l00575"></a>00575     <span class="keywordflow">return</span> test_part_results_;
<a name="l00576"></a>00576   }
<a name="l00577"></a>00577 
<a name="l00578"></a>00578   <span class="comment">// Gets the vector of TestProperties.</span>
<a name="l00579"></a>00579   <span class="keyword">const</span> std::vector&lt;TestProperty&gt;&amp; test_properties()<span class="keyword"> const </span>{
<a name="l00580"></a>00580     <span class="keywordflow">return</span> test_properties_;
<a name="l00581"></a>00581   }
<a name="l00582"></a>00582 
<a name="l00583"></a>00583   <span class="comment">// Sets the elapsed time.</span>
<a name="l00584"></a>00584   <span class="keywordtype">void</span> set_elapsed_time(<a class="code" href="namespacetesting.html#a992de1d091ce660f451d1e8b3ce30fd6">TimeInMillis</a> elapsed) { elapsed_time_ = elapsed; }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586   <span class="comment">// Adds a test property to the list. The property is validated and may add</span>
<a name="l00587"></a>00587   <span class="comment">// a non-fatal failure if invalid (e.g., if it conflicts with reserved</span>
<a name="l00588"></a>00588   <span class="comment">// key names). If a property is already recorded for the same key, the</span>
<a name="l00589"></a>00589   <span class="comment">// value will be updated, rather than storing multiple values for the same</span>
<a name="l00590"></a>00590   <span class="comment">// key.  xml_element specifies the element for which the property is being</span>
<a name="l00591"></a>00591   <span class="comment">// recorded and is used for validation.</span>
<a name="l00592"></a>00592   <span class="keywordtype">void</span> RecordProperty(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; xml_element,
<a name="l00593"></a>00593                       <span class="keyword">const</span> TestProperty&amp; test_property);
<a name="l00594"></a>00594 
<a name="l00595"></a>00595   <span class="comment">// Adds a failure if the key is a reserved attribute of Google Test</span>
<a name="l00596"></a>00596   <span class="comment">// testcase tags.  Returns true if the property is valid.</span>
<a name="l00597"></a>00597   <span class="comment">// TODO(russr): Validate attribute names are legal and human readable.</span>
<a name="l00598"></a>00598   <span class="keyword">static</span> <span class="keywordtype">bool</span> ValidateTestProperty(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; xml_element,
<a name="l00599"></a>00599                                    <span class="keyword">const</span> TestProperty&amp; test_property);
<a name="l00600"></a>00600 
<a name="l00601"></a>00601   <span class="comment">// Adds a test part result to the list.</span>
<a name="l00602"></a>00602   <span class="keywordtype">void</span> AddTestPartResult(<span class="keyword">const</span> TestPartResult&amp; test_part_result);
<a name="l00603"></a>00603 
<a name="l00604"></a>00604   <span class="comment">// Returns the death test count.</span>
<a name="l00605"></a>00605   <span class="keywordtype">int</span> death_test_count()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> death_test_count_; }
<a name="l00606"></a>00606 
<a name="l00607"></a>00607   <span class="comment">// Increments the death test count, returning the new count.</span>
<a name="l00608"></a>00608   <span class="keywordtype">int</span> increment_death_test_count() { <span class="keywordflow">return</span> ++death_test_count_; }
<a name="l00609"></a>00609 
<a name="l00610"></a>00610   <span class="comment">// Clears the test part results.</span>
<a name="l00611"></a>00611   <span class="keywordtype">void</span> ClearTestPartResults();
<a name="l00612"></a>00612 
<a name="l00613"></a>00613   <span class="comment">// Clears the object.</span>
<a name="l00614"></a>00614   <span class="keywordtype">void</span> Clear();
<a name="l00615"></a>00615 
<a name="l00616"></a>00616   <span class="comment">// Protects mutable state of the property vector and of owned</span>
<a name="l00617"></a>00617   <span class="comment">// properties, whose values may be updated.</span>
<a name="l00618"></a>00618   internal::Mutex test_properites_mutex_;
<a name="l00619"></a>00619 
<a name="l00620"></a>00620   <span class="comment">// The vector of TestPartResults</span>
<a name="l00621"></a>00621   std::vector&lt;TestPartResult&gt; test_part_results_;
<a name="l00622"></a>00622   <span class="comment">// The vector of TestProperties</span>
<a name="l00623"></a>00623   std::vector&lt;TestProperty&gt; test_properties_;
<a name="l00624"></a>00624   <span class="comment">// Running count of death tests.</span>
<a name="l00625"></a>00625   <span class="keywordtype">int</span> death_test_count_;
<a name="l00626"></a>00626   <span class="comment">// The elapsed time, in milliseconds.</span>
<a name="l00627"></a>00627   <a class="code" href="namespacetesting.html#a992de1d091ce660f451d1e8b3ce30fd6">TimeInMillis</a> elapsed_time_;
<a name="l00628"></a>00628 
<a name="l00629"></a>00629   <span class="comment">// We disallow copying TestResult.</span>
<a name="l00630"></a>00630   <a class="code" href="gtest-port_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(TestResult);
<a name="l00631"></a>00631 };  <span class="comment">// class TestResult</span>
<a name="l00632"></a>00632 
<a name="l00633"></a>00633 <span class="comment">// A TestInfo object stores the following information about a test:</span>
<a name="l00634"></a>00634 <span class="comment">//</span>
<a name="l00635"></a>00635 <span class="comment">//   Test case name</span>
<a name="l00636"></a>00636 <span class="comment">//   Test name</span>
<a name="l00637"></a>00637 <span class="comment">//   Whether the test should be run</span>
<a name="l00638"></a>00638 <span class="comment">//   A function pointer that creates the test object when invoked</span>
<a name="l00639"></a>00639 <span class="comment">//   Test result</span>
<a name="l00640"></a>00640 <span class="comment">//</span>
<a name="l00641"></a>00641 <span class="comment">// The constructor of TestInfo registers itself with the UnitTest</span>
<a name="l00642"></a>00642 <span class="comment">// singleton such that the RUN_ALL_TESTS() macro knows which tests to</span>
<a name="l00643"></a>00643 <span class="comment">// run.</span>
<a name="l00644"></a><a class="code" href="classtesting_1_1TestInfo.html">00644</a> <span class="keyword">class </span><a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> <a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a> {
<a name="l00645"></a>00645  <span class="keyword">public</span>:
<a name="l00646"></a>00646   <span class="comment">// Destructs a TestInfo object.  This function is not virtual, so</span>
<a name="l00647"></a>00647   <span class="comment">// don&#39;t inherit from TestInfo.</span>
<a name="l00648"></a>00648   ~<a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>();
<a name="l00649"></a>00649 
<a name="l00650"></a>00650   <span class="comment">// Returns the test case name.</span>
<a name="l00651"></a><a class="code" href="classtesting_1_1TestInfo.html#a26d22556d04b94c9cd15e28d74fef91c">00651</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestInfo.html#a26d22556d04b94c9cd15e28d74fef91c">test_case_name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> test_case_name_.c_str(); }
<a name="l00652"></a>00652 
<a name="l00653"></a>00653   <span class="comment">// Returns the test name.</span>
<a name="l00654"></a><a class="code" href="classtesting_1_1TestInfo.html#ab3d24cad310f0cde29a80b9a83949ff5">00654</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestInfo.html#ab3d24cad310f0cde29a80b9a83949ff5">name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> name_.c_str(); }
<a name="l00655"></a>00655 
<a name="l00656"></a>00656   <span class="comment">// Returns the name of the parameter type, or NULL if this is not a typed</span>
<a name="l00657"></a>00657   <span class="comment">// or a type-parameterized test.</span>
<a name="l00658"></a><a class="code" href="classtesting_1_1TestInfo.html#af15d5c533a7237ffc183bc4c924dfcf4">00658</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestInfo.html#af15d5c533a7237ffc183bc4c924dfcf4">type_param</a>()<span class="keyword"> const </span>{
<a name="l00659"></a>00659     <span class="keywordflow">if</span> (type_param_.get() != NULL)
<a name="l00660"></a>00660       <span class="keywordflow">return</span> type_param_-&gt;c_str();
<a name="l00661"></a>00661     <span class="keywordflow">return</span> NULL;
<a name="l00662"></a>00662   }
<a name="l00663"></a>00663 
<a name="l00664"></a>00664   <span class="comment">// Returns the text representation of the value parameter, or NULL if this</span>
<a name="l00665"></a>00665   <span class="comment">// is not a value-parameterized test.</span>
<a name="l00666"></a><a class="code" href="classtesting_1_1TestInfo.html#a9671fbc0effcb32e98803888dc166a66">00666</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestInfo.html#a9671fbc0effcb32e98803888dc166a66">value_param</a>()<span class="keyword"> const </span>{
<a name="l00667"></a>00667     <span class="keywordflow">if</span> (value_param_.get() != NULL)
<a name="l00668"></a>00668       <span class="keywordflow">return</span> value_param_-&gt;c_str();
<a name="l00669"></a>00669     <span class="keywordflow">return</span> NULL;
<a name="l00670"></a>00670   }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672   <span class="comment">// Returns the file name where this test is defined.</span>
<a name="l00673"></a><a class="code" href="classtesting_1_1TestInfo.html#a696330c27a9b1a6149fc7a47b9e24cb8">00673</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestInfo.html#a696330c27a9b1a6149fc7a47b9e24cb8">file</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> location_.file.c_str(); }
<a name="l00674"></a>00674 
<a name="l00675"></a>00675   <span class="comment">// Returns the line where this test is defined.</span>
<a name="l00676"></a><a class="code" href="classtesting_1_1TestInfo.html#a47f933fa393ad94bbf2f238fa6698492">00676</a>   <span class="keywordtype">int</span> <a class="code" href="classtesting_1_1TestInfo.html#a47f933fa393ad94bbf2f238fa6698492">line</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> location_.line; }
<a name="l00677"></a>00677 
<a name="l00678"></a>00678   <span class="comment">// Returns true if this test should run, that is if the test is not</span>
<a name="l00679"></a>00679   <span class="comment">// disabled (or it is disabled but the also_run_disabled_tests flag has</span>
<a name="l00680"></a>00680   <span class="comment">// been specified) and its full name matches the user-specified filter.</span>
<a name="l00681"></a>00681   <span class="comment">//</span>
<a name="l00682"></a>00682   <span class="comment">// Google Test allows the user to filter the tests by their full names.</span>
<a name="l00683"></a>00683   <span class="comment">// The full name of a test Bar in test case Foo is defined as</span>
<a name="l00684"></a>00684   <span class="comment">// &quot;Foo.Bar&quot;.  Only the tests that match the filter will run.</span>
<a name="l00685"></a>00685   <span class="comment">//</span>
<a name="l00686"></a>00686   <span class="comment">// A filter is a colon-separated list of glob (not regex) patterns,</span>
<a name="l00687"></a>00687   <span class="comment">// optionally followed by a &#39;-&#39; and a colon-separated list of</span>
<a name="l00688"></a>00688   <span class="comment">// negative patterns (tests to exclude).  A test is run if it</span>
<a name="l00689"></a>00689   <span class="comment">// matches one of the positive patterns and does not match any of</span>
<a name="l00690"></a>00690   <span class="comment">// the negative patterns.</span>
<a name="l00691"></a>00691   <span class="comment">//</span>
<a name="l00692"></a>00692   <span class="comment">// For example, *A*:Foo.* is a filter that matches any string that</span>
<a name="l00693"></a>00693   <span class="comment">// contains the character &#39;A&#39; or starts with &quot;Foo.&quot;.</span>
<a name="l00694"></a><a class="code" href="classtesting_1_1TestInfo.html#a240c9fb051d7b0586ed380c6b4e729e4">00694</a>   <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1TestInfo.html#a240c9fb051d7b0586ed380c6b4e729e4">should_run</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> should_run_; }
<a name="l00695"></a>00695 
<a name="l00696"></a>00696   <span class="comment">// Returns true iff this test will appear in the XML report.</span>
<a name="l00697"></a><a class="code" href="classtesting_1_1TestInfo.html#a7ad90aeebb1d6fe3a43c6e3e3427e382">00697</a>   <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1TestInfo.html#a7ad90aeebb1d6fe3a43c6e3e3427e382">is_reportable</a>()<span class="keyword"> const </span>{
<a name="l00698"></a>00698     <span class="comment">// For now, the XML report includes all tests matching the filter.</span>
<a name="l00699"></a>00699     <span class="comment">// In the future, we may trim tests that are excluded because of</span>
<a name="l00700"></a>00700     <span class="comment">// sharding.</span>
<a name="l00701"></a>00701     <span class="keywordflow">return</span> matches_filter_;
<a name="l00702"></a>00702   }
<a name="l00703"></a>00703 
<a name="l00704"></a>00704   <span class="comment">// Returns the result of the test.</span>
<a name="l00705"></a><a class="code" href="classtesting_1_1TestInfo.html#addea8766df3b8abe4cc4103218a49a65">00705</a>   <span class="keyword">const</span> <a class="code" href="classtesting_1_1TestResult.html">TestResult</a>* <a class="code" href="classtesting_1_1TestInfo.html#addea8766df3b8abe4cc4103218a49a65">result</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> &amp;result_; }
<a name="l00706"></a>00706 
<a name="l00707"></a>00707  <span class="keyword">private</span>:
<a name="l00708"></a>00708 <span class="preprocessor">#if GTEST_HAS_DEATH_TEST</span>
<a name="l00709"></a>00709 <span class="preprocessor"></span>  <span class="keyword">friend</span> <span class="keyword">class </span>internal::DefaultDeathTestFactory;
<a name="l00710"></a>00710 <span class="preprocessor">#endif  // GTEST_HAS_DEATH_TEST</span>
<a name="l00711"></a><a class="code" href="classtesting_1_1TestInfo.html#a5b78b1c2e1fa07ffed92da365593eaa4">00711</a> <span class="preprocessor"></span>  <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1Test.html">Test</a>;
<a name="l00712"></a><a class="code" href="classtesting_1_1TestInfo.html#aff779e55b06adfa7c0088bd10253f0f0">00712</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1TestCase.html">TestCase</a>;
<a name="l00713"></a><a class="code" href="classtesting_1_1TestInfo.html#acc0a5e7573fd6ae7ad1878613bb86853">00713</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1UnitTestImpl.html">internal::UnitTestImpl</a>;
<a name="l00714"></a><a class="code" href="classtesting_1_1TestInfo.html#adc037d188dab349a94868991955c9cd4">00714</a>   <span class="keyword">friend</span> <span class="keyword">class </span>internal::StreamingListenerTest;
<a name="l00715"></a>00715   <span class="keyword">friend</span> <a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>* <a class="code" href="namespacetesting_1_1internal.html#adbaeb4f56e1d50cdc1d58c0be1d40527">internal::MakeAndRegisterTestInfo</a>(
<a name="l00716"></a>00716       <span class="keyword">const</span> <span class="keywordtype">char</span>* test_case_name,
<a name="l00717"></a>00717       <span class="keyword">const</span> <span class="keywordtype">char</span>* name,
<a name="l00718"></a>00718       <span class="keyword">const</span> <span class="keywordtype">char</span>* type_param,
<a name="l00719"></a>00719       <span class="keyword">const</span> <span class="keywordtype">char</span>* value_param,
<a name="l00720"></a>00720       <a class="code" href="structtesting_1_1internal_1_1CodeLocation.html">internal::CodeLocation</a> code_location,
<a name="l00721"></a>00721       <a class="code" href="namespacetesting_1_1internal.html#ab1114197d3c657d8b7f8e0c5caa12d00">internal::TypeId</a> fixture_class_id,
<a name="l00722"></a>00722       <a class="code" href="classtesting_1_1Test.html#a5f2a051d1d99c9b784c666c586186cf9">Test::SetUpTestCaseFunc</a> set_up_tc,
<a name="l00723"></a>00723       <a class="code" href="classtesting_1_1Test.html#aa0f532e93b9f3500144c53f31466976c">Test::TearDownTestCaseFunc</a> tear_down_tc,
<a name="l00724"></a>00724       <a class="code" href="classtesting_1_1internal_1_1TestFactoryBase.html">internal::TestFactoryBase</a>* factory);
<a name="l00725"></a>00725 
<a name="l00726"></a>00726   <span class="comment">// Constructs a TestInfo object. The newly constructed instance assumes</span>
<a name="l00727"></a>00727   <span class="comment">// ownership of the factory object.</span>
<a name="l00728"></a>00728   <a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; test_case_name,
<a name="l00729"></a>00729            <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; name,
<a name="l00730"></a>00730            <span class="keyword">const</span> <span class="keywordtype">char</span>* a_type_param,   <span class="comment">// NULL if not a type-parameterized test</span>
<a name="l00731"></a>00731            <span class="keyword">const</span> <span class="keywordtype">char</span>* a_value_param,  <span class="comment">// NULL if not a value-parameterized test</span>
<a name="l00732"></a>00732            <a class="code" href="structtesting_1_1internal_1_1CodeLocation.html">internal::CodeLocation</a> a_code_location,
<a name="l00733"></a>00733            <a class="code" href="namespacetesting_1_1internal.html#ab1114197d3c657d8b7f8e0c5caa12d00">internal::TypeId</a> fixture_class_id,
<a name="l00734"></a>00734            <a class="code" href="classtesting_1_1internal_1_1TestFactoryBase.html">internal::TestFactoryBase</a>* factory);
<a name="l00735"></a>00735 
<a name="l00736"></a>00736   <span class="comment">// Increments the number of death tests encountered in this test so</span>
<a name="l00737"></a>00737   <span class="comment">// far.</span>
<a name="l00738"></a>00738   <span class="keywordtype">int</span> increment_death_test_count() {
<a name="l00739"></a>00739     <span class="keywordflow">return</span> result_.increment_death_test_count();
<a name="l00740"></a>00740   }
<a name="l00741"></a>00741 
<a name="l00742"></a>00742   <span class="comment">// Creates the test object, runs it, records its result, and then</span>
<a name="l00743"></a>00743   <span class="comment">// deletes it.</span>
<a name="l00744"></a>00744   <span class="keywordtype">void</span> Run();
<a name="l00745"></a>00745 
<a name="l00746"></a>00746   <span class="keyword">static</span> <span class="keywordtype">void</span> ClearTestResult(<a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>* test_info) {
<a name="l00747"></a>00747     test_info-&gt;result_.Clear();
<a name="l00748"></a>00748   }
<a name="l00749"></a>00749 
<a name="l00750"></a>00750   <span class="comment">// These fields are immutable properties of the test.</span>
<a name="l00751"></a>00751   <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a> test_case_name_;     <span class="comment">// Test case name</span>
<a name="l00752"></a>00752   <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a> name_;               <span class="comment">// Test name</span>
<a name="l00753"></a>00753   <span class="comment">// Name of the parameter type, or NULL if this is not a typed or a</span>
<a name="l00754"></a>00754   <span class="comment">// type-parameterized test.</span>
<a name="l00755"></a>00755   <span class="keyword">const</span> internal::scoped_ptr&lt;const ::std::string&gt; type_param_;
<a name="l00756"></a>00756   <span class="comment">// Text representation of the value parameter, or NULL if this is not a</span>
<a name="l00757"></a>00757   <span class="comment">// value-parameterized test.</span>
<a name="l00758"></a>00758   <span class="keyword">const</span> internal::scoped_ptr&lt;const ::std::string&gt; value_param_;
<a name="l00759"></a>00759   internal::CodeLocation location_;
<a name="l00760"></a>00760   <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#ab1114197d3c657d8b7f8e0c5caa12d00">internal::TypeId</a> fixture_class_id_;   <span class="comment">// ID of the test fixture class</span>
<a name="l00761"></a>00761   <span class="keywordtype">bool</span> should_run_;                 <span class="comment">// True iff this test should run</span>
<a name="l00762"></a>00762   <span class="keywordtype">bool</span> is_disabled_;                <span class="comment">// True iff this test is disabled</span>
<a name="l00763"></a>00763   <span class="keywordtype">bool</span> matches_filter_;             <span class="comment">// True if this test matches the</span>
<a name="l00764"></a>00764                                     <span class="comment">// user-specified filter.</span>
<a name="l00765"></a>00765   internal::TestFactoryBase* <span class="keyword">const</span> factory_;  <span class="comment">// The factory that creates</span>
<a name="l00766"></a>00766                                               <span class="comment">// the test object</span>
<a name="l00767"></a>00767 
<a name="l00768"></a>00768   <span class="comment">// This field is mutable and needs to be reset before running the</span>
<a name="l00769"></a>00769   <span class="comment">// test for the second time.</span>
<a name="l00770"></a>00770   TestResult result_;
<a name="l00771"></a>00771 
<a name="l00772"></a>00772   <a class="code" href="gtest-port_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(TestInfo);
<a name="l00773"></a>00773 };
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 <span class="comment">// A test case, which consists of a vector of TestInfos.</span>
<a name="l00776"></a>00776 <span class="comment">//</span>
<a name="l00777"></a>00777 <span class="comment">// TestCase is not copyable.</span>
<a name="l00778"></a><a class="code" href="classtesting_1_1TestCase.html">00778</a> <span class="keyword">class </span><a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> <a class="code" href="classtesting_1_1TestCase.html">TestCase</a> {
<a name="l00779"></a>00779  <span class="keyword">public</span>:
<a name="l00780"></a>00780   <span class="comment">// Creates a TestCase with the given name.</span>
<a name="l00781"></a>00781   <span class="comment">//</span>
<a name="l00782"></a>00782   <span class="comment">// TestCase does NOT have a default constructor.  Always use this</span>
<a name="l00783"></a>00783   <span class="comment">// constructor to create a TestCase object.</span>
<a name="l00784"></a>00784   <span class="comment">//</span>
<a name="l00785"></a>00785   <span class="comment">// Arguments:</span>
<a name="l00786"></a>00786   <span class="comment">//</span>
<a name="l00787"></a>00787   <span class="comment">//   name:         name of the test case</span>
<a name="l00788"></a>00788   <span class="comment">//   a_type_param: the name of the test&#39;s type parameter, or NULL if</span>
<a name="l00789"></a>00789   <span class="comment">//                 this is not a type-parameterized test.</span>
<a name="l00790"></a>00790   <span class="comment">//   set_up_tc:    pointer to the function that sets up the test case</span>
<a name="l00791"></a>00791   <span class="comment">//   tear_down_tc: pointer to the function that tears down the test case</span>
<a name="l00792"></a>00792   <a class="code" href="classtesting_1_1TestCase.html">TestCase</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* name, <span class="keyword">const</span> <span class="keywordtype">char</span>* a_type_param,
<a name="l00793"></a>00793            <a class="code" href="classtesting_1_1Test.html#a5f2a051d1d99c9b784c666c586186cf9">Test::SetUpTestCaseFunc</a> set_up_tc,
<a name="l00794"></a>00794            <a class="code" href="classtesting_1_1Test.html#aa0f532e93b9f3500144c53f31466976c">Test::TearDownTestCaseFunc</a> tear_down_tc);
<a name="l00795"></a>00795 
<a name="l00796"></a>00796   <span class="comment">// Destructor of TestCase.</span>
<a name="l00797"></a>00797   <span class="keyword">virtual</span> ~<a class="code" href="classtesting_1_1TestCase.html">TestCase</a>();
<a name="l00798"></a>00798 
<a name="l00799"></a>00799   <span class="comment">// Gets the name of the TestCase.</span>
<a name="l00800"></a><a class="code" href="classtesting_1_1TestCase.html#af4dfd4ece8e66520a30e6a9fbd9d43aa">00800</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestCase.html#af4dfd4ece8e66520a30e6a9fbd9d43aa">name</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> name_.c_str(); }
<a name="l00801"></a>00801 
<a name="l00802"></a>00802   <span class="comment">// Returns the name of the parameter type, or NULL if this is not a</span>
<a name="l00803"></a>00803   <span class="comment">// type-parameterized test case.</span>
<a name="l00804"></a><a class="code" href="classtesting_1_1TestCase.html#a2052c095bc6ac9c0ab1cae6f0e2d9fc9">00804</a>   <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classtesting_1_1TestCase.html#a2052c095bc6ac9c0ab1cae6f0e2d9fc9">type_param</a>()<span class="keyword"> const </span>{
<a name="l00805"></a>00805     <span class="keywordflow">if</span> (type_param_.get() != NULL)
<a name="l00806"></a>00806       <span class="keywordflow">return</span> type_param_-&gt;c_str();
<a name="l00807"></a>00807     <span class="keywordflow">return</span> NULL;
<a name="l00808"></a>00808   }
<a name="l00809"></a>00809 
<a name="l00810"></a>00810   <span class="comment">// Returns true if any test in this test case should run.</span>
<a name="l00811"></a><a class="code" href="classtesting_1_1TestCase.html#a0e49de754452943d88e3083e6cdded00">00811</a>   <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1TestCase.html#a0e49de754452943d88e3083e6cdded00">should_run</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> should_run_; }
<a name="l00812"></a>00812 
<a name="l00813"></a>00813   <span class="comment">// Gets the number of successful tests in this test case.</span>
<a name="l00814"></a>00814   <span class="keywordtype">int</span> successful_test_count() <span class="keyword">const</span>;
<a name="l00815"></a>00815 
<a name="l00816"></a>00816   <span class="comment">// Gets the number of failed tests in this test case.</span>
<a name="l00817"></a>00817   <span class="keywordtype">int</span> failed_test_count() <span class="keyword">const</span>;
<a name="l00818"></a>00818 
<a name="l00819"></a>00819   <span class="comment">// Gets the number of disabled tests that will be reported in the XML report.</span>
<a name="l00820"></a>00820   <span class="keywordtype">int</span> reportable_disabled_test_count() <span class="keyword">const</span>;
<a name="l00821"></a>00821 
<a name="l00822"></a>00822   <span class="comment">// Gets the number of disabled tests in this test case.</span>
<a name="l00823"></a>00823   <span class="keywordtype">int</span> disabled_test_count() <span class="keyword">const</span>;
<a name="l00824"></a>00824 
<a name="l00825"></a>00825   <span class="comment">// Gets the number of tests to be printed in the XML report.</span>
<a name="l00826"></a>00826   <span class="keywordtype">int</span> reportable_test_count() <span class="keyword">const</span>;
<a name="l00827"></a>00827 
<a name="l00828"></a>00828   <span class="comment">// Get the number of tests in this test case that should run.</span>
<a name="l00829"></a>00829   <span class="keywordtype">int</span> test_to_run_count() <span class="keyword">const</span>;
<a name="l00830"></a>00830 
<a name="l00831"></a>00831   <span class="comment">// Gets the number of all tests in this test case.</span>
<a name="l00832"></a>00832   <span class="keywordtype">int</span> total_test_count() <span class="keyword">const</span>;
<a name="l00833"></a>00833 
<a name="l00834"></a>00834   <span class="comment">// Returns true iff the test case passed.</span>
<a name="l00835"></a><a class="code" href="classtesting_1_1TestCase.html#ad093a04334d7eb8d707a7f1a321b040f">00835</a>   <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1TestCase.html#ad093a04334d7eb8d707a7f1a321b040f">Passed</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> !Failed(); }
<a name="l00836"></a>00836 
<a name="l00837"></a>00837   <span class="comment">// Returns true iff the test case failed.</span>
<a name="l00838"></a><a class="code" href="classtesting_1_1TestCase.html#a5c0922d310f860e78cca7e215f2fa0e4">00838</a>   <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1TestCase.html#a5c0922d310f860e78cca7e215f2fa0e4">Failed</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> failed_test_count() &gt; 0; }
<a name="l00839"></a>00839 
<a name="l00840"></a>00840   <span class="comment">// Returns the elapsed time, in milliseconds.</span>
<a name="l00841"></a><a class="code" href="classtesting_1_1TestCase.html#a80f163d2826ba8586fffb41e8d686727">00841</a>   <a class="code" href="namespacetesting.html#a992de1d091ce660f451d1e8b3ce30fd6">TimeInMillis</a> <a class="code" href="classtesting_1_1TestCase.html#a80f163d2826ba8586fffb41e8d686727">elapsed_time</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> elapsed_time_; }
<a name="l00842"></a>00842 
<a name="l00843"></a>00843   <span class="comment">// Returns the i-th test among all the tests. i can range from 0 to</span>
<a name="l00844"></a>00844   <span class="comment">// total_test_count() - 1. If i is not in that range, returns NULL.</span>
<a name="l00845"></a>00845   <span class="keyword">const</span> <a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>* GetTestInfo(<span class="keywordtype">int</span> i) <span class="keyword">const</span>;
<a name="l00846"></a>00846 
<a name="l00847"></a>00847   <span class="comment">// Returns the TestResult that holds test properties recorded during</span>
<a name="l00848"></a>00848   <span class="comment">// execution of SetUpTestCase and TearDownTestCase.</span>
<a name="l00849"></a><a class="code" href="classtesting_1_1TestCase.html#a3993481a8f0c2253653b5e1ec5934432">00849</a>   <span class="keyword">const</span> <a class="code" href="classtesting_1_1TestResult.html">TestResult</a>&amp; <a class="code" href="classtesting_1_1TestCase.html#a3993481a8f0c2253653b5e1ec5934432">ad_hoc_test_result</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ad_hoc_test_result_; }
<a name="l00850"></a>00850 
<a name="l00851"></a>00851  <span class="keyword">private</span>:
<a name="l00852"></a><a class="code" href="classtesting_1_1TestCase.html#a5b78b1c2e1fa07ffed92da365593eaa4">00852</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1Test.html">Test</a>;
<a name="l00853"></a><a class="code" href="classtesting_1_1TestCase.html#acc0a5e7573fd6ae7ad1878613bb86853">00853</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1UnitTestImpl.html">internal::UnitTestImpl</a>;
<a name="l00854"></a>00854 
<a name="l00855"></a>00855   <span class="comment">// Gets the (mutable) vector of TestInfos in this TestCase.</span>
<a name="l00856"></a>00856   std::vector&lt;TestInfo*&gt;&amp; test_info_list() { <span class="keywordflow">return</span> test_info_list_; }
<a name="l00857"></a>00857 
<a name="l00858"></a>00858   <span class="comment">// Gets the (immutable) vector of TestInfos in this TestCase.</span>
<a name="l00859"></a>00859   <span class="keyword">const</span> std::vector&lt;TestInfo*&gt;&amp; test_info_list()<span class="keyword"> const </span>{
<a name="l00860"></a>00860     <span class="keywordflow">return</span> test_info_list_;
<a name="l00861"></a>00861   }
<a name="l00862"></a>00862 
<a name="l00863"></a>00863   <span class="comment">// Returns the i-th test among all the tests. i can range from 0 to</span>
<a name="l00864"></a>00864   <span class="comment">// total_test_count() - 1. If i is not in that range, returns NULL.</span>
<a name="l00865"></a>00865   TestInfo* GetMutableTestInfo(<span class="keywordtype">int</span> i);
<a name="l00866"></a>00866 
<a name="l00867"></a>00867   <span class="comment">// Sets the should_run member.</span>
<a name="l00868"></a>00868   <span class="keywordtype">void</span> set_should_run(<span class="keywordtype">bool</span> should) { should_run_ = should; }
<a name="l00869"></a>00869 
<a name="l00870"></a>00870   <span class="comment">// Adds a TestInfo to this test case.  Will delete the TestInfo upon</span>
<a name="l00871"></a>00871   <span class="comment">// destruction of the TestCase object.</span>
<a name="l00872"></a>00872   <span class="keywordtype">void</span> AddTestInfo(TestInfo * test_info);
<a name="l00873"></a>00873 
<a name="l00874"></a>00874   <span class="comment">// Clears the results of all tests in this test case.</span>
<a name="l00875"></a>00875   <span class="keywordtype">void</span> ClearResult();
<a name="l00876"></a>00876 
<a name="l00877"></a>00877   <span class="comment">// Clears the results of all tests in the given test case.</span>
<a name="l00878"></a>00878   <span class="keyword">static</span> <span class="keywordtype">void</span> ClearTestCaseResult(TestCase* test_case) {
<a name="l00879"></a>00879     test_case-&gt;ClearResult();
<a name="l00880"></a>00880   }
<a name="l00881"></a>00881 
<a name="l00882"></a>00882   <span class="comment">// Runs every test in this TestCase.</span>
<a name="l00883"></a>00883   <span class="keywordtype">void</span> Run();
<a name="l00884"></a>00884 
<a name="l00885"></a>00885   <span class="comment">// Runs SetUpTestCase() for this TestCase.  This wrapper is needed</span>
<a name="l00886"></a>00886   <span class="comment">// for catching exceptions thrown from SetUpTestCase().</span>
<a name="l00887"></a>00887   <span class="keywordtype">void</span> RunSetUpTestCase() { (*set_up_tc_)(); }
<a name="l00888"></a>00888 
<a name="l00889"></a>00889   <span class="comment">// Runs TearDownTestCase() for this TestCase.  This wrapper is</span>
<a name="l00890"></a>00890   <span class="comment">// needed for catching exceptions thrown from TearDownTestCase().</span>
<a name="l00891"></a>00891   <span class="keywordtype">void</span> RunTearDownTestCase() { (*tear_down_tc_)(); }
<a name="l00892"></a>00892 
<a name="l00893"></a>00893   <span class="comment">// Returns true iff test passed.</span>
<a name="l00894"></a>00894   <span class="keyword">static</span> <span class="keywordtype">bool</span> TestPassed(<span class="keyword">const</span> TestInfo* test_info) {
<a name="l00895"></a>00895     <span class="keywordflow">return</span> test_info-&gt;should_run() &amp;&amp; test_info-&gt;result()-&gt;Passed();
<a name="l00896"></a>00896   }
<a name="l00897"></a>00897 
<a name="l00898"></a>00898   <span class="comment">// Returns true iff test failed.</span>
<a name="l00899"></a>00899   <span class="keyword">static</span> <span class="keywordtype">bool</span> TestFailed(<span class="keyword">const</span> TestInfo* test_info) {
<a name="l00900"></a>00900     <span class="keywordflow">return</span> test_info-&gt;should_run() &amp;&amp; test_info-&gt;result()-&gt;Failed();
<a name="l00901"></a>00901   }
<a name="l00902"></a>00902 
<a name="l00903"></a>00903   <span class="comment">// Returns true iff the test is disabled and will be reported in the XML</span>
<a name="l00904"></a>00904   <span class="comment">// report.</span>
<a name="l00905"></a>00905   <span class="keyword">static</span> <span class="keywordtype">bool</span> TestReportableDisabled(<span class="keyword">const</span> TestInfo* test_info) {
<a name="l00906"></a>00906     <span class="keywordflow">return</span> test_info-&gt;is_reportable() &amp;&amp; test_info-&gt;is_disabled_;
<a name="l00907"></a>00907   }
<a name="l00908"></a>00908 
<a name="l00909"></a>00909   <span class="comment">// Returns true iff test is disabled.</span>
<a name="l00910"></a>00910   <span class="keyword">static</span> <span class="keywordtype">bool</span> TestDisabled(<span class="keyword">const</span> TestInfo* test_info) {
<a name="l00911"></a>00911     <span class="keywordflow">return</span> test_info-&gt;is_disabled_;
<a name="l00912"></a>00912   }
<a name="l00913"></a>00913 
<a name="l00914"></a>00914   <span class="comment">// Returns true iff this test will appear in the XML report.</span>
<a name="l00915"></a>00915   <span class="keyword">static</span> <span class="keywordtype">bool</span> TestReportable(<span class="keyword">const</span> TestInfo* test_info) {
<a name="l00916"></a>00916     <span class="keywordflow">return</span> test_info-&gt;is_reportable();
<a name="l00917"></a>00917   }
<a name="l00918"></a>00918 
<a name="l00919"></a>00919   <span class="comment">// Returns true if the given test should run.</span>
<a name="l00920"></a>00920   <span class="keyword">static</span> <span class="keywordtype">bool</span> ShouldRunTest(<span class="keyword">const</span> TestInfo* test_info) {
<a name="l00921"></a>00921     <span class="keywordflow">return</span> test_info-&gt;should_run();
<a name="l00922"></a>00922   }
<a name="l00923"></a>00923 
<a name="l00924"></a>00924   <span class="comment">// Shuffles the tests in this test case.</span>
<a name="l00925"></a>00925   <span class="keywordtype">void</span> ShuffleTests(internal::Random* random);
<a name="l00926"></a>00926 
<a name="l00927"></a>00927   <span class="comment">// Restores the test order to before the first shuffle.</span>
<a name="l00928"></a>00928   <span class="keywordtype">void</span> UnshuffleTests();
<a name="l00929"></a>00929 
<a name="l00930"></a>00930   <span class="comment">// Name of the test case.</span>
<a name="l00931"></a>00931   <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a> name_;
<a name="l00932"></a>00932   <span class="comment">// Name of the parameter type, or NULL if this is not a typed or a</span>
<a name="l00933"></a>00933   <span class="comment">// type-parameterized test.</span>
<a name="l00934"></a>00934   <span class="keyword">const</span> internal::scoped_ptr&lt;const ::std::string&gt; type_param_;
<a name="l00935"></a>00935   <span class="comment">// The vector of TestInfos in their original order.  It owns the</span>
<a name="l00936"></a>00936   <span class="comment">// elements in the vector.</span>
<a name="l00937"></a>00937   std::vector&lt;TestInfo*&gt; test_info_list_;
<a name="l00938"></a>00938   <span class="comment">// Provides a level of indirection for the test list to allow easy</span>
<a name="l00939"></a>00939   <span class="comment">// shuffling and restoring the test order.  The i-th element in this</span>
<a name="l00940"></a>00940   <span class="comment">// vector is the index of the i-th test in the shuffled test list.</span>
<a name="l00941"></a>00941   std::vector&lt;int&gt; test_indices_;
<a name="l00942"></a>00942   <span class="comment">// Pointer to the function that sets up the test case.</span>
<a name="l00943"></a>00943   <a class="code" href="classtesting_1_1Test.html#a5f2a051d1d99c9b784c666c586186cf9">Test::SetUpTestCaseFunc</a> set_up_tc_;
<a name="l00944"></a>00944   <span class="comment">// Pointer to the function that tears down the test case.</span>
<a name="l00945"></a>00945   <a class="code" href="classtesting_1_1Test.html#aa0f532e93b9f3500144c53f31466976c">Test::TearDownTestCaseFunc</a> tear_down_tc_;
<a name="l00946"></a>00946   <span class="comment">// True iff any test in this test case should run.</span>
<a name="l00947"></a>00947   <span class="keywordtype">bool</span> should_run_;
<a name="l00948"></a>00948   <span class="comment">// Elapsed time, in milliseconds.</span>
<a name="l00949"></a>00949   <a class="code" href="namespacetesting.html#a992de1d091ce660f451d1e8b3ce30fd6">TimeInMillis</a> elapsed_time_;
<a name="l00950"></a>00950   <span class="comment">// Holds test properties recorded during execution of SetUpTestCase and</span>
<a name="l00951"></a>00951   <span class="comment">// TearDownTestCase.</span>
<a name="l00952"></a>00952   TestResult ad_hoc_test_result_;
<a name="l00953"></a>00953 
<a name="l00954"></a>00954   <span class="comment">// We disallow copying TestCases.</span>
<a name="l00955"></a>00955   <a class="code" href="gtest-port_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(TestCase);
<a name="l00956"></a>00956 };
<a name="l00957"></a>00957 
<a name="l00958"></a>00958 <span class="comment">// An Environment object is capable of setting up and tearing down an</span>
<a name="l00959"></a>00959 <span class="comment">// environment.  You should subclass this to define your own</span>
<a name="l00960"></a>00960 <span class="comment">// environment(s).</span>
<a name="l00961"></a>00961 <span class="comment">//</span>
<a name="l00962"></a>00962 <span class="comment">// An Environment object does the set-up and tear-down in virtual</span>
<a name="l00963"></a>00963 <span class="comment">// methods SetUp() and TearDown() instead of the constructor and the</span>
<a name="l00964"></a>00964 <span class="comment">// destructor, as:</span>
<a name="l00965"></a>00965 <span class="comment">//</span>
<a name="l00966"></a>00966 <span class="comment">//   1. You cannot safely throw from a destructor.  This is a problem</span>
<a name="l00967"></a>00967 <span class="comment">//      as in some cases Google Test is used where exceptions are enabled, and</span>
<a name="l00968"></a>00968 <span class="comment">//      we may want to implement ASSERT_* using exceptions where they are</span>
<a name="l00969"></a>00969 <span class="comment">//      available.</span>
<a name="l00970"></a>00970 <span class="comment">//   2. You cannot use ASSERT_* directly in a constructor or</span>
<a name="l00971"></a>00971 <span class="comment">//      destructor.</span>
<a name="l00972"></a><a class="code" href="classtesting_1_1Environment.html">00972</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1Environment.html">Environment</a> {
<a name="l00973"></a>00973  <span class="keyword">public</span>:
<a name="l00974"></a>00974   <span class="comment">// The d&#39;tor is virtual as we need to subclass Environment.</span>
<a name="l00975"></a><a class="code" href="classtesting_1_1Environment.html#a0e41c320362576d752cd1f44cabd57d4">00975</a>   <span class="keyword">virtual</span> <a class="code" href="classtesting_1_1Environment.html#a0e41c320362576d752cd1f44cabd57d4">~Environment</a>() {}
<a name="l00976"></a>00976 
<a name="l00977"></a>00977   <span class="comment">// Override this to define how to set up the environment.</span>
<a name="l00978"></a><a class="code" href="classtesting_1_1Environment.html#a1bf8cafaa9d4eba9feb98655ee434eb3">00978</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Environment.html#a1bf8cafaa9d4eba9feb98655ee434eb3">SetUp</a>() {}
<a name="l00979"></a>00979 
<a name="l00980"></a>00980   <span class="comment">// Override this to define how to tear down the environment.</span>
<a name="l00981"></a><a class="code" href="classtesting_1_1Environment.html#a039bdaa705c46b9b88234cf4d3bb6254">00981</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1Environment.html#a039bdaa705c46b9b88234cf4d3bb6254">TearDown</a>() {}
<a name="l00982"></a>00982  <span class="keyword">private</span>:
<a name="l00983"></a>00983   <span class="comment">// If you see an error about overriding the following function or</span>
<a name="l00984"></a>00984   <span class="comment">// about it being private, you have mis-spelled SetUp() as Setup().</span>
<a name="l00985"></a>00985   <span class="keyword">struct </span>Setup_should_be_spelled_SetUp {};
<a name="l00986"></a>00986   <span class="keyword">virtual</span> Setup_should_be_spelled_SetUp* Setup() { <span class="keywordflow">return</span> NULL; }
<a name="l00987"></a>00987 };
<a name="l00988"></a>00988 
<a name="l00989"></a>00989 <span class="comment">// The interface for tracing execution of tests. The methods are organized in</span>
<a name="l00990"></a>00990 <span class="comment">// the order the corresponding events are fired.</span>
<a name="l00991"></a><a class="code" href="classtesting_1_1TestEventListener.html">00991</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1TestEventListener.html">TestEventListener</a> {
<a name="l00992"></a>00992  <span class="keyword">public</span>:
<a name="l00993"></a><a class="code" href="classtesting_1_1TestEventListener.html#a4512d19e7a108ec4926239ec1ea85d63">00993</a>   <span class="keyword">virtual</span> <a class="code" href="classtesting_1_1TestEventListener.html#a4512d19e7a108ec4926239ec1ea85d63">~TestEventListener</a>() {}
<a name="l00994"></a>00994 
<a name="l00995"></a>00995   <span class="comment">// Fired before any test activity starts.</span>
<a name="l00996"></a>00996   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#a5f6c84f39851e8a603a2d2e10063816b">OnTestProgramStart</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test) = 0;
<a name="l00997"></a>00997 
<a name="l00998"></a>00998   <span class="comment">// Fired before each iteration of tests starts.  There may be more than</span>
<a name="l00999"></a>00999   <span class="comment">// one iteration if GTEST_FLAG(repeat) is set. iteration is the iteration</span>
<a name="l01000"></a>01000   <span class="comment">// index, starting from 0.</span>
<a name="l01001"></a>01001   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#a60cc09b7907cb329d152eb5e7133bdeb">OnTestIterationStart</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test,
<a name="l01002"></a>01002                                     <span class="keywordtype">int</span> iteration) = 0;
<a name="l01003"></a>01003 
<a name="l01004"></a>01004   <span class="comment">// Fired before environment set-up for each iteration of tests starts.</span>
<a name="l01005"></a>01005   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#aa6502e534919605be45f26a6daf9a40c">OnEnvironmentsSetUpStart</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test) = 0;
<a name="l01006"></a>01006 
<a name="l01007"></a>01007   <span class="comment">// Fired after environment set-up for each iteration of tests ends.</span>
<a name="l01008"></a>01008   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#aaa1021d75f5dbf3f05c829c1cc520341">OnEnvironmentsSetUpEnd</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test) = 0;
<a name="l01009"></a>01009 
<a name="l01010"></a>01010   <span class="comment">// Fired before the test case starts.</span>
<a name="l01011"></a>01011   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#ab4ed885d63f5bbff8076c1329b3dfe36">OnTestCaseStart</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1TestCase.html">TestCase</a>&amp; test_case) = 0;
<a name="l01012"></a>01012 
<a name="l01013"></a>01013   <span class="comment">// Fired before the test starts.</span>
<a name="l01014"></a>01014   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#ab4f6a0ca16ae75daf385b3b5914e1048">OnTestStart</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>&amp; test_info) = 0;
<a name="l01015"></a>01015 
<a name="l01016"></a>01016   <span class="comment">// Fired after a failed assertion or a SUCCEED() invocation.</span>
<a name="l01017"></a>01017   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#a054f8705c883fa120b91473aff38f2ee">OnTestPartResult</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1TestPartResult.html">TestPartResult</a>&amp; test_part_result) = 0;
<a name="l01018"></a>01018 
<a name="l01019"></a>01019   <span class="comment">// Fired after the test ends.</span>
<a name="l01020"></a>01020   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#abb1c44525ef038500608b5dc2f17099b">OnTestEnd</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>&amp; test_info) = 0;
<a name="l01021"></a>01021 
<a name="l01022"></a>01022   <span class="comment">// Fired after the test case ends.</span>
<a name="l01023"></a>01023   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#ae61985e2ef76ac78379b077be57a9c36">OnTestCaseEnd</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1TestCase.html">TestCase</a>&amp; test_case) = 0;
<a name="l01024"></a>01024 
<a name="l01025"></a>01025   <span class="comment">// Fired before environment tear-down for each iteration of tests starts.</span>
<a name="l01026"></a>01026   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#a468b5e6701bcb86cb2c956caadbba5e4">OnEnvironmentsTearDownStart</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test) = 0;
<a name="l01027"></a>01027 
<a name="l01028"></a>01028   <span class="comment">// Fired after environment tear-down for each iteration of tests ends.</span>
<a name="l01029"></a>01029   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#a9ea04fa7f447865ba76df35e12ba2092">OnEnvironmentsTearDownEnd</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test) = 0;
<a name="l01030"></a>01030 
<a name="l01031"></a>01031   <span class="comment">// Fired after each iteration of tests finishes.</span>
<a name="l01032"></a>01032   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#a550fdb3e55726e4cefa09f5697941425">OnTestIterationEnd</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test,
<a name="l01033"></a>01033                                   <span class="keywordtype">int</span> iteration) = 0;
<a name="l01034"></a>01034 
<a name="l01035"></a>01035   <span class="comment">// Fired after all test activities have ended.</span>
<a name="l01036"></a>01036   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1TestEventListener.html#ad15b6246d94c268e233487a86463ef3d">OnTestProgramEnd</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; unit_test) = 0;
<a name="l01037"></a>01037 };
<a name="l01038"></a>01038 
<a name="l01039"></a>01039 <span class="comment">// The convenience class for users who need to override just one or two</span>
<a name="l01040"></a>01040 <span class="comment">// methods and are not concerned that a possible change to a signature of</span>
<a name="l01041"></a>01041 <span class="comment">// the methods they override will not be caught during the build.  For</span>
<a name="l01042"></a>01042 <span class="comment">// comments about each method please see the definition of TestEventListener</span>
<a name="l01043"></a>01043 <span class="comment">// above.</span>
<a name="l01044"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html">01044</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1EmptyTestEventListener.html">EmptyTestEventListener</a> : <span class="keyword">public</span> <a class="code" href="classtesting_1_1TestEventListener.html">TestEventListener</a> {
<a name="l01045"></a>01045  <span class="keyword">public</span>:
<a name="l01046"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#aa3847c8a3c22d8d69a6006dfdd6589fc">01046</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#aa3847c8a3c22d8d69a6006dfdd6589fc">OnTestProgramStart</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; <span class="comment">/*unit_test*/</span>) {}
<a name="l01047"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#a836f05829855dc60d13ba99ad712c0dd">01047</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#a836f05829855dc60d13ba99ad712c0dd">OnTestIterationStart</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; <span class="comment">/*unit_test*/</span>,
<a name="l01048"></a>01048                                     <span class="keywordtype">int</span> <span class="comment">/*iteration*/</span>) {}
<a name="l01049"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#a156d1965248fbdced6aabacadfa2d63f">01049</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#a156d1965248fbdced6aabacadfa2d63f">OnEnvironmentsSetUpStart</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; <span class="comment">/*unit_test*/</span>) {}
<a name="l01050"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#abc481c6648d15d4242245195a06f5aa0">01050</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#abc481c6648d15d4242245195a06f5aa0">OnEnvironmentsSetUpEnd</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; <span class="comment">/*unit_test*/</span>) {}
<a name="l01051"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#ae4707ed9cc7ace5241bc8ccc4051209b">01051</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#ae4707ed9cc7ace5241bc8ccc4051209b">OnTestCaseStart</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1TestCase.html">TestCase</a>&amp; <span class="comment">/*test_case*/</span>) {}
<a name="l01052"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#a84fa74cc9ba742f9f847ea405ca84e5e">01052</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#a84fa74cc9ba742f9f847ea405ca84e5e">OnTestStart</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>&amp; <span class="comment">/*test_info*/</span>) {}
<a name="l01053"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#a59e7f7d9f2e2d089a6e8c1e2577f4718">01053</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#a59e7f7d9f2e2d089a6e8c1e2577f4718">OnTestPartResult</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1TestPartResult.html">TestPartResult</a>&amp; <span class="comment">/*test_part_result*/</span>) {}
<a name="l01054"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#afd58d21005f0d0d0399fb114627545d3">01054</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#afd58d21005f0d0d0399fb114627545d3">OnTestEnd</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>&amp; <span class="comment">/*test_info*/</span>) {}
<a name="l01055"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#a6bec703158283104c4298f7d8a528515">01055</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#a6bec703158283104c4298f7d8a528515">OnTestCaseEnd</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1TestCase.html">TestCase</a>&amp; <span class="comment">/*test_case*/</span>) {}
<a name="l01056"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#a00fa1a4ea5831e20746188414268e7c6">01056</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#a00fa1a4ea5831e20746188414268e7c6">OnEnvironmentsTearDownStart</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; <span class="comment">/*unit_test*/</span>) {}
<a name="l01057"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#aea64c83c415b33a4c0b0239bafd1438d">01057</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#aea64c83c415b33a4c0b0239bafd1438d">OnEnvironmentsTearDownEnd</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; <span class="comment">/*unit_test*/</span>) {}
<a name="l01058"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#a2253e5a18b3cf7bccd349567a252209d">01058</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#a2253e5a18b3cf7bccd349567a252209d">OnTestIterationEnd</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; <span class="comment">/*unit_test*/</span>,
<a name="l01059"></a>01059                                   <span class="keywordtype">int</span> <span class="comment">/*iteration*/</span>) {}
<a name="l01060"></a><a class="code" href="classtesting_1_1EmptyTestEventListener.html#a0abcc02bd2331a2e29ad6f4d9daf2a32">01060</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1EmptyTestEventListener.html#a0abcc02bd2331a2e29ad6f4d9daf2a32">OnTestProgramEnd</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>&amp; <span class="comment">/*unit_test*/</span>) {}
<a name="l01061"></a>01061 };
<a name="l01062"></a>01062 
<a name="l01063"></a>01063 <span class="comment">// TestEventListeners lets users add listeners to track events in Google Test.</span>
<a name="l01064"></a><a class="code" href="classtesting_1_1TestEventListeners.html">01064</a> <span class="keyword">class </span><a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> <a class="code" href="classtesting_1_1TestEventListeners.html">TestEventListeners</a> {
<a name="l01065"></a>01065  <span class="keyword">public</span>:
<a name="l01066"></a>01066   <a class="code" href="classtesting_1_1TestEventListeners.html">TestEventListeners</a>();
<a name="l01067"></a>01067   ~<a class="code" href="classtesting_1_1TestEventListeners.html">TestEventListeners</a>();
<a name="l01068"></a>01068 
<a name="l01069"></a>01069   <span class="comment">// Appends an event listener to the end of the list. Google Test assumes</span>
<a name="l01070"></a>01070   <span class="comment">// the ownership of the listener (i.e. it will delete the listener when</span>
<a name="l01071"></a>01071   <span class="comment">// the test program finishes).</span>
<a name="l01072"></a>01072   <span class="keywordtype">void</span> Append(<a class="code" href="classtesting_1_1TestEventListener.html">TestEventListener</a>* listener);
<a name="l01073"></a>01073 
<a name="l01074"></a>01074   <span class="comment">// Removes the given event listener from the list and returns it.  It then</span>
<a name="l01075"></a>01075   <span class="comment">// becomes the caller&#39;s responsibility to delete the listener. Returns</span>
<a name="l01076"></a>01076   <span class="comment">// NULL if the listener is not found in the list.</span>
<a name="l01077"></a>01077   <a class="code" href="classtesting_1_1TestEventListener.html">TestEventListener</a>* Release(<a class="code" href="classtesting_1_1TestEventListener.html">TestEventListener</a>* listener);
<a name="l01078"></a>01078 
<a name="l01079"></a>01079   <span class="comment">// Returns the standard listener responsible for the default console</span>
<a name="l01080"></a>01080   <span class="comment">// output.  Can be removed from the listeners list to shut down default</span>
<a name="l01081"></a>01081   <span class="comment">// console output.  Note that removing this object from the listener list</span>
<a name="l01082"></a>01082   <span class="comment">// with Release transfers its ownership to the caller and makes this</span>
<a name="l01083"></a>01083   <span class="comment">// function return NULL the next time.</span>
<a name="l01084"></a><a class="code" href="classtesting_1_1TestEventListeners.html#a0a69b6a19e27d53d9ef4683c05e9f75a">01084</a>   <a class="code" href="classtesting_1_1TestEventListener.html">TestEventListener</a>* <a class="code" href="classtesting_1_1TestEventListeners.html#a0a69b6a19e27d53d9ef4683c05e9f75a">default_result_printer</a>()<span class="keyword"> const </span>{
<a name="l01085"></a>01085     <span class="keywordflow">return</span> default_result_printer_;
<a name="l01086"></a>01086   }
<a name="l01087"></a>01087 
<a name="l01088"></a>01088   <span class="comment">// Returns the standard listener responsible for the default XML output</span>
<a name="l01089"></a>01089   <span class="comment">// controlled by the --gtest_output=xml flag.  Can be removed from the</span>
<a name="l01090"></a>01090   <span class="comment">// listeners list by users who want to shut down the default XML output</span>
<a name="l01091"></a>01091   <span class="comment">// controlled by this flag and substitute it with custom one.  Note that</span>
<a name="l01092"></a>01092   <span class="comment">// removing this object from the listener list with Release transfers its</span>
<a name="l01093"></a>01093   <span class="comment">// ownership to the caller and makes this function return NULL the next</span>
<a name="l01094"></a>01094   <span class="comment">// time.</span>
<a name="l01095"></a><a class="code" href="classtesting_1_1TestEventListeners.html#a9867c9af50e8d2934a2475286c7cebc5">01095</a>   <a class="code" href="classtesting_1_1TestEventListener.html">TestEventListener</a>* <a class="code" href="classtesting_1_1TestEventListeners.html#a9867c9af50e8d2934a2475286c7cebc5">default_xml_generator</a>()<span class="keyword"> const </span>{
<a name="l01096"></a>01096     <span class="keywordflow">return</span> default_xml_generator_;
<a name="l01097"></a>01097   }
<a name="l01098"></a>01098 
<a name="l01099"></a>01099  <span class="keyword">private</span>:
<a name="l01100"></a><a class="code" href="classtesting_1_1TestEventListeners.html#aff779e55b06adfa7c0088bd10253f0f0">01100</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1TestCase.html">TestCase</a>;
<a name="l01101"></a><a class="code" href="classtesting_1_1TestEventListeners.html#a4c49c2cdb6c328e6b709b4542f23de3c">01101</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>;
<a name="l01102"></a><a class="code" href="classtesting_1_1TestEventListeners.html#abae39633da9932847b41cb80efd62115">01102</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1DefaultGlobalTestPartResultReporter.html">internal::DefaultGlobalTestPartResultReporter</a>;
<a name="l01103"></a><a class="code" href="classtesting_1_1TestEventListeners.html#afddba49fdf3f493532b4d5efb9814f4e">01103</a>   <span class="keyword">friend</span> <span class="keyword">class </span>internal::NoExecDeathTest;
<a name="l01104"></a><a class="code" href="classtesting_1_1TestEventListeners.html#addbc107b6b445617c880182bd4f44cf9">01104</a>   <span class="keyword">friend</span> <span class="keyword">class </span>internal::TestEventListenersAccessor;
<a name="l01105"></a><a class="code" href="classtesting_1_1TestEventListeners.html#acc0a5e7573fd6ae7ad1878613bb86853">01105</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1UnitTestImpl.html">internal::UnitTestImpl</a>;
<a name="l01106"></a>01106 
<a name="l01107"></a>01107   <span class="comment">// Returns repeater that broadcasts the TestEventListener events to all</span>
<a name="l01108"></a>01108   <span class="comment">// subscribers.</span>
<a name="l01109"></a>01109   <a class="code" href="classtesting_1_1TestEventListener.html">TestEventListener</a>* repeater();
<a name="l01110"></a>01110 
<a name="l01111"></a>01111   <span class="comment">// Sets the default_result_printer attribute to the provided listener.</span>
<a name="l01112"></a>01112   <span class="comment">// The listener is also added to the listener list and previous</span>
<a name="l01113"></a>01113   <span class="comment">// default_result_printer is removed from it and deleted. The listener can</span>
<a name="l01114"></a>01114   <span class="comment">// also be NULL in which case it will not be added to the list. Does</span>
<a name="l01115"></a>01115   <span class="comment">// nothing if the previous and the current listener objects are the same.</span>
<a name="l01116"></a>01116   <span class="keywordtype">void</span> SetDefaultResultPrinter(<a class="code" href="classtesting_1_1TestEventListener.html">TestEventListener</a>* listener);
<a name="l01117"></a>01117 
<a name="l01118"></a>01118   <span class="comment">// Sets the default_xml_generator attribute to the provided listener.  The</span>
<a name="l01119"></a>01119   <span class="comment">// listener is also added to the listener list and previous</span>
<a name="l01120"></a>01120   <span class="comment">// default_xml_generator is removed from it and deleted. The listener can</span>
<a name="l01121"></a>01121   <span class="comment">// also be NULL in which case it will not be added to the list. Does</span>
<a name="l01122"></a>01122   <span class="comment">// nothing if the previous and the current listener objects are the same.</span>
<a name="l01123"></a>01123   <span class="keywordtype">void</span> SetDefaultXmlGenerator(<a class="code" href="classtesting_1_1TestEventListener.html">TestEventListener</a>* listener);
<a name="l01124"></a>01124 
<a name="l01125"></a>01125   <span class="comment">// Controls whether events will be forwarded by the repeater to the</span>
<a name="l01126"></a>01126   <span class="comment">// listeners in the list.</span>
<a name="l01127"></a>01127   <span class="keywordtype">bool</span> EventForwardingEnabled() <span class="keyword">const</span>;
<a name="l01128"></a>01128   <span class="keywordtype">void</span> SuppressEventForwarding();
<a name="l01129"></a>01129 
<a name="l01130"></a>01130   <span class="comment">// The actual list of listeners.</span>
<a name="l01131"></a>01131   internal::TestEventRepeater* repeater_;
<a name="l01132"></a>01132   <span class="comment">// Listener responsible for the standard result output.</span>
<a name="l01133"></a>01133   <a class="code" href="classtesting_1_1TestEventListener.html">TestEventListener</a>* default_result_printer_;
<a name="l01134"></a>01134   <span class="comment">// Listener responsible for the creation of the XML output file.</span>
<a name="l01135"></a>01135   <a class="code" href="classtesting_1_1TestEventListener.html">TestEventListener</a>* default_xml_generator_;
<a name="l01136"></a>01136 
<a name="l01137"></a>01137   <span class="comment">// We disallow copying TestEventListeners.</span>
<a name="l01138"></a>01138   <a class="code" href="gtest-port_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(<a class="code" href="classtesting_1_1TestEventListeners.html">TestEventListeners</a>);
<a name="l01139"></a>01139 };
<a name="l01140"></a>01140 
<a name="l01141"></a>01141 <span class="comment">// A UnitTest consists of a vector of TestCases.</span>
<a name="l01142"></a>01142 <span class="comment">//</span>
<a name="l01143"></a>01143 <span class="comment">// This is a singleton class.  The only instance of UnitTest is</span>
<a name="l01144"></a>01144 <span class="comment">// created when UnitTest::GetInstance() is first called.  This</span>
<a name="l01145"></a>01145 <span class="comment">// instance is never deleted.</span>
<a name="l01146"></a>01146 <span class="comment">//</span>
<a name="l01147"></a>01147 <span class="comment">// UnitTest is not copyable.</span>
<a name="l01148"></a>01148 <span class="comment">//</span>
<a name="l01149"></a>01149 <span class="comment">// This class is thread-safe as long as the methods are called</span>
<a name="l01150"></a>01150 <span class="comment">// according to their specification.</span>
<a name="l01151"></a><a class="code" href="classtesting_1_1UnitTest.html">01151</a> <span class="keyword">class </span><a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a> {
<a name="l01152"></a>01152  <span class="keyword">public</span>:
<a name="l01153"></a>01153   <span class="comment">// Gets the singleton UnitTest object.  The first time this method</span>
<a name="l01154"></a>01154   <span class="comment">// is called, a UnitTest object is constructed and returned.</span>
<a name="l01155"></a>01155   <span class="comment">// Consecutive calls will return the same object.</span>
<a name="l01156"></a>01156   <span class="keyword">static</span> <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>* GetInstance();
<a name="l01157"></a>01157 
<a name="l01158"></a>01158   <span class="comment">// Runs all tests in this UnitTest object and prints the result.</span>
<a name="l01159"></a>01159   <span class="comment">// Returns 0 if successful, or 1 otherwise.</span>
<a name="l01160"></a>01160   <span class="comment">//</span>
<a name="l01161"></a>01161   <span class="comment">// This method can only be called from the main thread.</span>
<a name="l01162"></a>01162   <span class="comment">//</span>
<a name="l01163"></a>01163   <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l01164"></a>01164   <span class="keywordtype">int</span> Run() <a class="code" href="gtest-port_8h.html#a8e5aab8276b2645f64f41c9e3021b935">GTEST_MUST_USE_RESULT_</a>;
<a name="l01165"></a>01165 
<a name="l01166"></a>01166   <span class="comment">// Returns the working directory when the first TEST() or TEST_F()</span>
<a name="l01167"></a>01167   <span class="comment">// was executed.  The UnitTest object owns the string.</span>
<a name="l01168"></a>01168   <span class="keyword">const</span> <span class="keywordtype">char</span>* original_working_dir() <span class="keyword">const</span>;
<a name="l01169"></a>01169 
<a name="l01170"></a>01170   <span class="comment">// Returns the TestCase object for the test that&#39;s currently running,</span>
<a name="l01171"></a>01171   <span class="comment">// or NULL if no test is running.</span>
<a name="l01172"></a>01172   <span class="keyword">const</span> <a class="code" href="classtesting_1_1TestCase.html">TestCase</a>* current_test_case() <span class="keyword">const</span>
<a name="l01173"></a>01173       <a class="code" href="gtest-port_8h.html#a69abff5a4efdd07bd5faebe3dd318d06">GTEST_LOCK_EXCLUDED_</a>(mutex_);
<a name="l01174"></a>01174 
<a name="l01175"></a>01175   <span class="comment">// Returns the TestInfo object for the test that&#39;s currently running,</span>
<a name="l01176"></a>01176   <span class="comment">// or NULL if no test is running.</span>
<a name="l01177"></a>01177   <span class="keyword">const</span> <a class="code" href="classtesting_1_1TestInfo.html">TestInfo</a>* current_test_info() <span class="keyword">const</span>
<a name="l01178"></a>01178       <a class="code" href="gtest-port_8h.html#a69abff5a4efdd07bd5faebe3dd318d06">GTEST_LOCK_EXCLUDED_</a>(mutex_);
<a name="l01179"></a>01179 
<a name="l01180"></a>01180   <span class="comment">// Returns the random seed used at the start of the current test run.</span>
<a name="l01181"></a>01181   <span class="keywordtype">int</span> random_seed() <span class="keyword">const</span>;
<a name="l01182"></a>01182 
<a name="l01183"></a>01183 <span class="preprocessor">#if GTEST_HAS_PARAM_TEST</span>
<a name="l01184"></a>01184 <span class="preprocessor"></span>  <span class="comment">// Returns the ParameterizedTestCaseRegistry object used to keep track of</span>
<a name="l01185"></a>01185   <span class="comment">// value-parameterized tests and instantiate and register them.</span>
<a name="l01186"></a>01186   <span class="comment">//</span>
<a name="l01187"></a>01187   <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l01188"></a>01188   internal::ParameterizedTestCaseRegistry&amp; parameterized_test_registry()
<a name="l01189"></a>01189       <a class="code" href="gtest-port_8h.html#a69abff5a4efdd07bd5faebe3dd318d06">GTEST_LOCK_EXCLUDED_</a>(mutex_);
<a name="l01190"></a>01190 <span class="preprocessor">#endif  // GTEST_HAS_PARAM_TEST</span>
<a name="l01191"></a>01191 <span class="preprocessor"></span>
<a name="l01192"></a>01192   <span class="comment">// Gets the number of successful test cases.</span>
<a name="l01193"></a>01193   <span class="keywordtype">int</span> successful_test_case_count() <span class="keyword">const</span>;
<a name="l01194"></a>01194 
<a name="l01195"></a>01195   <span class="comment">// Gets the number of failed test cases.</span>
<a name="l01196"></a>01196   <span class="keywordtype">int</span> failed_test_case_count() <span class="keyword">const</span>;
<a name="l01197"></a>01197 
<a name="l01198"></a>01198   <span class="comment">// Gets the number of all test cases.</span>
<a name="l01199"></a>01199   <span class="keywordtype">int</span> total_test_case_count() <span class="keyword">const</span>;
<a name="l01200"></a>01200 
<a name="l01201"></a>01201   <span class="comment">// Gets the number of all test cases that contain at least one test</span>
<a name="l01202"></a>01202   <span class="comment">// that should run.</span>
<a name="l01203"></a>01203   <span class="keywordtype">int</span> test_case_to_run_count() <span class="keyword">const</span>;
<a name="l01204"></a>01204 
<a name="l01205"></a>01205   <span class="comment">// Gets the number of successful tests.</span>
<a name="l01206"></a>01206   <span class="keywordtype">int</span> successful_test_count() <span class="keyword">const</span>;
<a name="l01207"></a>01207 
<a name="l01208"></a>01208   <span class="comment">// Gets the number of failed tests.</span>
<a name="l01209"></a>01209   <span class="keywordtype">int</span> failed_test_count() <span class="keyword">const</span>;
<a name="l01210"></a>01210 
<a name="l01211"></a>01211   <span class="comment">// Gets the number of disabled tests that will be reported in the XML report.</span>
<a name="l01212"></a>01212   <span class="keywordtype">int</span> reportable_disabled_test_count() <span class="keyword">const</span>;
<a name="l01213"></a>01213 
<a name="l01214"></a>01214   <span class="comment">// Gets the number of disabled tests.</span>
<a name="l01215"></a>01215   <span class="keywordtype">int</span> disabled_test_count() <span class="keyword">const</span>;
<a name="l01216"></a>01216 
<a name="l01217"></a>01217   <span class="comment">// Gets the number of tests to be printed in the XML report.</span>
<a name="l01218"></a>01218   <span class="keywordtype">int</span> reportable_test_count() <span class="keyword">const</span>;
<a name="l01219"></a>01219 
<a name="l01220"></a>01220   <span class="comment">// Gets the number of all tests.</span>
<a name="l01221"></a>01221   <span class="keywordtype">int</span> total_test_count() <span class="keyword">const</span>;
<a name="l01222"></a>01222 
<a name="l01223"></a>01223   <span class="comment">// Gets the number of tests that should run.</span>
<a name="l01224"></a>01224   <span class="keywordtype">int</span> test_to_run_count() <span class="keyword">const</span>;
<a name="l01225"></a>01225 
<a name="l01226"></a>01226   <span class="comment">// Gets the time of the test program start, in ms from the start of the</span>
<a name="l01227"></a>01227   <span class="comment">// UNIX epoch.</span>
<a name="l01228"></a>01228   <a class="code" href="namespacetesting.html#a992de1d091ce660f451d1e8b3ce30fd6">TimeInMillis</a> start_timestamp() <span class="keyword">const</span>;
<a name="l01229"></a>01229 
<a name="l01230"></a>01230   <span class="comment">// Gets the elapsed time, in milliseconds.</span>
<a name="l01231"></a>01231   <a class="code" href="namespacetesting.html#a992de1d091ce660f451d1e8b3ce30fd6">TimeInMillis</a> elapsed_time() <span class="keyword">const</span>;
<a name="l01232"></a>01232 
<a name="l01233"></a>01233   <span class="comment">// Returns true iff the unit test passed (i.e. all test cases passed).</span>
<a name="l01234"></a>01234   <span class="keywordtype">bool</span> Passed() <span class="keyword">const</span>;
<a name="l01235"></a>01235 
<a name="l01236"></a>01236   <span class="comment">// Returns true iff the unit test failed (i.e. some test case failed</span>
<a name="l01237"></a>01237   <span class="comment">// or something outside of all tests failed).</span>
<a name="l01238"></a>01238   <span class="keywordtype">bool</span> Failed() <span class="keyword">const</span>;
<a name="l01239"></a>01239 
<a name="l01240"></a>01240   <span class="comment">// Gets the i-th test case among all the test cases. i can range from 0 to</span>
<a name="l01241"></a>01241   <span class="comment">// total_test_case_count() - 1. If i is not in that range, returns NULL.</span>
<a name="l01242"></a>01242   <span class="keyword">const</span> <a class="code" href="classtesting_1_1TestCase.html">TestCase</a>* GetTestCase(<span class="keywordtype">int</span> i) <span class="keyword">const</span>;
<a name="l01243"></a>01243 
<a name="l01244"></a>01244   <span class="comment">// Returns the TestResult containing information on test failures and</span>
<a name="l01245"></a>01245   <span class="comment">// properties logged outside of individual test cases.</span>
<a name="l01246"></a>01246   <span class="keyword">const</span> <a class="code" href="classtesting_1_1TestResult.html">TestResult</a>&amp; ad_hoc_test_result() <span class="keyword">const</span>;
<a name="l01247"></a>01247 
<a name="l01248"></a>01248   <span class="comment">// Returns the list of event listeners that can be used to track events</span>
<a name="l01249"></a>01249   <span class="comment">// inside Google Test.</span>
<a name="l01250"></a>01250   <a class="code" href="classtesting_1_1TestEventListeners.html">TestEventListeners</a>&amp; listeners();
<a name="l01251"></a>01251 
<a name="l01252"></a>01252  <span class="keyword">private</span>:
<a name="l01253"></a>01253   <span class="comment">// Registers and returns a global test environment.  When a test</span>
<a name="l01254"></a>01254   <span class="comment">// program is run, all global test environments will be set-up in</span>
<a name="l01255"></a>01255   <span class="comment">// the order they were registered.  After all tests in the program</span>
<a name="l01256"></a>01256   <span class="comment">// have finished, all global test environments will be torn-down in</span>
<a name="l01257"></a>01257   <span class="comment">// the *reverse* order they were registered.</span>
<a name="l01258"></a>01258   <span class="comment">//</span>
<a name="l01259"></a>01259   <span class="comment">// The UnitTest object takes ownership of the given environment.</span>
<a name="l01260"></a>01260   <span class="comment">//</span>
<a name="l01261"></a>01261   <span class="comment">// This method can only be called from the main thread.</span>
<a name="l01262"></a>01262   <a class="code" href="classtesting_1_1Environment.html">Environment</a>* AddEnvironment(<a class="code" href="classtesting_1_1Environment.html">Environment</a>* env);
<a name="l01263"></a>01263 
<a name="l01264"></a>01264   <span class="comment">// Adds a TestPartResult to the current TestResult object.  All</span>
<a name="l01265"></a>01265   <span class="comment">// Google Test assertion macros (e.g. ASSERT_TRUE, EXPECT_EQ, etc)</span>
<a name="l01266"></a>01266   <span class="comment">// eventually call this to report their results.  The user code</span>
<a name="l01267"></a>01267   <span class="comment">// should use the assertion macros instead of calling this directly.</span>
<a name="l01268"></a>01268   <span class="keywordtype">void</span> AddTestPartResult(<a class="code" href="classtesting_1_1TestPartResult.html#a65ae656b33fdfdfffaf34858778a52d5">TestPartResult::Type</a> result_type,
<a name="l01269"></a>01269                          <span class="keyword">const</span> <span class="keywordtype">char</span>* file_name,
<a name="l01270"></a>01270                          <span class="keywordtype">int</span> line_number,
<a name="l01271"></a>01271                          <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; message,
<a name="l01272"></a>01272                          <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; os_stack_trace)
<a name="l01273"></a>01273       <a class="code" href="gtest-port_8h.html#a69abff5a4efdd07bd5faebe3dd318d06">GTEST_LOCK_EXCLUDED_</a>(mutex_);
<a name="l01274"></a>01274 
<a name="l01275"></a>01275   <span class="comment">// Adds a TestProperty to the current TestResult object when invoked from</span>
<a name="l01276"></a>01276   <span class="comment">// inside a test, to current TestCase&#39;s ad_hoc_test_result_ when invoked</span>
<a name="l01277"></a>01277   <span class="comment">// from SetUpTestCase or TearDownTestCase, or to the global property set</span>
<a name="l01278"></a>01278   <span class="comment">// when invoked elsewhere.  If the result already contains a property with</span>
<a name="l01279"></a>01279   <span class="comment">// the same key, the value will be updated.</span>
<a name="l01280"></a>01280   <span class="keywordtype">void</span> RecordProperty(<span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; key, <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; value);
<a name="l01281"></a>01281 
<a name="l01282"></a>01282   <span class="comment">// Gets the i-th test case among all the test cases. i can range from 0 to</span>
<a name="l01283"></a>01283   <span class="comment">// total_test_case_count() - 1. If i is not in that range, returns NULL.</span>
<a name="l01284"></a>01284   <a class="code" href="classtesting_1_1TestCase.html">TestCase</a>* GetMutableTestCase(<span class="keywordtype">int</span> i);
<a name="l01285"></a>01285 
<a name="l01286"></a>01286   <span class="comment">// Accessors for the implementation object.</span>
<a name="l01287"></a>01287   <a class="code" href="classtesting_1_1internal_1_1UnitTestImpl.html">internal::UnitTestImpl</a>* impl() { <span class="keywordflow">return</span> impl_; }
<a name="l01288"></a>01288   <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1UnitTestImpl.html">internal::UnitTestImpl</a>* impl()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> impl_; }
<a name="l01289"></a>01289 
<a name="l01290"></a>01290   <span class="comment">// These classes and funcions are friends as they need to access private</span>
<a name="l01291"></a>01291   <span class="comment">// members of UnitTest.</span>
<a name="l01292"></a><a class="code" href="classtesting_1_1UnitTest.html#a5b78b1c2e1fa07ffed92da365593eaa4">01292</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1Test.html">Test</a>;
<a name="l01293"></a><a class="code" href="classtesting_1_1UnitTest.html#a183151aa061362c87572e743fe233db1">01293</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1AssertHelper.html">internal::AssertHelper</a>;
<a name="l01294"></a><a class="code" href="classtesting_1_1UnitTest.html#afa3927576c08d7b1e197ba16b2b3dcb7">01294</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ScopedTrace.html">internal::ScopedTrace</a>;
<a name="l01295"></a><a class="code" href="classtesting_1_1UnitTest.html#adc037d188dab349a94868991955c9cd4">01295</a>   <span class="keyword">friend</span> <span class="keyword">class </span>internal::StreamingListenerTest;
<a name="l01296"></a><a class="code" href="classtesting_1_1UnitTest.html#ae970f89a9f477a349fe5778be85ef42e">01296</a>   <span class="keyword">friend</span> <span class="keyword">class </span>internal::UnitTestRecordPropertyTestHelper;
<a name="l01297"></a>01297   <span class="keyword">friend</span> <a class="code" href="classtesting_1_1Environment.html">Environment</a>* <a class="code" href="namespacetesting.html#a460d7b998622e332392c1e00be3a60d5">AddGlobalTestEnvironment</a>(<a class="code" href="classtesting_1_1Environment.html">Environment</a>* env);
<a name="l01298"></a>01298   <span class="keyword">friend</span> <a class="code" href="classtesting_1_1internal_1_1UnitTestImpl.html">internal::UnitTestImpl</a>* <a class="code" href="namespacetesting_1_1internal.html#a9bd0caf5d16512de38b39599c13ee634">internal::GetUnitTestImpl</a>();
<a name="l01299"></a>01299   <span class="keyword">friend</span> <span class="keywordtype">void</span> <a class="code" href="namespacetesting_1_1internal.html#a85f6ff0e40f9a5f10af66a73cf1364fa">internal::ReportFailureInUnknownLocation</a>(
<a name="l01300"></a>01300       <a class="code" href="classtesting_1_1TestPartResult.html#a65ae656b33fdfdfffaf34858778a52d5">TestPartResult::Type</a> result_type,
<a name="l01301"></a>01301       <span class="keyword">const</span> <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>&amp; message);
<a name="l01302"></a>01302 
<a name="l01303"></a>01303   <span class="comment">// Creates an empty UnitTest.</span>
<a name="l01304"></a>01304   <a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>();
<a name="l01305"></a>01305 
<a name="l01306"></a>01306   <span class="comment">// D&#39;tor</span>
<a name="l01307"></a>01307   <span class="keyword">virtual</span> ~<a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>();
<a name="l01308"></a>01308 
<a name="l01309"></a>01309   <span class="comment">// Pushes a trace defined by SCOPED_TRACE() on to the per-thread</span>
<a name="l01310"></a>01310   <span class="comment">// Google Test trace stack.</span>
<a name="l01311"></a>01311   <span class="keywordtype">void</span> PushGTestTrace(<span class="keyword">const</span> <a class="code" href="structtesting_1_1internal_1_1TraceInfo.html">internal::TraceInfo</a>&amp; trace)
<a name="l01312"></a>01312       <a class="code" href="gtest-port_8h.html#a69abff5a4efdd07bd5faebe3dd318d06">GTEST_LOCK_EXCLUDED_</a>(mutex_);
<a name="l01313"></a>01313 
<a name="l01314"></a>01314   <span class="comment">// Pops a trace from the per-thread Google Test trace stack.</span>
<a name="l01315"></a>01315   <span class="keywordtype">void</span> PopGTestTrace()
<a name="l01316"></a>01316       GTEST_LOCK_EXCLUDED_(mutex_);
<a name="l01317"></a>01317 
<a name="l01318"></a>01318   <span class="comment">// Protects mutable state in *impl_.  This is mutable as some const</span>
<a name="l01319"></a>01319   <span class="comment">// methods need to lock it too.</span>
<a name="l01320"></a>01320   mutable internal::Mutex mutex_;
<a name="l01321"></a>01321 
<a name="l01322"></a>01322   <span class="comment">// Opaque implementation object.  This field is never changed once</span>
<a name="l01323"></a>01323   <span class="comment">// the object is constructed.  We don&#39;t mark it as const here, as</span>
<a name="l01324"></a>01324   <span class="comment">// doing so will cause a warning in the constructor of UnitTest.</span>
<a name="l01325"></a>01325   <span class="comment">// Mutable state in *impl_ is protected by mutex_.</span>
<a name="l01326"></a>01326   internal::UnitTestImpl* impl_;
<a name="l01327"></a>01327 
<a name="l01328"></a>01328   <span class="comment">// We disallow copying UnitTest.</span>
<a name="l01329"></a>01329   <a class="code" href="gtest-port_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(<a class="code" href="classtesting_1_1UnitTest.html">UnitTest</a>);
<a name="l01330"></a>01330 };
<a name="l01331"></a>01331 
<a name="l01332"></a>01332 <span class="comment">// A convenient wrapper for adding an environment for the test</span>
<a name="l01333"></a>01333 <span class="comment">// program.</span>
<a name="l01334"></a>01334 <span class="comment">//</span>
<a name="l01335"></a>01335 <span class="comment">// You should call this before RUN_ALL_TESTS() is called, probably in</span>
<a name="l01336"></a>01336 <span class="comment">// main().  If you use gtest_main, you need to call this before main()</span>
<a name="l01337"></a>01337 <span class="comment">// starts for it to take effect.  For example, you can define a global</span>
<a name="l01338"></a>01338 <span class="comment">// variable like this:</span>
<a name="l01339"></a>01339 <span class="comment">//</span>
<a name="l01340"></a>01340 <span class="comment">//   testing::Environment* const foo_env =</span>
<a name="l01341"></a>01341 <span class="comment">//       testing::AddGlobalTestEnvironment(new FooEnvironment);</span>
<a name="l01342"></a>01342 <span class="comment">//</span>
<a name="l01343"></a>01343 <span class="comment">// However, we strongly recommend you to write your own main() and</span>
<a name="l01344"></a>01344 <span class="comment">// call AddGlobalTestEnvironment() there, as relying on initialization</span>
<a name="l01345"></a>01345 <span class="comment">// of global variables makes the code harder to read and may cause</span>
<a name="l01346"></a>01346 <span class="comment">// problems when you register multiple environments from different</span>
<a name="l01347"></a>01347 <span class="comment">// translation units and the environments have dependencies among them</span>
<a name="l01348"></a>01348 <span class="comment">// (remember that the compiler doesn&#39;t guarantee the order in which</span>
<a name="l01349"></a>01349 <span class="comment">// global variables from different translation units are initialized).</span>
<a name="l01350"></a><a class="code" href="namespacetesting.html#a460d7b998622e332392c1e00be3a60d5">01350</a> inline <a class="code" href="classtesting_1_1Environment.html">Environment</a>* <a class="code" href="namespacetesting.html#a460d7b998622e332392c1e00be3a60d5">AddGlobalTestEnvironment</a>(<a class="code" href="classtesting_1_1Environment.html">Environment</a>* env) {
<a name="l01351"></a>01351   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1UnitTest.html#af254e2e695471eb9f128bc556bae3668">UnitTest::GetInstance</a>()-&gt;AddEnvironment(env);
<a name="l01352"></a>01352 }
<a name="l01353"></a>01353 
<a name="l01354"></a>01354 <span class="comment">// Initializes Google Test.  This must be called before calling</span>
<a name="l01355"></a>01355 <span class="comment">// RUN_ALL_TESTS().  In particular, it parses a command line for the</span>
<a name="l01356"></a>01356 <span class="comment">// flags that Google Test recognizes.  Whenever a Google Test flag is</span>
<a name="l01357"></a>01357 <span class="comment">// seen, it is removed from argv, and *argc is decremented.</span>
<a name="l01358"></a>01358 <span class="comment">//</span>
<a name="l01359"></a>01359 <span class="comment">// No value is returned.  Instead, the Google Test flag variables are</span>
<a name="l01360"></a>01360 <span class="comment">// updated.</span>
<a name="l01361"></a>01361 <span class="comment">//</span>
<a name="l01362"></a>01362 <span class="comment">// Calling the function for the second time has no user-visible effect.</span>
<a name="l01363"></a>01363 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> <span class="keywordtype">void</span> <a class="code" href="namespacetesting.html#aee3f6f99df893f576f705f66c0559482">InitGoogleTest</a>(<span class="keywordtype">int</span>* argc, <span class="keywordtype">char</span>** argv);
<a name="l01364"></a>01364 
<a name="l01365"></a>01365 <span class="comment">// This overloaded version can be used in Windows programs compiled in</span>
<a name="l01366"></a>01366 <span class="comment">// UNICODE mode.</span>
<a name="l01367"></a>01367 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> <span class="keywordtype">void</span> <a class="code" href="namespacetesting.html#aee3f6f99df893f576f705f66c0559482">InitGoogleTest</a>(<span class="keywordtype">int</span>* argc, <span class="keywordtype">wchar_t</span>** argv);
<a name="l01368"></a>01368 
<a name="l01369"></a>01369 <span class="keyword">namespace </span>internal {
<a name="l01370"></a>01370 
<a name="l01371"></a>01371 <span class="comment">// Separate the error generating code from the code path to reduce the stack</span>
<a name="l01372"></a>01372 <span class="comment">// frame size of CmpHelperEQ. This helps reduce the overhead of some sanitizers</span>
<a name="l01373"></a>01373 <span class="comment">// when calling EXPECT_* in a tight loop.</span>
<a name="l01374"></a>01374 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l01375"></a><a class="code" href="namespacetesting_1_1internal.html#a046f222fcbf16cce93c0658ad51c45ea">01375</a> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="namespacetesting_1_1internal.html#a046f222fcbf16cce93c0658ad51c45ea">CmpHelperEQFailure</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01376"></a>01376                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01377"></a>01377                                    <span class="keyword">const</span> T1&amp; expected, <span class="keyword">const</span> T2&amp; actual) {
<a name="l01378"></a>01378   <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#ac61e2ba2cbf259fd6ee5ffd4e49c9445">EqFailure</a>(expected_expression,
<a name="l01379"></a>01379                    actual_expression,
<a name="l01380"></a>01380                    <a class="code" href="namespacetesting_1_1internal.html#a91ab078f10adc669f09b7f604975c518">FormatForComparisonFailureMessage</a>(expected, actual),
<a name="l01381"></a>01381                    <a class="code" href="namespacetesting_1_1internal.html#a91ab078f10adc669f09b7f604975c518">FormatForComparisonFailureMessage</a>(actual, expected),
<a name="l01382"></a>01382                    <span class="keyword">false</span>);
<a name="l01383"></a>01383 }
<a name="l01384"></a>01384 
<a name="l01385"></a>01385 <span class="comment">// The helper function for {ASSERT|EXPECT}_EQ.</span>
<a name="l01386"></a>01386 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l01387"></a><a class="code" href="namespacetesting_1_1internal.html#a36f7c44fad92225cbb45fde1642cf30e">01387</a> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="namespacetesting_1_1internal.html#a36f7c44fad92225cbb45fde1642cf30e">CmpHelperEQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01388"></a>01388                             <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01389"></a>01389                             <span class="keyword">const</span> T1&amp; expected,
<a name="l01390"></a>01390                             <span class="keyword">const</span> T2&amp; actual) {
<a name="l01391"></a>01391 <a class="code" href="gtest-port_8h.html#a86994cc68e844d8b82089c70408dfc61">GTEST_DISABLE_MSC_WARNINGS_PUSH_</a>(4389 <span class="comment">/* signed/unsigned mismatch */</span>)
<a name="l01392"></a>01392   <span class="keywordflow">if</span> (expected == actual) {
<a name="l01393"></a>01393     <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a74a3d26c1286bd4d7c189c5dff2483ab">AssertionSuccess</a>();
<a name="l01394"></a>01394   }
<a name="l01395"></a>01395 <a class="code" href="gtest-port_8h.html#ab4c44546d6d9aced68993b87b608fc06">GTEST_DISABLE_MSC_WARNINGS_POP_</a>()
<a name="l01396"></a>01396 
<a name="l01397"></a>01397   <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#a046f222fcbf16cce93c0658ad51c45ea">CmpHelperEQFailure</a>(expected_expression, actual_expression, expected,
<a name="l01398"></a>01398                             actual);
<a name="l01399"></a>01399 }
<a name="l01400"></a>01400 
<a name="l01401"></a>01401 <span class="comment">// With this overloaded version, we allow anonymous enums to be used</span>
<a name="l01402"></a>01402 <span class="comment">// in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous enums</span>
<a name="l01403"></a>01403 <span class="comment">// can be implicitly cast to BiggestInt.</span>
<a name="l01404"></a>01404 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="namespacetesting_1_1internal.html#a36f7c44fad92225cbb45fde1642cf30e">CmpHelperEQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01405"></a>01405                                        <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01406"></a>01406                                        <a class="code" href="namespacetesting_1_1internal.html#a05c6bd9ede5ccdf25191a590d610dcc6">BiggestInt</a> expected,
<a name="l01407"></a>01407                                        <a class="code" href="namespacetesting_1_1internal.html#a05c6bd9ede5ccdf25191a590d610dcc6">BiggestInt</a> actual);
<a name="l01408"></a>01408 
<a name="l01409"></a>01409 <span class="comment">// The helper class for {ASSERT|EXPECT}_EQ.  The template argument</span>
<a name="l01410"></a>01410 <span class="comment">// lhs_is_null_literal is true iff the first argument to ASSERT_EQ()</span>
<a name="l01411"></a>01411 <span class="comment">// is a null pointer literal.  The following default implementation is</span>
<a name="l01412"></a>01412 <span class="comment">// for lhs_is_null_literal being false.</span>
<a name="l01413"></a>01413 <span class="keyword">template</span> &lt;<span class="keywordtype">bool</span> lhs_is_null_literal&gt;
<a name="l01414"></a><a class="code" href="classtesting_1_1internal_1_1EqHelper.html">01414</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1EqHelper.html">EqHelper</a> {
<a name="l01415"></a>01415  <span class="keyword">public</span>:
<a name="l01416"></a>01416   <span class="comment">// This templatized version is for the general case.</span>
<a name="l01417"></a>01417   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l01418"></a><a class="code" href="classtesting_1_1internal_1_1EqHelper.html#ac2977ed90cd3c88607f804e43b86b92c">01418</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> Compare(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01419"></a>01419                                  <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01420"></a>01420                                  <span class="keyword">const</span> T1&amp; expected,
<a name="l01421"></a>01421                                  <span class="keyword">const</span> T2&amp; actual) {
<a name="l01422"></a>01422     <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#a36f7c44fad92225cbb45fde1642cf30e">CmpHelperEQ</a>(expected_expression, actual_expression, expected,
<a name="l01423"></a>01423                        actual);
<a name="l01424"></a>01424   }
<a name="l01425"></a>01425 
<a name="l01426"></a>01426   <span class="comment">// With this overloaded version, we allow anonymous enums to be used</span>
<a name="l01427"></a>01427   <span class="comment">// in {ASSERT|EXPECT}_EQ when compiled with gcc 4, as anonymous</span>
<a name="l01428"></a>01428   <span class="comment">// enums can be implicitly cast to BiggestInt.</span>
<a name="l01429"></a>01429   <span class="comment">//</span>
<a name="l01430"></a>01430   <span class="comment">// Even though its body looks the same as the above version, we</span>
<a name="l01431"></a>01431   <span class="comment">// cannot merge the two, as it will make anonymous enums unhappy.</span>
<a name="l01432"></a><a class="code" href="classtesting_1_1internal_1_1EqHelper.html#a3de996954b41d484c065ed824fe7eac9">01432</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> Compare(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01433"></a>01433                                  <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01434"></a>01434                                  <a class="code" href="namespacetesting_1_1internal.html#a05c6bd9ede5ccdf25191a590d610dcc6">BiggestInt</a> expected,
<a name="l01435"></a>01435                                  <a class="code" href="namespacetesting_1_1internal.html#a05c6bd9ede5ccdf25191a590d610dcc6">BiggestInt</a> actual) {
<a name="l01436"></a>01436     <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#a36f7c44fad92225cbb45fde1642cf30e">CmpHelperEQ</a>(expected_expression, actual_expression, expected,
<a name="l01437"></a>01437                        actual);
<a name="l01438"></a>01438   }
<a name="l01439"></a>01439 };
<a name="l01440"></a>01440 
<a name="l01441"></a>01441 <span class="comment">// This specialization is used when the first argument to ASSERT_EQ()</span>
<a name="l01442"></a>01442 <span class="comment">// is a null pointer literal, like NULL, false, or 0.</span>
<a name="l01443"></a>01443 <span class="keyword">template</span> &lt;&gt;
<a name="l01444"></a><a class="code" href="classtesting_1_1internal_1_1EqHelper_3_01true_01_4.html">01444</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1EqHelper.html">EqHelper</a>&lt;true&gt; {
<a name="l01445"></a>01445  <span class="keyword">public</span>:
<a name="l01446"></a>01446   <span class="comment">// We define two overloaded versions of Compare().  The first</span>
<a name="l01447"></a>01447   <span class="comment">// version will be picked when the second argument to ASSERT_EQ() is</span>
<a name="l01448"></a>01448   <span class="comment">// NOT a pointer, e.g. ASSERT_EQ(0, AnIntFunction()) or</span>
<a name="l01449"></a>01449   <span class="comment">// EXPECT_EQ(false, a_bool).</span>
<a name="l01450"></a>01450   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l01451"></a><a class="code" href="classtesting_1_1internal_1_1EqHelper_3_01true_01_4.html#a70d6d7e3cb1df06ad6114f25e843fd6d">01451</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> Compare(
<a name="l01452"></a>01452       <span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01453"></a>01453       <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01454"></a>01454       <span class="keyword">const</span> T1&amp; expected,
<a name="l01455"></a>01455       <span class="keyword">const</span> T2&amp; actual,
<a name="l01456"></a>01456       <span class="comment">// The following line prevents this overload from being considered if T2</span>
<a name="l01457"></a>01457       <span class="comment">// is not a pointer type.  We need this because ASSERT_EQ(NULL, my_ptr)</span>
<a name="l01458"></a>01458       <span class="comment">// expands to Compare(&quot;&quot;, &quot;&quot;, NULL, my_ptr), which requires a conversion</span>
<a name="l01459"></a>01459       <span class="comment">// to match the Secret* in the other overload, which would otherwise make</span>
<a name="l01460"></a>01460       <span class="comment">// this template match better.</span>
<a name="l01461"></a>01461       <span class="keyword">typename</span> EnableIf&lt;!<a class="code" href="structtesting_1_1internal_1_1is__pointer.html">is_pointer&lt;T2&gt;::value</a>&gt;::type* = 0) {
<a name="l01462"></a>01462     <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#a36f7c44fad92225cbb45fde1642cf30e">CmpHelperEQ</a>(expected_expression, actual_expression, expected,
<a name="l01463"></a>01463                        actual);
<a name="l01464"></a>01464   }
<a name="l01465"></a>01465 
<a name="l01466"></a>01466   <span class="comment">// This version will be picked when the second argument to ASSERT_EQ() is a</span>
<a name="l01467"></a>01467   <span class="comment">// pointer, e.g. ASSERT_EQ(NULL, a_pointer).</span>
<a name="l01468"></a>01468   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01469"></a><a class="code" href="classtesting_1_1internal_1_1EqHelper_3_01true_01_4.html#ab38e840297adb48f18767a1a99187fb3">01469</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> Compare(
<a name="l01470"></a>01470       <span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01471"></a>01471       <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01472"></a>01472       <span class="comment">// We used to have a second template parameter instead of Secret*.  That</span>
<a name="l01473"></a>01473       <span class="comment">// template parameter would deduce to &#39;long&#39;, making this a better match</span>
<a name="l01474"></a>01474       <span class="comment">// than the first overload even without the first overload&#39;s EnableIf.</span>
<a name="l01475"></a>01475       <span class="comment">// Unfortunately, gcc with -Wconversion-null warns when &quot;passing NULL to</span>
<a name="l01476"></a>01476       <span class="comment">// non-pointer argument&quot; (even a deduced integral argument), so the old</span>
<a name="l01477"></a>01477       <span class="comment">// implementation caused warnings in user code.</span>
<a name="l01478"></a>01478       Secret* <span class="comment">/* expected (NULL) */</span>,
<a name="l01479"></a>01479       T* actual) {
<a name="l01480"></a>01480     <span class="comment">// We already know that &#39;expected&#39; is a null pointer.</span>
<a name="l01481"></a>01481     <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#a36f7c44fad92225cbb45fde1642cf30e">CmpHelperEQ</a>(expected_expression, actual_expression,
<a name="l01482"></a>01482                        static_cast&lt;T*&gt;(NULL), actual);
<a name="l01483"></a>01483   }
<a name="l01484"></a>01484 };
<a name="l01485"></a>01485 
<a name="l01486"></a>01486 <span class="comment">// Separate the error generating code from the code path to reduce the stack</span>
<a name="l01487"></a>01487 <span class="comment">// frame size of CmpHelperOP. This helps reduce the overhead of some sanitizers</span>
<a name="l01488"></a>01488 <span class="comment">// when calling EXPECT_OP in a tight loop.</span>
<a name="l01489"></a>01489 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l01490"></a><a class="code" href="namespacetesting_1_1internal.html#a894ffccd936d78fd555f490020c27f0a">01490</a> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="namespacetesting_1_1internal.html#a894ffccd936d78fd555f490020c27f0a">CmpHelperOpFailure</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr1, <span class="keyword">const</span> <span class="keywordtype">char</span>* expr2,
<a name="l01491"></a>01491                                    <span class="keyword">const</span> T1&amp; val1, <span class="keyword">const</span> T2&amp; val2,
<a name="l01492"></a>01492                                    <span class="keyword">const</span> <span class="keywordtype">char</span>* op) {
<a name="l01493"></a>01493   <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a8d91083190a5914bfe8c5666e2dbca9b">AssertionFailure</a>()
<a name="l01494"></a>01494          &lt;&lt; <span class="stringliteral">&quot;Expected: (&quot;</span> &lt;&lt; expr1 &lt;&lt; <span class="stringliteral">&quot;) &quot;</span> &lt;&lt; op &lt;&lt; <span class="stringliteral">&quot; (&quot;</span> &lt;&lt; expr2
<a name="l01495"></a>01495          &lt;&lt; <span class="stringliteral">&quot;), actual: &quot;</span> &lt;&lt; <a class="code" href="namespacetesting_1_1internal.html#a91ab078f10adc669f09b7f604975c518">FormatForComparisonFailureMessage</a>(val1, val2)
<a name="l01496"></a>01496          &lt;&lt; <span class="stringliteral">&quot; vs &quot;</span> &lt;&lt; <a class="code" href="namespacetesting_1_1internal.html#a91ab078f10adc669f09b7f604975c518">FormatForComparisonFailureMessage</a>(val2, val1);
<a name="l01497"></a>01497 }
<a name="l01498"></a>01498 
<a name="l01499"></a>01499 <span class="comment">// A macro for implementing the helper functions needed to implement</span>
<a name="l01500"></a>01500 <span class="comment">// ASSERT_?? and EXPECT_??.  It is here just to avoid copy-and-paste</span>
<a name="l01501"></a>01501 <span class="comment">// of similar code.</span>
<a name="l01502"></a>01502 <span class="comment">//</span>
<a name="l01503"></a>01503 <span class="comment">// For each templatized helper function, we also define an overloaded</span>
<a name="l01504"></a>01504 <span class="comment">// version for BiggestInt in order to reduce code bloat and allow</span>
<a name="l01505"></a>01505 <span class="comment">// anonymous enums to be used with {ASSERT|EXPECT}_?? when compiled</span>
<a name="l01506"></a>01506 <span class="comment">// with gcc 4.</span>
<a name="l01507"></a>01507 <span class="comment">//</span>
<a name="l01508"></a>01508 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l01509"></a>01509 
<a name="l01510"></a><a class="code" href="gtest_8h.html#a4a5b6fbde5dd05e05dd6846ac5e5c18e">01510</a> <span class="preprocessor">#define GTEST_IMPL_CMP_HELPER_(op_name, op)\</span>
<a name="l01511"></a>01511 <span class="preprocessor">template &lt;typename T1, typename T2&gt;\</span>
<a name="l01512"></a>01512 <span class="preprocessor">AssertionResult CmpHelper##op_name(const char* expr1, const char* expr2, \</span>
<a name="l01513"></a>01513 <span class="preprocessor">                                   const T1&amp; val1, const T2&amp; val2) {\</span>
<a name="l01514"></a>01514 <span class="preprocessor">  if (val1 op val2) {\</span>
<a name="l01515"></a>01515 <span class="preprocessor">    return AssertionSuccess();\</span>
<a name="l01516"></a>01516 <span class="preprocessor">  } else {\</span>
<a name="l01517"></a>01517 <span class="preprocessor">    return CmpHelperOpFailure(expr1, expr2, val1, val2, #op);\</span>
<a name="l01518"></a>01518 <span class="preprocessor">  }\</span>
<a name="l01519"></a>01519 <span class="preprocessor">}\</span>
<a name="l01520"></a>01520 <span class="preprocessor">GTEST_API_ AssertionResult CmpHelper##op_name(\</span>
<a name="l01521"></a>01521 <span class="preprocessor">    const char* expr1, const char* expr2, BiggestInt val1, BiggestInt val2)</span>
<a name="l01522"></a>01522 <span class="preprocessor"></span>
<a name="l01523"></a>01523 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l01524"></a>01524 
<a name="l01525"></a>01525 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_NE</span>
<a name="l01526"></a>01526 <a class="code" href="gtest_8h.html#a4a5b6fbde5dd05e05dd6846ac5e5c18e">GTEST_IMPL_CMP_HELPER_</a>(NE, !=);
<a name="l01527"></a>01527 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_LE</span>
<a name="l01528"></a>01528 <a class="code" href="gtest_8h.html#a4a5b6fbde5dd05e05dd6846ac5e5c18e">GTEST_IMPL_CMP_HELPER_</a>(LE, &lt;=);
<a name="l01529"></a>01529 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_LT</span>
<a name="l01530"></a>01530 <a class="code" href="gtest_8h.html#a4a5b6fbde5dd05e05dd6846ac5e5c18e">GTEST_IMPL_CMP_HELPER_</a>(LT, &lt;);
<a name="l01531"></a>01531 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_GE</span>
<a name="l01532"></a>01532 <a class="code" href="gtest_8h.html#a4a5b6fbde5dd05e05dd6846ac5e5c18e">GTEST_IMPL_CMP_HELPER_</a>(GE, &gt;=);
<a name="l01533"></a>01533 <span class="comment">// Implements the helper function for {ASSERT|EXPECT}_GT</span>
<a name="l01534"></a>01534 <a class="code" href="gtest_8h.html#a4a5b6fbde5dd05e05dd6846ac5e5c18e">GTEST_IMPL_CMP_HELPER_</a>(GT, &gt;);
<a name="l01535"></a>01535 
<a name="l01536"></a>01536 <span class="preprocessor">#undef GTEST_IMPL_CMP_HELPER_</span>
<a name="l01537"></a>01537 <span class="preprocessor"></span>
<a name="l01538"></a>01538 <span class="comment">// The helper function for {ASSERT|EXPECT}_STREQ.</span>
<a name="l01539"></a>01539 <span class="comment">//</span>
<a name="l01540"></a>01540 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l01541"></a>01541 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting_1_1internal.html#a8621c45bf8d0c06ea0dda6f8cdbc2c6b">CmpHelperSTREQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01542"></a>01542                                           <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01543"></a>01543                                           <span class="keyword">const</span> <span class="keywordtype">char</span>* expected,
<a name="l01544"></a>01544                                           <span class="keyword">const</span> <span class="keywordtype">char</span>* actual);
<a name="l01545"></a>01545 
<a name="l01546"></a>01546 <span class="comment">// The helper function for {ASSERT|EXPECT}_STRCASEEQ.</span>
<a name="l01547"></a>01547 <span class="comment">//</span>
<a name="l01548"></a>01548 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l01549"></a>01549 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting_1_1internal.html#a911fceccafc659cf4b564c88634803bf">CmpHelperSTRCASEEQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01550"></a>01550                                               <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01551"></a>01551                                               <span class="keyword">const</span> <span class="keywordtype">char</span>* expected,
<a name="l01552"></a>01552                                               <span class="keyword">const</span> <span class="keywordtype">char</span>* actual);
<a name="l01553"></a>01553 
<a name="l01554"></a>01554 <span class="comment">// The helper function for {ASSERT|EXPECT}_STRNE.</span>
<a name="l01555"></a>01555 <span class="comment">//</span>
<a name="l01556"></a>01556 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l01557"></a>01557 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting_1_1internal.html#a6b485231a046ff760844a0321c04870b">CmpHelperSTRNE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s1_expression,
<a name="l01558"></a>01558                                           <span class="keyword">const</span> <span class="keywordtype">char</span>* s2_expression,
<a name="l01559"></a>01559                                           <span class="keyword">const</span> <span class="keywordtype">char</span>* s1,
<a name="l01560"></a>01560                                           <span class="keyword">const</span> <span class="keywordtype">char</span>* s2);
<a name="l01561"></a>01561 
<a name="l01562"></a>01562 <span class="comment">// The helper function for {ASSERT|EXPECT}_STRCASENE.</span>
<a name="l01563"></a>01563 <span class="comment">//</span>
<a name="l01564"></a>01564 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l01565"></a>01565 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting_1_1internal.html#a5f74b933606b0a742cd5a8ad2d7087e0">CmpHelperSTRCASENE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s1_expression,
<a name="l01566"></a>01566                                               <span class="keyword">const</span> <span class="keywordtype">char</span>* s2_expression,
<a name="l01567"></a>01567                                               <span class="keyword">const</span> <span class="keywordtype">char</span>* s1,
<a name="l01568"></a>01568                                               <span class="keyword">const</span> <span class="keywordtype">char</span>* s2);
<a name="l01569"></a>01569 
<a name="l01570"></a>01570 
<a name="l01571"></a>01571 <span class="comment">// Helper function for *_STREQ on wide strings.</span>
<a name="l01572"></a>01572 <span class="comment">//</span>
<a name="l01573"></a>01573 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l01574"></a>01574 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting_1_1internal.html#a8621c45bf8d0c06ea0dda6f8cdbc2c6b">CmpHelperSTREQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01575"></a>01575                                           <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01576"></a>01576                                           <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* expected,
<a name="l01577"></a>01577                                           <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* actual);
<a name="l01578"></a>01578 
<a name="l01579"></a>01579 <span class="comment">// Helper function for *_STRNE on wide strings.</span>
<a name="l01580"></a>01580 <span class="comment">//</span>
<a name="l01581"></a>01581 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l01582"></a>01582 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting_1_1internal.html#a6b485231a046ff760844a0321c04870b">CmpHelperSTRNE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* s1_expression,
<a name="l01583"></a>01583                                           <span class="keyword">const</span> <span class="keywordtype">char</span>* s2_expression,
<a name="l01584"></a>01584                                           <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* s1,
<a name="l01585"></a>01585                                           <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* s2);
<a name="l01586"></a>01586 
<a name="l01587"></a>01587 }  <span class="comment">// namespace internal</span>
<a name="l01588"></a>01588 
<a name="l01589"></a>01589 <span class="comment">// IsSubstring() and IsNotSubstring() are intended to be used as the</span>
<a name="l01590"></a>01590 <span class="comment">// first argument to {EXPECT,ASSERT}_PRED_FORMAT2(), not by</span>
<a name="l01591"></a>01591 <span class="comment">// themselves.  They check whether needle is a substring of haystack</span>
<a name="l01592"></a>01592 <span class="comment">// (NULL is considered a substring of itself only), and return an</span>
<a name="l01593"></a>01593 <span class="comment">// appropriate error message when they fail.</span>
<a name="l01594"></a>01594 <span class="comment">//</span>
<a name="l01595"></a>01595 <span class="comment">// The {needle,haystack}_expr arguments are the stringified</span>
<a name="l01596"></a>01596 <span class="comment">// expressions that generated the two real arguments.</span>
<a name="l01597"></a>01597 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#a5c90a86562b2470213c07742e0eeb0fe">IsSubstring</a>(
<a name="l01598"></a>01598     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01599"></a>01599     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack);
<a name="l01600"></a>01600 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#a5c90a86562b2470213c07742e0eeb0fe">IsSubstring</a>(
<a name="l01601"></a>01601     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01602"></a>01602     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* needle, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* haystack);
<a name="l01603"></a>01603 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#ab553b649b06ef2339cbd90f8dfa119f0">IsNotSubstring</a>(
<a name="l01604"></a>01604     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01605"></a>01605     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack);
<a name="l01606"></a>01606 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#ab553b649b06ef2339cbd90f8dfa119f0">IsNotSubstring</a>(
<a name="l01607"></a>01607     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01608"></a>01608     <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* needle, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* haystack);
<a name="l01609"></a>01609 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#a5c90a86562b2470213c07742e0eeb0fe">IsSubstring</a>(
<a name="l01610"></a>01610     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01611"></a>01611     <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">const ::std::string</a>&amp; needle, <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">const ::std::string</a>&amp; haystack);
<a name="l01612"></a>01612 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#ab553b649b06ef2339cbd90f8dfa119f0">IsNotSubstring</a>(
<a name="l01613"></a>01613     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01614"></a>01614     <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">const ::std::string</a>&amp; needle, <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">const ::std::string</a>&amp; haystack);
<a name="l01615"></a>01615 
<a name="l01616"></a>01616 <span class="preprocessor">#if GTEST_HAS_STD_WSTRING</span>
<a name="l01617"></a>01617 <span class="preprocessor"></span><a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#a5c90a86562b2470213c07742e0eeb0fe">IsSubstring</a>(
<a name="l01618"></a>01618     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01619"></a>01619     <a class="code" href="namespacetesting_1_1internal.html#a3f543179329c353aee1d7b54a9a8e335">const ::std::wstring</a>&amp; needle, <a class="code" href="namespacetesting_1_1internal.html#a3f543179329c353aee1d7b54a9a8e335">const ::std::wstring</a>&amp; haystack);
<a name="l01620"></a>01620 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#ab553b649b06ef2339cbd90f8dfa119f0">IsNotSubstring</a>(
<a name="l01621"></a>01621     <span class="keyword">const</span> <span class="keywordtype">char</span>* needle_expr, <span class="keyword">const</span> <span class="keywordtype">char</span>* haystack_expr,
<a name="l01622"></a>01622     <a class="code" href="namespacetesting_1_1internal.html#a3f543179329c353aee1d7b54a9a8e335">const ::std::wstring</a>&amp; needle, <a class="code" href="namespacetesting_1_1internal.html#a3f543179329c353aee1d7b54a9a8e335">const ::std::wstring</a>&amp; haystack);
<a name="l01623"></a>01623 <span class="preprocessor">#endif  // GTEST_HAS_STD_WSTRING</span>
<a name="l01624"></a>01624 <span class="preprocessor"></span>
<a name="l01625"></a>01625 <span class="keyword">namespace </span>internal {
<a name="l01626"></a>01626 
<a name="l01627"></a>01627 <span class="comment">// Helper template function for comparing floating-points.</span>
<a name="l01628"></a>01628 <span class="comment">//</span>
<a name="l01629"></a>01629 <span class="comment">// Template parameter:</span>
<a name="l01630"></a>01630 <span class="comment">//</span>
<a name="l01631"></a>01631 <span class="comment">//   RawType: the raw floating-point type (either float or double)</span>
<a name="l01632"></a>01632 <span class="comment">//</span>
<a name="l01633"></a>01633 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l01634"></a>01634 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> RawType&gt;
<a name="l01635"></a><a class="code" href="namespacetesting_1_1internal.html#aaf581f35dfe9f1a3705f99b455a18abd">01635</a> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="namespacetesting_1_1internal.html#aaf581f35dfe9f1a3705f99b455a18abd">CmpHelperFloatingPointEQ</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expected_expression,
<a name="l01636"></a>01636                                          <span class="keyword">const</span> <span class="keywordtype">char</span>* actual_expression,
<a name="l01637"></a>01637                                          RawType expected,
<a name="l01638"></a>01638                                          RawType actual) {
<a name="l01639"></a>01639   <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1FloatingPoint.html">FloatingPoint&lt;RawType&gt;</a> lhs(expected), rhs(actual);
<a name="l01640"></a>01640 
<a name="l01641"></a>01641   <span class="keywordflow">if</span> (lhs.AlmostEquals(rhs)) {
<a name="l01642"></a>01642     <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a74a3d26c1286bd4d7c189c5dff2483ab">AssertionSuccess</a>();
<a name="l01643"></a>01643   }
<a name="l01644"></a>01644 
<a name="l01645"></a>01645   ::std::stringstream expected_ss;
<a name="l01646"></a>01646   expected_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)
<a name="l01647"></a>01647               &lt;&lt; expected;
<a name="l01648"></a>01648 
<a name="l01649"></a>01649   ::std::stringstream actual_ss;
<a name="l01650"></a>01650   actual_ss &lt;&lt; std::setprecision(std::numeric_limits&lt;RawType&gt;::digits10 + 2)
<a name="l01651"></a>01651             &lt;&lt; actual;
<a name="l01652"></a>01652 
<a name="l01653"></a>01653   <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#ac61e2ba2cbf259fd6ee5ffd4e49c9445">EqFailure</a>(expected_expression,
<a name="l01654"></a>01654                    actual_expression,
<a name="l01655"></a>01655                    <a class="code" href="namespacetesting_1_1internal.html#a75bdbc38815772055696b2a40bae614e">StringStreamToString</a>(&amp;expected_ss),
<a name="l01656"></a>01656                    <a class="code" href="namespacetesting_1_1internal.html#a75bdbc38815772055696b2a40bae614e">StringStreamToString</a>(&amp;actual_ss),
<a name="l01657"></a>01657                    <span class="keyword">false</span>);
<a name="l01658"></a>01658 }
<a name="l01659"></a>01659 
<a name="l01660"></a>01660 <span class="comment">// Helper function for implementing ASSERT_NEAR.</span>
<a name="l01661"></a>01661 <span class="comment">//</span>
<a name="l01662"></a>01662 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN A USER PROGRAM.</span>
<a name="l01663"></a>01663 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> <a class="code" href="classtesting_1_1AssertionResult.html">AssertionResult</a> <a class="code" href="namespacetesting_1_1internal.html#aea60207c4cedc8946a70ada62e38da8f">DoubleNearPredFormat</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr1,
<a name="l01664"></a>01664                                                 <span class="keyword">const</span> <span class="keywordtype">char</span>* expr2,
<a name="l01665"></a>01665                                                 <span class="keyword">const</span> <span class="keywordtype">char</span>* abs_error_expr,
<a name="l01666"></a>01666                                                 <span class="keywordtype">double</span> val1,
<a name="l01667"></a>01667                                                 <span class="keywordtype">double</span> val2,
<a name="l01668"></a>01668                                                 <span class="keywordtype">double</span> abs_error);
<a name="l01669"></a>01669 
<a name="l01670"></a>01670 <span class="comment">// INTERNAL IMPLEMENTATION - DO NOT USE IN USER CODE.</span>
<a name="l01671"></a>01671 <span class="comment">// A class that enables one to stream messages to assertion macros</span>
<a name="l01672"></a><a class="code" href="classtesting_1_1internal_1_1AssertHelper.html">01672</a> <span class="keyword">class </span><a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> <a class="code" href="classtesting_1_1internal_1_1AssertHelper.html">AssertHelper</a> {
<a name="l01673"></a>01673  <span class="keyword">public</span>:
<a name="l01674"></a>01674   <span class="comment">// Constructor.</span>
<a name="l01675"></a>01675   <a class="code" href="classtesting_1_1internal_1_1AssertHelper.html">AssertHelper</a>(<a class="code" href="classtesting_1_1TestPartResult.html#a65ae656b33fdfdfffaf34858778a52d5">TestPartResult::Type</a> type,
<a name="l01676"></a>01676                <span class="keyword">const</span> <span class="keywordtype">char</span>* file,
<a name="l01677"></a>01677                <span class="keywordtype">int</span> line,
<a name="l01678"></a>01678                <span class="keyword">const</span> <span class="keywordtype">char</span>* message);
<a name="l01679"></a>01679   ~<a class="code" href="classtesting_1_1internal_1_1AssertHelper.html">AssertHelper</a>();
<a name="l01680"></a>01680 
<a name="l01681"></a>01681   <span class="comment">// Message assignment is a semantic trick to enable assertion</span>
<a name="l01682"></a>01682   <span class="comment">// streaming; see the GTEST_MESSAGE_ macro below.</span>
<a name="l01683"></a>01683   <span class="keywordtype">void</span> operator=(<span class="keyword">const</span> <a class="code" href="classtesting_1_1Message.html">Message</a>&amp; message) <span class="keyword">const</span>;
<a name="l01684"></a>01684 
<a name="l01685"></a>01685  <span class="keyword">private</span>:
<a name="l01686"></a>01686   <span class="comment">// We put our data in a struct so that the size of the AssertHelper class can</span>
<a name="l01687"></a>01687   <span class="comment">// be as small as possible.  This is important because gcc is incapable of</span>
<a name="l01688"></a>01688   <span class="comment">// re-using stack space even for temporary variables, so every EXPECT_EQ</span>
<a name="l01689"></a>01689   <span class="comment">// reserves stack space for another AssertHelper.</span>
<a name="l01690"></a>01690   <span class="keyword">struct </span>AssertHelperData {
<a name="l01691"></a>01691     AssertHelperData(<a class="code" href="classtesting_1_1TestPartResult.html#a65ae656b33fdfdfffaf34858778a52d5">TestPartResult::Type</a> t,
<a name="l01692"></a>01692                      <span class="keyword">const</span> <span class="keywordtype">char</span>* srcfile,
<a name="l01693"></a>01693                      <span class="keywordtype">int</span> line_num,
<a name="l01694"></a>01694                      <span class="keyword">const</span> <span class="keywordtype">char</span>* msg)
<a name="l01695"></a>01695         : type(t), file(srcfile), line(line_num), message(msg) { }
<a name="l01696"></a>01696 
<a name="l01697"></a>01697     <a class="code" href="classtesting_1_1TestPartResult.html#a65ae656b33fdfdfffaf34858778a52d5">TestPartResult::Type</a> <span class="keyword">const</span> type;
<a name="l01698"></a>01698     <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> file;
<a name="l01699"></a>01699     <span class="keywordtype">int</span> <span class="keyword">const</span> line;
<a name="l01700"></a>01700     <a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a> <span class="keyword">const</span> message;
<a name="l01701"></a>01701 
<a name="l01702"></a>01702    <span class="keyword">private</span>:
<a name="l01703"></a>01703     <a class="code" href="gtest-port_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(AssertHelperData);
<a name="l01704"></a>01704   };
<a name="l01705"></a>01705 
<a name="l01706"></a>01706   AssertHelperData* <span class="keyword">const</span> data_;
<a name="l01707"></a>01707 
<a name="l01708"></a>01708   <a class="code" href="gtest-port_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(<a class="code" href="classtesting_1_1internal_1_1AssertHelper.html">AssertHelper</a>);
<a name="l01709"></a>01709 };
<a name="l01710"></a>01710 
<a name="l01711"></a>01711 }  <span class="comment">// namespace internal</span>
<a name="l01712"></a>01712 
<a name="l01713"></a>01713 <span class="preprocessor">#if GTEST_HAS_PARAM_TEST</span>
<a name="l01714"></a>01714 <span class="preprocessor"></span><span class="comment">// The pure interface class that all value-parameterized tests inherit from.</span>
<a name="l01715"></a>01715 <span class="comment">// A value-parameterized class must inherit from both ::testing::Test and</span>
<a name="l01716"></a>01716 <span class="comment">// ::testing::WithParamInterface. In most cases that just means inheriting</span>
<a name="l01717"></a>01717 <span class="comment">// from ::testing::TestWithParam, but more complicated test hierarchies</span>
<a name="l01718"></a>01718 <span class="comment">// may need to inherit from Test and WithParamInterface at different levels.</span>
<a name="l01719"></a>01719 <span class="comment">//</span>
<a name="l01720"></a>01720 <span class="comment">// This interface has support for accessing the test parameter value via</span>
<a name="l01721"></a>01721 <span class="comment">// the GetParam() method.</span>
<a name="l01722"></a>01722 <span class="comment">//</span>
<a name="l01723"></a>01723 <span class="comment">// Use it with one of the parameter generator defining functions, like Range(),</span>
<a name="l01724"></a>01724 <span class="comment">// Values(), ValuesIn(), Bool(), and Combine().</span>
<a name="l01725"></a>01725 <span class="comment">//</span>
<a name="l01726"></a>01726 <span class="comment">// class FooTest : public ::testing::TestWithParam&lt;int&gt; {</span>
<a name="l01727"></a>01727 <span class="comment">//  protected:</span>
<a name="l01728"></a>01728 <span class="comment">//   FooTest() {</span>
<a name="l01729"></a>01729 <span class="comment">//     // Can use GetParam() here.</span>
<a name="l01730"></a>01730 <span class="comment">//   }</span>
<a name="l01731"></a>01731 <span class="comment">//   virtual ~FooTest() {</span>
<a name="l01732"></a>01732 <span class="comment">//     // Can use GetParam() here.</span>
<a name="l01733"></a>01733 <span class="comment">//   }</span>
<a name="l01734"></a>01734 <span class="comment">//   virtual void SetUp() {</span>
<a name="l01735"></a>01735 <span class="comment">//     // Can use GetParam() here.</span>
<a name="l01736"></a>01736 <span class="comment">//   }</span>
<a name="l01737"></a>01737 <span class="comment">//   virtual void TearDown {</span>
<a name="l01738"></a>01738 <span class="comment">//     // Can use GetParam() here.</span>
<a name="l01739"></a>01739 <span class="comment">//   }</span>
<a name="l01740"></a>01740 <span class="comment">// };</span>
<a name="l01741"></a>01741 <span class="comment">// TEST_P(FooTest, DoesBar) {</span>
<a name="l01742"></a>01742 <span class="comment">//   // Can use GetParam() method here.</span>
<a name="l01743"></a>01743 <span class="comment">//   Foo foo;</span>
<a name="l01744"></a>01744 <span class="comment">//   ASSERT_TRUE(foo.DoesBar(GetParam()));</span>
<a name="l01745"></a>01745 <span class="comment">// }</span>
<a name="l01746"></a>01746 <span class="comment">// INSTANTIATE_TEST_CASE_P(OneToTenRange, FooTest, ::testing::Range(1, 10));</span>
<a name="l01747"></a>01747 
<a name="l01748"></a>01748 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01749"></a>01749 <span class="keyword">class </span>WithParamInterface {
<a name="l01750"></a>01750  <span class="keyword">public</span>:
<a name="l01751"></a>01751   <span class="keyword">typedef</span> T ParamType;
<a name="l01752"></a>01752   <span class="keyword">virtual</span> ~WithParamInterface() {}
<a name="l01753"></a>01753 
<a name="l01754"></a>01754   <span class="comment">// The current parameter value. Is also available in the test fixture&#39;s</span>
<a name="l01755"></a>01755   <span class="comment">// constructor. This member function is non-static, even though it only</span>
<a name="l01756"></a>01756   <span class="comment">// references static data, to reduce the opportunity for incorrect uses</span>
<a name="l01757"></a>01757   <span class="comment">// like writing &#39;WithParamInterface&lt;bool&gt;::GetParam()&#39; for a test that</span>
<a name="l01758"></a>01758   <span class="comment">// uses a fixture whose parameter type is int.</span>
<a name="l01759"></a>01759   <span class="keyword">const</span> ParamType&amp; GetParam()<span class="keyword"> const </span>{
<a name="l01760"></a>01760     <a class="code" href="gtest-port_8h.html#ab54343f0a36dc4cb0ce8a478dd7847b8">GTEST_CHECK_</a>(parameter_ != NULL)
<a name="l01761"></a>01761         &lt;&lt; <span class="stringliteral">&quot;GetParam() can only be called inside a value-parameterized test &quot;</span>
<a name="l01762"></a>01762         &lt;&lt; <span class="stringliteral">&quot;-- did you intend to write TEST_P instead of TEST_F?&quot;</span>;
<a name="l01763"></a>01763     <span class="keywordflow">return</span> *parameter_;
<a name="l01764"></a>01764   }
<a name="l01765"></a>01765 
<a name="l01766"></a>01766  <span class="keyword">private</span>:
<a name="l01767"></a>01767   <span class="comment">// Sets parameter value. The caller is responsible for making sure the value</span>
<a name="l01768"></a>01768   <span class="comment">// remains alive and unchanged throughout the current test.</span>
<a name="l01769"></a>01769   <span class="keyword">static</span> <span class="keywordtype">void</span> SetParam(<span class="keyword">const</span> ParamType* parameter) {
<a name="l01770"></a>01770     parameter_ = parameter;
<a name="l01771"></a>01771   }
<a name="l01772"></a>01772 
<a name="l01773"></a>01773   <span class="comment">// Static value used for accessing parameter during a test lifetime.</span>
<a name="l01774"></a>01774   <span class="keyword">static</span> <span class="keyword">const</span> ParamType* parameter_;
<a name="l01775"></a>01775 
<a name="l01776"></a>01776   <span class="comment">// TestClass must be a subclass of WithParamInterface&lt;T&gt; and Test.</span>
<a name="l01777"></a>01777   <span class="keyword">template</span> &lt;<span class="keyword">class</span> TestClass&gt; <span class="keyword">friend</span> <span class="keyword">class </span>internal::ParameterizedTestFactory;
<a name="l01778"></a>01778 };
<a name="l01779"></a>01779 
<a name="l01780"></a>01780 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01781"></a>01781 <span class="keyword">const</span> T* WithParamInterface&lt;T&gt;::parameter_ = NULL;
<a name="l01782"></a>01782 
<a name="l01783"></a>01783 <span class="comment">// Most value-parameterized classes can ignore the existence of</span>
<a name="l01784"></a>01784 <span class="comment">// WithParamInterface, and can just inherit from ::testing::TestWithParam.</span>
<a name="l01785"></a>01785 
<a name="l01786"></a>01786 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01787"></a>01787 <span class="keyword">class </span>TestWithParam : <span class="keyword">public</span> Test, <span class="keyword">public</span> WithParamInterface&lt;T&gt; {
<a name="l01788"></a>01788 };
<a name="l01789"></a>01789 
<a name="l01790"></a>01790 <span class="preprocessor">#endif  // GTEST_HAS_PARAM_TEST</span>
<a name="l01791"></a>01791 <span class="preprocessor"></span>
<a name="l01792"></a>01792 <span class="comment">// Macros for indicating success/failure in test code.</span>
<a name="l01793"></a>01793 
<a name="l01794"></a>01794 <span class="comment">// ADD_FAILURE unconditionally adds a failure to the current test.</span>
<a name="l01795"></a>01795 <span class="comment">// SUCCEED generates a success - it doesn&#39;t automatically make the</span>
<a name="l01796"></a>01796 <span class="comment">// current test successful, as a test is only successful when it has</span>
<a name="l01797"></a>01797 <span class="comment">// no failure.</span>
<a name="l01798"></a>01798 <span class="comment">//</span>
<a name="l01799"></a>01799 <span class="comment">// EXPECT_* verifies that a certain condition is satisfied.  If not,</span>
<a name="l01800"></a>01800 <span class="comment">// it behaves like ADD_FAILURE.  In particular:</span>
<a name="l01801"></a>01801 <span class="comment">//</span>
<a name="l01802"></a>01802 <span class="comment">//   EXPECT_TRUE  verifies that a Boolean condition is true.</span>
<a name="l01803"></a>01803 <span class="comment">//   EXPECT_FALSE verifies that a Boolean condition is false.</span>
<a name="l01804"></a>01804 <span class="comment">//</span>
<a name="l01805"></a>01805 <span class="comment">// FAIL and ASSERT_* are similar to ADD_FAILURE and EXPECT_*, except</span>
<a name="l01806"></a>01806 <span class="comment">// that they will also abort the current function on failure.  People</span>
<a name="l01807"></a>01807 <span class="comment">// usually want the fail-fast behavior of FAIL and ASSERT_*, but those</span>
<a name="l01808"></a>01808 <span class="comment">// writing data-driven tests often find themselves using ADD_FAILURE</span>
<a name="l01809"></a>01809 <span class="comment">// and EXPECT_* more.</span>
<a name="l01810"></a>01810 
<a name="l01811"></a>01811 <span class="comment">// Generates a nonfatal failure with a generic message.</span>
<a name="l01812"></a><a class="code" href="gtest_8h.html#adc16b5b0a740c39084ea5c9e960e3063">01812</a> <span class="preprocessor">#define ADD_FAILURE() GTEST_NONFATAL_FAILURE_(&quot;Failed&quot;)</span>
<a name="l01813"></a>01813 <span class="preprocessor"></span>
<a name="l01814"></a>01814 <span class="comment">// Generates a nonfatal failure at the given source file location with</span>
<a name="l01815"></a>01815 <span class="comment">// a generic message.</span>
<a name="l01816"></a><a class="code" href="gtest_8h.html#a448d7e5105b640e892fd8153fbee0b7f">01816</a> <span class="preprocessor">#define ADD_FAILURE_AT(file, line) \</span>
<a name="l01817"></a>01817 <span class="preprocessor">  GTEST_MESSAGE_AT_(file, line, &quot;Failed&quot;, \</span>
<a name="l01818"></a>01818 <span class="preprocessor">                    ::testing::TestPartResult::kNonFatalFailure)</span>
<a name="l01819"></a>01819 <span class="preprocessor"></span>
<a name="l01820"></a>01820 <span class="comment">// Generates a fatal failure with a generic message.</span>
<a name="l01821"></a><a class="code" href="gtest_8h.html#a636231436707c30d6778f79ae96f5dc6">01821</a> <span class="preprocessor">#define GTEST_FAIL() GTEST_FATAL_FAILURE_(&quot;Failed&quot;)</span>
<a name="l01822"></a>01822 <span class="preprocessor"></span>
<a name="l01823"></a>01823 <span class="comment">// Define this macro to 1 to omit the definition of FAIL(), which is a</span>
<a name="l01824"></a>01824 <span class="comment">// generic name and clashes with some other libraries.</span>
<a name="l01825"></a>01825 <span class="preprocessor">#if !GTEST_DONT_DEFINE_FAIL</span>
<a name="l01826"></a><a class="code" href="gtest_8h.html#a3e26a8d27caa386ed0ea7ce9d5b7c4ed">01826</a> <span class="preprocessor"></span><span class="preprocessor"># define FAIL() GTEST_FAIL()</span>
<a name="l01827"></a>01827 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01828"></a>01828 <span class="preprocessor"></span>
<a name="l01829"></a>01829 <span class="comment">// Generates a success with a generic message.</span>
<a name="l01830"></a><a class="code" href="gtest_8h.html#a2690441c38202728f4159ac2462d9720">01830</a> <span class="preprocessor">#define GTEST_SUCCEED() GTEST_SUCCESS_(&quot;Succeeded&quot;)</span>
<a name="l01831"></a>01831 <span class="preprocessor"></span>
<a name="l01832"></a>01832 <span class="comment">// Define this macro to 1 to omit the definition of SUCCEED(), which</span>
<a name="l01833"></a>01833 <span class="comment">// is a generic name and clashes with some other libraries.</span>
<a name="l01834"></a>01834 <span class="preprocessor">#if !GTEST_DONT_DEFINE_SUCCEED</span>
<a name="l01835"></a><a class="code" href="gtest_8h.html#a75adcdf89f69b0b615e395daafc315af">01835</a> <span class="preprocessor"></span><span class="preprocessor"># define SUCCEED() GTEST_SUCCEED()</span>
<a name="l01836"></a>01836 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01837"></a>01837 <span class="preprocessor"></span>
<a name="l01838"></a>01838 <span class="comment">// Macros for testing exceptions.</span>
<a name="l01839"></a>01839 <span class="comment">//</span>
<a name="l01840"></a>01840 <span class="comment">//    * {ASSERT|EXPECT}_THROW(statement, expected_exception):</span>
<a name="l01841"></a>01841 <span class="comment">//         Tests that the statement throws the expected exception.</span>
<a name="l01842"></a>01842 <span class="comment">//    * {ASSERT|EXPECT}_NO_THROW(statement):</span>
<a name="l01843"></a>01843 <span class="comment">//         Tests that the statement doesn&#39;t throw any exception.</span>
<a name="l01844"></a>01844 <span class="comment">//    * {ASSERT|EXPECT}_ANY_THROW(statement):</span>
<a name="l01845"></a>01845 <span class="comment">//         Tests that the statement throws an exception.</span>
<a name="l01846"></a>01846 
<a name="l01847"></a><a class="code" href="gtest_8h.html#a789842b4475eed948e6fd18390d5a859">01847</a> <span class="preprocessor">#define EXPECT_THROW(statement, expected_exception) \</span>
<a name="l01848"></a>01848 <span class="preprocessor">  GTEST_TEST_THROW_(statement, expected_exception, GTEST_NONFATAL_FAILURE_)</span>
<a name="l01849"></a><a class="code" href="gtest_8h.html#a2743a1438137ad857aa3f9fec3ff67ec">01849</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_NO_THROW(statement) \</span>
<a name="l01850"></a>01850 <span class="preprocessor">  GTEST_TEST_NO_THROW_(statement, GTEST_NONFATAL_FAILURE_)</span>
<a name="l01851"></a><a class="code" href="gtest_8h.html#a9be43f44d148e8a8d6a89c864bf4e461">01851</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_ANY_THROW(statement) \</span>
<a name="l01852"></a>01852 <span class="preprocessor">  GTEST_TEST_ANY_THROW_(statement, GTEST_NONFATAL_FAILURE_)</span>
<a name="l01853"></a><a class="code" href="gtest_8h.html#aedb1eddae6c2a2430b0e7b7e03b4f052">01853</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_THROW(statement, expected_exception) \</span>
<a name="l01854"></a>01854 <span class="preprocessor">  GTEST_TEST_THROW_(statement, expected_exception, GTEST_FATAL_FAILURE_)</span>
<a name="l01855"></a><a class="code" href="gtest_8h.html#a895c34d9b192cdc2ba46d2680623485d">01855</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_NO_THROW(statement) \</span>
<a name="l01856"></a>01856 <span class="preprocessor">  GTEST_TEST_NO_THROW_(statement, GTEST_FATAL_FAILURE_)</span>
<a name="l01857"></a><a class="code" href="gtest_8h.html#affadeef9379fe5aabf6f28d9eab9d3c0">01857</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_ANY_THROW(statement) \</span>
<a name="l01858"></a>01858 <span class="preprocessor">  GTEST_TEST_ANY_THROW_(statement, GTEST_FATAL_FAILURE_)</span>
<a name="l01859"></a>01859 <span class="preprocessor"></span>
<a name="l01860"></a>01860 <span class="comment">// Boolean assertions. Condition can be either a Boolean expression or an</span>
<a name="l01861"></a>01861 <span class="comment">// AssertionResult. For more information on how to use AssertionResult with</span>
<a name="l01862"></a>01862 <span class="comment">// these macros see comments on that class.</span>
<a name="l01863"></a><a class="code" href="gtest_8h.html#ac33e7cdfb5d44a7a0f0ab552eb5c3c6a">01863</a> <span class="preprocessor">#define EXPECT_TRUE(condition) \</span>
<a name="l01864"></a>01864 <span class="preprocessor">  GTEST_TEST_BOOLEAN_(condition, #condition, false, true, \</span>
<a name="l01865"></a>01865 <span class="preprocessor">                      GTEST_NONFATAL_FAILURE_)</span>
<a name="l01866"></a><a class="code" href="gtest_8h.html#aeb6c7ae89f440c90c1a1815951c836da">01866</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_FALSE(condition) \</span>
<a name="l01867"></a>01867 <span class="preprocessor">  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \</span>
<a name="l01868"></a>01868 <span class="preprocessor">                      GTEST_NONFATAL_FAILURE_)</span>
<a name="l01869"></a><a class="code" href="gtest_8h.html#ae9244bfbda562e8b798789b001993fa5">01869</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_TRUE(condition) \</span>
<a name="l01870"></a>01870 <span class="preprocessor">  GTEST_TEST_BOOLEAN_(condition, #condition, false, true, \</span>
<a name="l01871"></a>01871 <span class="preprocessor">                      GTEST_FATAL_FAILURE_)</span>
<a name="l01872"></a><a class="code" href="gtest_8h.html#a8197fa52f3538588d20d8af4834c9003">01872</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_FALSE(condition) \</span>
<a name="l01873"></a>01873 <span class="preprocessor">  GTEST_TEST_BOOLEAN_(!(condition), #condition, true, false, \</span>
<a name="l01874"></a>01874 <span class="preprocessor">                      GTEST_FATAL_FAILURE_)</span>
<a name="l01875"></a>01875 <span class="preprocessor"></span>
<a name="l01876"></a>01876 <span class="comment">// Includes the auto-generated header that implements a family of</span>
<a name="l01877"></a>01877 <span class="comment">// generic predicate assertion macros.</span>
<a name="l01878"></a>01878 <span class="preprocessor">#include &quot;<a class="code" href="gtest__pred__impl_8h.html">gtest/gtest_pred_impl.h</a>&quot;</span>
<a name="l01879"></a>01879 
<a name="l01880"></a>01880 <span class="comment">// Macros for testing equalities and inequalities.</span>
<a name="l01881"></a>01881 <span class="comment">//</span>
<a name="l01882"></a>01882 <span class="comment">//    * {ASSERT|EXPECT}_EQ(expected, actual): Tests that expected == actual</span>
<a name="l01883"></a>01883 <span class="comment">//    * {ASSERT|EXPECT}_NE(v1, v2):           Tests that v1 != v2</span>
<a name="l01884"></a>01884 <span class="comment">//    * {ASSERT|EXPECT}_LT(v1, v2):           Tests that v1 &lt; v2</span>
<a name="l01885"></a>01885 <span class="comment">//    * {ASSERT|EXPECT}_LE(v1, v2):           Tests that v1 &lt;= v2</span>
<a name="l01886"></a>01886 <span class="comment">//    * {ASSERT|EXPECT}_GT(v1, v2):           Tests that v1 &gt; v2</span>
<a name="l01887"></a>01887 <span class="comment">//    * {ASSERT|EXPECT}_GE(v1, v2):           Tests that v1 &gt;= v2</span>
<a name="l01888"></a>01888 <span class="comment">//</span>
<a name="l01889"></a>01889 <span class="comment">// When they are not, Google Test prints both the tested expressions and</span>
<a name="l01890"></a>01890 <span class="comment">// their actual values.  The values must be compatible built-in types,</span>
<a name="l01891"></a>01891 <span class="comment">// or you will get a compiler error.  By &quot;compatible&quot; we mean that the</span>
<a name="l01892"></a>01892 <span class="comment">// values can be compared by the respective operator.</span>
<a name="l01893"></a>01893 <span class="comment">//</span>
<a name="l01894"></a>01894 <span class="comment">// Note:</span>
<a name="l01895"></a>01895 <span class="comment">//</span>
<a name="l01896"></a>01896 <span class="comment">//   1. It is possible to make a user-defined type work with</span>
<a name="l01897"></a>01897 <span class="comment">//   {ASSERT|EXPECT}_??(), but that requires overloading the</span>
<a name="l01898"></a>01898 <span class="comment">//   comparison operators and is thus discouraged by the Google C++</span>
<a name="l01899"></a>01899 <span class="comment">//   Usage Guide.  Therefore, you are advised to use the</span>
<a name="l01900"></a>01900 <span class="comment">//   {ASSERT|EXPECT}_TRUE() macro to assert that two objects are</span>
<a name="l01901"></a>01901 <span class="comment">//   equal.</span>
<a name="l01902"></a>01902 <span class="comment">//</span>
<a name="l01903"></a>01903 <span class="comment">//   2. The {ASSERT|EXPECT}_??() macros do pointer comparisons on</span>
<a name="l01904"></a>01904 <span class="comment">//   pointers (in particular, C strings).  Therefore, if you use it</span>
<a name="l01905"></a>01905 <span class="comment">//   with two C strings, you are testing how their locations in memory</span>
<a name="l01906"></a>01906 <span class="comment">//   are related, not how their content is related.  To compare two C</span>
<a name="l01907"></a>01907 <span class="comment">//   strings by content, use {ASSERT|EXPECT}_STR*().</span>
<a name="l01908"></a>01908 <span class="comment">//</span>
<a name="l01909"></a>01909 <span class="comment">//   3. {ASSERT|EXPECT}_EQ(expected, actual) is preferred to</span>
<a name="l01910"></a>01910 <span class="comment">//   {ASSERT|EXPECT}_TRUE(expected == actual), as the former tells you</span>
<a name="l01911"></a>01911 <span class="comment">//   what the actual value is when it fails, and similarly for the</span>
<a name="l01912"></a>01912 <span class="comment">//   other comparisons.</span>
<a name="l01913"></a>01913 <span class="comment">//</span>
<a name="l01914"></a>01914 <span class="comment">//   4. Do not depend on the order in which {ASSERT|EXPECT}_??()</span>
<a name="l01915"></a>01915 <span class="comment">//   evaluate their arguments, which is undefined.</span>
<a name="l01916"></a>01916 <span class="comment">//</span>
<a name="l01917"></a>01917 <span class="comment">//   5. These macros evaluate their arguments exactly once.</span>
<a name="l01918"></a>01918 <span class="comment">//</span>
<a name="l01919"></a>01919 <span class="comment">// Examples:</span>
<a name="l01920"></a>01920 <span class="comment">//</span>
<a name="l01921"></a>01921 <span class="comment">//   EXPECT_NE(5, Foo());</span>
<a name="l01922"></a>01922 <span class="comment">//   EXPECT_EQ(NULL, a_pointer);</span>
<a name="l01923"></a>01923 <span class="comment">//   ASSERT_LT(i, array_size);</span>
<a name="l01924"></a>01924 <span class="comment">//   ASSERT_GT(records.size(), 0) &lt;&lt; &quot;There is no record left.&quot;;</span>
<a name="l01925"></a>01925 
<a name="l01926"></a><a class="code" href="gtest_8h.html#aff8385840165a184edc29446aa51936f">01926</a> <span class="preprocessor">#define EXPECT_EQ(expected, actual) \</span>
<a name="l01927"></a>01927 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal:: \</span>
<a name="l01928"></a>01928 <span class="preprocessor">                      EqHelper&lt;GTEST_IS_NULL_LITERAL_(expected)&gt;::Compare, \</span>
<a name="l01929"></a>01929 <span class="preprocessor">                      expected, actual)</span>
<a name="l01930"></a><a class="code" href="gtest_8h.html#adb8a724f2c5c63ead11073c21fd51198">01930</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_NE(expected, actual) \</span>
<a name="l01931"></a>01931 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperNE, expected, actual)</span>
<a name="l01932"></a><a class="code" href="gtest_8h.html#ae0f265632323b4a07b585dcfde10f60a">01932</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_LE(val1, val2) \</span>
<a name="l01933"></a>01933 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)</span>
<a name="l01934"></a><a class="code" href="gtest_8h.html#af28c06b2b5e8dee151896f299f6610cf">01934</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_LT(val1, val2) \</span>
<a name="l01935"></a>01935 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)</span>
<a name="l01936"></a><a class="code" href="gtest_8h.html#ab7a0ff4bfa4d9b27baa118d8b0756ca0">01936</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_GE(val1, val2) \</span>
<a name="l01937"></a>01937 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)</span>
<a name="l01938"></a><a class="code" href="gtest_8h.html#aa8bc8320813e1abb0016129b636e3b27">01938</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_GT(val1, val2) \</span>
<a name="l01939"></a>01939 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)</span>
<a name="l01940"></a>01940 <span class="preprocessor"></span>
<a name="l01941"></a><a class="code" href="gtest_8h.html#ab49d537c37c637256307f8d55154050c">01941</a> <span class="preprocessor">#define GTEST_ASSERT_EQ(expected, actual) \</span>
<a name="l01942"></a>01942 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal:: \</span>
<a name="l01943"></a>01943 <span class="preprocessor">                      EqHelper&lt;GTEST_IS_NULL_LITERAL_(expected)&gt;::Compare, \</span>
<a name="l01944"></a>01944 <span class="preprocessor">                      expected, actual)</span>
<a name="l01945"></a><a class="code" href="gtest_8h.html#a6fa9bb2b6731eba8f481e40e9e4931b3">01945</a> <span class="preprocessor"></span><span class="preprocessor">#define GTEST_ASSERT_NE(val1, val2) \</span>
<a name="l01946"></a>01946 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperNE, val1, val2)</span>
<a name="l01947"></a><a class="code" href="gtest_8h.html#abef04dcd4a0259d378de7b3b3ffb6730">01947</a> <span class="preprocessor"></span><span class="preprocessor">#define GTEST_ASSERT_LE(val1, val2) \</span>
<a name="l01948"></a>01948 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLE, val1, val2)</span>
<a name="l01949"></a><a class="code" href="gtest_8h.html#a5a75667e637febd18e5f7d4f3abf55e8">01949</a> <span class="preprocessor"></span><span class="preprocessor">#define GTEST_ASSERT_LT(val1, val2) \</span>
<a name="l01950"></a>01950 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperLT, val1, val2)</span>
<a name="l01951"></a><a class="code" href="gtest_8h.html#a55373d99c079ff1b894e2eb5bcd15c5a">01951</a> <span class="preprocessor"></span><span class="preprocessor">#define GTEST_ASSERT_GE(val1, val2) \</span>
<a name="l01952"></a>01952 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGE, val1, val2)</span>
<a name="l01953"></a><a class="code" href="gtest_8h.html#a088b9056fd1c1f316b41c22f64deb33a">01953</a> <span class="preprocessor"></span><span class="preprocessor">#define GTEST_ASSERT_GT(val1, val2) \</span>
<a name="l01954"></a>01954 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperGT, val1, val2)</span>
<a name="l01955"></a>01955 <span class="preprocessor"></span>
<a name="l01956"></a>01956 <span class="comment">// Define macro GTEST_DONT_DEFINE_ASSERT_XY to 1 to omit the definition of</span>
<a name="l01957"></a>01957 <span class="comment">// ASSERT_XY(), which clashes with some users&#39; own code.</span>
<a name="l01958"></a>01958 
<a name="l01959"></a>01959 <span class="preprocessor">#if !GTEST_DONT_DEFINE_ASSERT_EQ</span>
<a name="l01960"></a><a class="code" href="gtest_8h.html#a1a6db8b1338ee7040329322b77779086">01960</a> <span class="preprocessor"></span><span class="preprocessor"># define ASSERT_EQ(val1, val2) GTEST_ASSERT_EQ(val1, val2)</span>
<a name="l01961"></a>01961 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01962"></a>01962 <span class="preprocessor"></span>
<a name="l01963"></a>01963 <span class="preprocessor">#if !GTEST_DONT_DEFINE_ASSERT_NE</span>
<a name="l01964"></a><a class="code" href="gtest_8h.html#aa866c8dece57912e6f51495ed3e8d8d5">01964</a> <span class="preprocessor"></span><span class="preprocessor"># define ASSERT_NE(val1, val2) GTEST_ASSERT_NE(val1, val2)</span>
<a name="l01965"></a>01965 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01966"></a>01966 <span class="preprocessor"></span>
<a name="l01967"></a>01967 <span class="preprocessor">#if !GTEST_DONT_DEFINE_ASSERT_LE</span>
<a name="l01968"></a><a class="code" href="gtest_8h.html#a775643748feff0b490aae651d041e971">01968</a> <span class="preprocessor"></span><span class="preprocessor"># define ASSERT_LE(val1, val2) GTEST_ASSERT_LE(val1, val2)</span>
<a name="l01969"></a>01969 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01970"></a>01970 <span class="preprocessor"></span>
<a name="l01971"></a>01971 <span class="preprocessor">#if !GTEST_DONT_DEFINE_ASSERT_LT</span>
<a name="l01972"></a><a class="code" href="gtest_8h.html#affc4f9cae4c3aabfe60fced83737b42c">01972</a> <span class="preprocessor"></span><span class="preprocessor"># define ASSERT_LT(val1, val2) GTEST_ASSERT_LT(val1, val2)</span>
<a name="l01973"></a>01973 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01974"></a>01974 <span class="preprocessor"></span>
<a name="l01975"></a>01975 <span class="preprocessor">#if !GTEST_DONT_DEFINE_ASSERT_GE</span>
<a name="l01976"></a><a class="code" href="gtest_8h.html#af4ff5dc71479fcb374b6bc2ed195bcc4">01976</a> <span class="preprocessor"></span><span class="preprocessor"># define ASSERT_GE(val1, val2) GTEST_ASSERT_GE(val1, val2)</span>
<a name="l01977"></a>01977 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01978"></a>01978 <span class="preprocessor"></span>
<a name="l01979"></a>01979 <span class="preprocessor">#if !GTEST_DONT_DEFINE_ASSERT_GT</span>
<a name="l01980"></a><a class="code" href="gtest_8h.html#a16a882d4eafc9f8643867aea40879140">01980</a> <span class="preprocessor"></span><span class="preprocessor"># define ASSERT_GT(val1, val2) GTEST_ASSERT_GT(val1, val2)</span>
<a name="l01981"></a>01981 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l01982"></a>01982 <span class="preprocessor"></span>
<a name="l01983"></a>01983 <span class="comment">// C-string Comparisons.  All tests treat NULL and any non-NULL string</span>
<a name="l01984"></a>01984 <span class="comment">// as different.  Two NULLs are equal.</span>
<a name="l01985"></a>01985 <span class="comment">//</span>
<a name="l01986"></a>01986 <span class="comment">//    * {ASSERT|EXPECT}_STREQ(s1, s2):     Tests that s1 == s2</span>
<a name="l01987"></a>01987 <span class="comment">//    * {ASSERT|EXPECT}_STRNE(s1, s2):     Tests that s1 != s2</span>
<a name="l01988"></a>01988 <span class="comment">//    * {ASSERT|EXPECT}_STRCASEEQ(s1, s2): Tests that s1 == s2, ignoring case</span>
<a name="l01989"></a>01989 <span class="comment">//    * {ASSERT|EXPECT}_STRCASENE(s1, s2): Tests that s1 != s2, ignoring case</span>
<a name="l01990"></a>01990 <span class="comment">//</span>
<a name="l01991"></a>01991 <span class="comment">// For wide or narrow string objects, you can use the</span>
<a name="l01992"></a>01992 <span class="comment">// {ASSERT|EXPECT}_??() macros.</span>
<a name="l01993"></a>01993 <span class="comment">//</span>
<a name="l01994"></a>01994 <span class="comment">// Don&#39;t depend on the order in which the arguments are evaluated,</span>
<a name="l01995"></a>01995 <span class="comment">// which is undefined.</span>
<a name="l01996"></a>01996 <span class="comment">//</span>
<a name="l01997"></a>01997 <span class="comment">// These macros evaluate their arguments exactly once.</span>
<a name="l01998"></a>01998 
<a name="l01999"></a><a class="code" href="gtest_8h.html#a5b4b193a92c39b99d7b9404c49feef0b">01999</a> <span class="preprocessor">#define EXPECT_STREQ(expected, actual) \</span>
<a name="l02000"></a>02000 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, expected, actual)</span>
<a name="l02001"></a><a class="code" href="gtest_8h.html#aee7e9c42f55549dbc0dfc42391eb9775">02001</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_STRNE(s1, s2) \</span>
<a name="l02002"></a>02002 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)</span>
<a name="l02003"></a><a class="code" href="gtest_8h.html#acd0cb7ae81a768e9cc639804a478e71c">02003</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_STRCASEEQ(expected, actual) \</span>
<a name="l02004"></a>02004 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, expected, actual)</span>
<a name="l02005"></a><a class="code" href="gtest_8h.html#a07d0b5cbd3b5f7c8b6f44c609046ff07">02005</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_STRCASENE(s1, s2)\</span>
<a name="l02006"></a>02006 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)</span>
<a name="l02007"></a>02007 <span class="preprocessor"></span>
<a name="l02008"></a><a class="code" href="gtest_8h.html#a54e8edaad096ff704fedaa65a3e24f78">02008</a> <span class="preprocessor">#define ASSERT_STREQ(expected, actual) \</span>
<a name="l02009"></a>02009 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTREQ, expected, actual)</span>
<a name="l02010"></a><a class="code" href="gtest_8h.html#a3d679660ac1b2f9f6e6c7608452af923">02010</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_STRNE(s1, s2) \</span>
<a name="l02011"></a>02011 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRNE, s1, s2)</span>
<a name="l02012"></a><a class="code" href="gtest_8h.html#ad140c8b1f79ae534781784e580ab21a6">02012</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_STRCASEEQ(expected, actual) \</span>
<a name="l02013"></a>02013 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASEEQ, expected, actual)</span>
<a name="l02014"></a><a class="code" href="gtest_8h.html#ac3d2c3836b103068a050f32585b2aaad">02014</a> <span class="preprocessor"></span><span class="preprocessor">#define ASSERT_STRCASENE(s1, s2)\</span>
<a name="l02015"></a>02015 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperSTRCASENE, s1, s2)</span>
<a name="l02016"></a>02016 <span class="preprocessor"></span>
<a name="l02017"></a>02017 <span class="comment">// Macros for comparing floating-point numbers.</span>
<a name="l02018"></a>02018 <span class="comment">//</span>
<a name="l02019"></a>02019 <span class="comment">//    * {ASSERT|EXPECT}_FLOAT_EQ(expected, actual):</span>
<a name="l02020"></a>02020 <span class="comment">//         Tests that two float values are almost equal.</span>
<a name="l02021"></a>02021 <span class="comment">//    * {ASSERT|EXPECT}_DOUBLE_EQ(expected, actual):</span>
<a name="l02022"></a>02022 <span class="comment">//         Tests that two double values are almost equal.</span>
<a name="l02023"></a>02023 <span class="comment">//    * {ASSERT|EXPECT}_NEAR(v1, v2, abs_error):</span>
<a name="l02024"></a>02024 <span class="comment">//         Tests that v1 and v2 are within the given distance to each other.</span>
<a name="l02025"></a>02025 <span class="comment">//</span>
<a name="l02026"></a>02026 <span class="comment">// Google Test uses ULP-based comparison to automatically pick a default</span>
<a name="l02027"></a>02027 <span class="comment">// error bound that is appropriate for the operands.  See the</span>
<a name="l02028"></a>02028 <span class="comment">// FloatingPoint template class in gtest-internal.h if you are</span>
<a name="l02029"></a>02029 <span class="comment">// interested in the implementation details.</span>
<a name="l02030"></a>02030 
<a name="l02031"></a><a class="code" href="gtest_8h.html#a5ce7d58df8cb696aa05e77c2370de7a8">02031</a> <span class="preprocessor">#define EXPECT_FLOAT_EQ(expected, actual)\</span>
<a name="l02032"></a>02032 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;float&gt;, \</span>
<a name="l02033"></a>02033 <span class="preprocessor">                      expected, actual)</span>
<a name="l02034"></a>02034 <span class="preprocessor"></span>
<a name="l02035"></a><a class="code" href="gtest_8h.html#a6e6277442d96cd18300619c321614397">02035</a> <span class="preprocessor">#define EXPECT_DOUBLE_EQ(expected, actual)\</span>
<a name="l02036"></a>02036 <span class="preprocessor">  EXPECT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;double&gt;, \</span>
<a name="l02037"></a>02037 <span class="preprocessor">                      expected, actual)</span>
<a name="l02038"></a>02038 <span class="preprocessor"></span>
<a name="l02039"></a><a class="code" href="gtest_8h.html#a965b7b85a1c2d26981a1dfa48f67ebda">02039</a> <span class="preprocessor">#define ASSERT_FLOAT_EQ(expected, actual)\</span>
<a name="l02040"></a>02040 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;float&gt;, \</span>
<a name="l02041"></a>02041 <span class="preprocessor">                      expected, actual)</span>
<a name="l02042"></a>02042 <span class="preprocessor"></span>
<a name="l02043"></a><a class="code" href="gtest_8h.html#a360ed28a372738adca9ac2fa9522e562">02043</a> <span class="preprocessor">#define ASSERT_DOUBLE_EQ(expected, actual)\</span>
<a name="l02044"></a>02044 <span class="preprocessor">  ASSERT_PRED_FORMAT2(::testing::internal::CmpHelperFloatingPointEQ&lt;double&gt;, \</span>
<a name="l02045"></a>02045 <span class="preprocessor">                      expected, actual)</span>
<a name="l02046"></a>02046 <span class="preprocessor"></span>
<a name="l02047"></a><a class="code" href="gtest_8h.html#a88cd7978af0e7dbd42cd606dfabdcc6f">02047</a> <span class="preprocessor">#define EXPECT_NEAR(val1, val2, abs_error)\</span>
<a name="l02048"></a>02048 <span class="preprocessor">  EXPECT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \</span>
<a name="l02049"></a>02049 <span class="preprocessor">                      val1, val2, abs_error)</span>
<a name="l02050"></a>02050 <span class="preprocessor"></span>
<a name="l02051"></a><a class="code" href="gtest_8h.html#a73cce6b752d204f91a36bef2f8e663b3">02051</a> <span class="preprocessor">#define ASSERT_NEAR(val1, val2, abs_error)\</span>
<a name="l02052"></a>02052 <span class="preprocessor">  ASSERT_PRED_FORMAT3(::testing::internal::DoubleNearPredFormat, \</span>
<a name="l02053"></a>02053 <span class="preprocessor">                      val1, val2, abs_error)</span>
<a name="l02054"></a>02054 <span class="preprocessor"></span>
<a name="l02055"></a>02055 <span class="comment">// These predicate format functions work on floating-point values, and</span>
<a name="l02056"></a>02056 <span class="comment">// can be used in {ASSERT|EXPECT}_PRED_FORMAT2*(), e.g.</span>
<a name="l02057"></a>02057 <span class="comment">//</span>
<a name="l02058"></a>02058 <span class="comment">//   EXPECT_PRED_FORMAT2(testing::DoubleLE, Foo(), 5.0);</span>
<a name="l02059"></a>02059 
<a name="l02060"></a>02060 <span class="comment">// Asserts that val1 is less than, or almost equal to, val2.  Fails</span>
<a name="l02061"></a>02061 <span class="comment">// otherwise.  In particular, it fails if either val1 or val2 is NaN.</span>
<a name="l02062"></a>02062 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#a69106491c2e7f50e50da0ce5e8ae4374">FloatLE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr1, <span class="keyword">const</span> <span class="keywordtype">char</span>* expr2,
<a name="l02063"></a>02063                                    <span class="keywordtype">float</span> val1, <span class="keywordtype">float</span> val2);
<a name="l02064"></a>02064 <a class="code" href="gtest-port_8h.html#aa73be6f0ba4a7456180a94904ce17790">GTEST_API_</a> AssertionResult <a class="code" href="namespacetesting.html#a84c020b981d0eb4eabfb0feda155aaaf">DoubleLE</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* expr1, <span class="keyword">const</span> <span class="keywordtype">char</span>* expr2,
<a name="l02065"></a>02065                                     <span class="keywordtype">double</span> val1, <span class="keywordtype">double</span> val2);
<a name="l02066"></a>02066 
<a name="l02067"></a>02067 
<a name="l02068"></a>02068 <span class="preprocessor">#if GTEST_OS_WINDOWS</span>
<a name="l02069"></a>02069 <span class="preprocessor"></span>
<a name="l02070"></a>02070 <span class="comment">// Macros that test for HRESULT failure and success, these are only useful</span>
<a name="l02071"></a>02071 <span class="comment">// on Windows, and rely on Windows SDK macros and APIs to compile.</span>
<a name="l02072"></a>02072 <span class="comment">//</span>
<a name="l02073"></a>02073 <span class="comment">//    * {ASSERT|EXPECT}_HRESULT_{SUCCEEDED|FAILED}(expr)</span>
<a name="l02074"></a>02074 <span class="comment">//</span>
<a name="l02075"></a>02075 <span class="comment">// When expr unexpectedly fails or succeeds, Google Test prints the</span>
<a name="l02076"></a>02076 <span class="comment">// expected result and the actual result with both a human-readable</span>
<a name="l02077"></a>02077 <span class="comment">// string representation of the error, if available, as well as the</span>
<a name="l02078"></a>02078 <span class="comment">// hex result code.</span>
<a name="l02079"></a>02079 <span class="preprocessor"># define EXPECT_HRESULT_SUCCEEDED(expr) \</span>
<a name="l02080"></a>02080 <span class="preprocessor">    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))</span>
<a name="l02081"></a>02081 <span class="preprocessor"></span>
<a name="l02082"></a>02082 <span class="preprocessor"># define ASSERT_HRESULT_SUCCEEDED(expr) \</span>
<a name="l02083"></a>02083 <span class="preprocessor">    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTSuccess, (expr))</span>
<a name="l02084"></a>02084 <span class="preprocessor"></span>
<a name="l02085"></a>02085 <span class="preprocessor"># define EXPECT_HRESULT_FAILED(expr) \</span>
<a name="l02086"></a>02086 <span class="preprocessor">    EXPECT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))</span>
<a name="l02087"></a>02087 <span class="preprocessor"></span>
<a name="l02088"></a>02088 <span class="preprocessor"># define ASSERT_HRESULT_FAILED(expr) \</span>
<a name="l02089"></a>02089 <span class="preprocessor">    ASSERT_PRED_FORMAT1(::testing::internal::IsHRESULTFailure, (expr))</span>
<a name="l02090"></a>02090 <span class="preprocessor"></span>
<a name="l02091"></a>02091 <span class="preprocessor">#endif  // GTEST_OS_WINDOWS</span>
<a name="l02092"></a>02092 <span class="preprocessor"></span>
<a name="l02093"></a>02093 <span class="comment">// Macros that execute statement and check that it doesn&#39;t generate new fatal</span>
<a name="l02094"></a>02094 <span class="comment">// failures in the current thread.</span>
<a name="l02095"></a>02095 <span class="comment">//</span>
<a name="l02096"></a>02096 <span class="comment">//   * {ASSERT|EXPECT}_NO_FATAL_FAILURE(statement);</span>
<a name="l02097"></a>02097 <span class="comment">//</span>
<a name="l02098"></a>02098 <span class="comment">// Examples:</span>
<a name="l02099"></a>02099 <span class="comment">//</span>
<a name="l02100"></a>02100 <span class="comment">//   EXPECT_NO_FATAL_FAILURE(Process());</span>
<a name="l02101"></a>02101 <span class="comment">//   ASSERT_NO_FATAL_FAILURE(Process()) &lt;&lt; &quot;Process() failed&quot;;</span>
<a name="l02102"></a>02102 <span class="comment">//</span>
<a name="l02103"></a><a class="code" href="gtest_8h.html#a5034fda3490aad5a93942ac83f4cea49">02103</a> <span class="preprocessor">#define ASSERT_NO_FATAL_FAILURE(statement) \</span>
<a name="l02104"></a>02104 <span class="preprocessor">    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_FATAL_FAILURE_)</span>
<a name="l02105"></a><a class="code" href="gtest_8h.html#a067c02ccaf3171d6e1781cd0f8cdcf74">02105</a> <span class="preprocessor"></span><span class="preprocessor">#define EXPECT_NO_FATAL_FAILURE(statement) \</span>
<a name="l02106"></a>02106 <span class="preprocessor">    GTEST_TEST_NO_FATAL_FAILURE_(statement, GTEST_NONFATAL_FAILURE_)</span>
<a name="l02107"></a>02107 <span class="preprocessor"></span>
<a name="l02108"></a>02108 <span class="comment">// Causes a trace (including the source file path, the current line</span>
<a name="l02109"></a>02109 <span class="comment">// number, and the given message) to be included in every test failure</span>
<a name="l02110"></a>02110 <span class="comment">// message generated by code in the current scope.  The effect is</span>
<a name="l02111"></a>02111 <span class="comment">// undone when the control leaves the current scope.</span>
<a name="l02112"></a>02112 <span class="comment">//</span>
<a name="l02113"></a>02113 <span class="comment">// The message argument can be anything streamable to std::ostream.</span>
<a name="l02114"></a>02114 <span class="comment">//</span>
<a name="l02115"></a>02115 <span class="comment">// In the implementation, we include the current line number as part</span>
<a name="l02116"></a>02116 <span class="comment">// of the dummy variable name, thus allowing multiple SCOPED_TRACE()s</span>
<a name="l02117"></a>02117 <span class="comment">// to appear in the same block - as long as they are on different</span>
<a name="l02118"></a>02118 <span class="comment">// lines.</span>
<a name="l02119"></a><a class="code" href="gtest_8h.html#a4dac08f15adc8cb1ee0e5c1bfb0f440d">02119</a> <span class="preprocessor">#define SCOPED_TRACE(message) \</span>
<a name="l02120"></a>02120 <span class="preprocessor">  ::testing::internal::ScopedTrace GTEST_CONCAT_TOKEN_(gtest_trace_, __LINE__)(\</span>
<a name="l02121"></a>02121 <span class="preprocessor">    __FILE__, __LINE__, ::testing::Message() &lt;&lt; (message))</span>
<a name="l02122"></a>02122 <span class="preprocessor"></span>
<a name="l02123"></a>02123 <span class="comment">// Compile-time assertion for type equality.</span>
<a name="l02124"></a>02124 <span class="comment">// StaticAssertTypeEq&lt;type1, type2&gt;() compiles iff type1 and type2 are</span>
<a name="l02125"></a>02125 <span class="comment">// the same type.  The value it returns is not interesting.</span>
<a name="l02126"></a>02126 <span class="comment">//</span>
<a name="l02127"></a>02127 <span class="comment">// Instead of making StaticAssertTypeEq a class template, we make it a</span>
<a name="l02128"></a>02128 <span class="comment">// function template that invokes a helper class template.  This</span>
<a name="l02129"></a>02129 <span class="comment">// prevents a user from misusing StaticAssertTypeEq&lt;T1, T2&gt; by</span>
<a name="l02130"></a>02130 <span class="comment">// defining objects of that type.</span>
<a name="l02131"></a>02131 <span class="comment">//</span>
<a name="l02132"></a>02132 <span class="comment">// CAVEAT:</span>
<a name="l02133"></a>02133 <span class="comment">//</span>
<a name="l02134"></a>02134 <span class="comment">// When used inside a method of a class template,</span>
<a name="l02135"></a>02135 <span class="comment">// StaticAssertTypeEq&lt;T1, T2&gt;() is effective ONLY IF the method is</span>
<a name="l02136"></a>02136 <span class="comment">// instantiated.  For example, given:</span>
<a name="l02137"></a>02137 <span class="comment">//</span>
<a name="l02138"></a>02138 <span class="comment">//   template &lt;typename T&gt; class Foo {</span>
<a name="l02139"></a>02139 <span class="comment">//    public:</span>
<a name="l02140"></a>02140 <span class="comment">//     void Bar() { testing::StaticAssertTypeEq&lt;int, T&gt;(); }</span>
<a name="l02141"></a>02141 <span class="comment">//   };</span>
<a name="l02142"></a>02142 <span class="comment">//</span>
<a name="l02143"></a>02143 <span class="comment">// the code:</span>
<a name="l02144"></a>02144 <span class="comment">//</span>
<a name="l02145"></a>02145 <span class="comment">//   void Test1() { Foo&lt;bool&gt; foo; }</span>
<a name="l02146"></a>02146 <span class="comment">//</span>
<a name="l02147"></a>02147 <span class="comment">// will NOT generate a compiler error, as Foo&lt;bool&gt;::Bar() is never</span>
<a name="l02148"></a>02148 <span class="comment">// actually instantiated.  Instead, you need:</span>
<a name="l02149"></a>02149 <span class="comment">//</span>
<a name="l02150"></a>02150 <span class="comment">//   void Test2() { Foo&lt;bool&gt; foo; foo.Bar(); }</span>
<a name="l02151"></a>02151 <span class="comment">//</span>
<a name="l02152"></a>02152 <span class="comment">// to cause a compiler error.</span>
<a name="l02153"></a>02153 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l02154"></a><a class="code" href="namespacetesting.html#a661e70fc6afeb5c085eed3716aa45059">02154</a> <span class="keywordtype">bool</span> <a class="code" href="namespacetesting.html#a661e70fc6afeb5c085eed3716aa45059">StaticAssertTypeEq</a>() {
<a name="l02155"></a>02155   (void)internal::StaticAssertTypeEqHelper&lt;T1, T2&gt;();
<a name="l02156"></a>02156   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l02157"></a>02157 }
<a name="l02158"></a>02158 
<a name="l02159"></a>02159 <span class="comment">// Defines a test.</span>
<a name="l02160"></a>02160 <span class="comment">//</span>
<a name="l02161"></a>02161 <span class="comment">// The first parameter is the name of the test case, and the second</span>
<a name="l02162"></a>02162 <span class="comment">// parameter is the name of the test within the test case.</span>
<a name="l02163"></a>02163 <span class="comment">//</span>
<a name="l02164"></a>02164 <span class="comment">// The convention is to end the test case name with &quot;Test&quot;.  For</span>
<a name="l02165"></a>02165 <span class="comment">// example, a test case for the Foo class can be named FooTest.</span>
<a name="l02166"></a>02166 <span class="comment">//</span>
<a name="l02167"></a>02167 <span class="comment">// Test code should appear between braces after an invocation of</span>
<a name="l02168"></a>02168 <span class="comment">// this macro.  Example:</span>
<a name="l02169"></a>02169 <span class="comment">//</span>
<a name="l02170"></a>02170 <span class="comment">//   TEST(FooTest, InitializesCorrectly) {</span>
<a name="l02171"></a>02171 <span class="comment">//     Foo foo;</span>
<a name="l02172"></a>02172 <span class="comment">//     EXPECT_TRUE(foo.StatusIsOK());</span>
<a name="l02173"></a>02173 <span class="comment">//   }</span>
<a name="l02174"></a>02174 
<a name="l02175"></a>02175 <span class="comment">// Note that we call GetTestTypeId() instead of GetTypeId&lt;</span>
<a name="l02176"></a>02176 <span class="comment">// ::testing::Test&gt;() here to get the type ID of testing::Test.  This</span>
<a name="l02177"></a>02177 <span class="comment">// is to work around a suspected linker bug when using Google Test as</span>
<a name="l02178"></a>02178 <span class="comment">// a framework on Mac OS X.  The bug causes GetTypeId&lt;</span>
<a name="l02179"></a>02179 <span class="comment">// ::testing::Test&gt;() to return different values depending on whether</span>
<a name="l02180"></a>02180 <span class="comment">// the call is from the Google Test framework itself or from user test</span>
<a name="l02181"></a>02181 <span class="comment">// code.  GetTestTypeId() is guaranteed to always return the same</span>
<a name="l02182"></a>02182 <span class="comment">// value, as it always calls GetTypeId&lt;&gt;() from the Google Test</span>
<a name="l02183"></a>02183 <span class="comment">// framework.</span>
<a name="l02184"></a><a class="code" href="gtest_8h.html#a725b565bedc3a34dc109901854214cc4">02184</a> <span class="preprocessor">#define GTEST_TEST(test_case_name, test_name)\</span>
<a name="l02185"></a>02185 <span class="preprocessor">  GTEST_TEST_(test_case_name, test_name, \</span>
<a name="l02186"></a>02186 <span class="preprocessor">              ::testing::Test, ::testing::internal::GetTestTypeId())</span>
<a name="l02187"></a>02187 <span class="preprocessor"></span>
<a name="l02188"></a>02188 <span class="comment">// Define this macro to 1 to omit the definition of TEST(), which</span>
<a name="l02189"></a>02189 <span class="comment">// is a generic name and clashes with some other libraries.</span>
<a name="l02190"></a>02190 <span class="preprocessor">#if !GTEST_DONT_DEFINE_TEST</span>
<a name="l02191"></a><a class="code" href="gtest_8h.html#ad8b332753515c0ab8baada563c2547eb">02191</a> <span class="preprocessor"></span><span class="preprocessor"># define TEST(test_case_name, test_name) GTEST_TEST(test_case_name, test_name)</span>
<a name="l02192"></a>02192 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
<a name="l02193"></a>02193 <span class="preprocessor"></span>
<a name="l02194"></a>02194 <span class="comment">// Defines a test that uses a test fixture.</span>
<a name="l02195"></a>02195 <span class="comment">//</span>
<a name="l02196"></a>02196 <span class="comment">// The first parameter is the name of the test fixture class, which</span>
<a name="l02197"></a>02197 <span class="comment">// also doubles as the test case name.  The second parameter is the</span>
<a name="l02198"></a>02198 <span class="comment">// name of the test within the test case.</span>
<a name="l02199"></a>02199 <span class="comment">//</span>
<a name="l02200"></a>02200 <span class="comment">// A test fixture class must be declared earlier.  The user should put</span>
<a name="l02201"></a>02201 <span class="comment">// his test code between braces after using this macro.  Example:</span>
<a name="l02202"></a>02202 <span class="comment">//</span>
<a name="l02203"></a>02203 <span class="comment">//   class FooTest : public testing::Test {</span>
<a name="l02204"></a>02204 <span class="comment">//    protected:</span>
<a name="l02205"></a>02205 <span class="comment">//     virtual void SetUp() { b_.AddElement(3); }</span>
<a name="l02206"></a>02206 <span class="comment">//</span>
<a name="l02207"></a>02207 <span class="comment">//     Foo a_;</span>
<a name="l02208"></a>02208 <span class="comment">//     Foo b_;</span>
<a name="l02209"></a>02209 <span class="comment">//   };</span>
<a name="l02210"></a>02210 <span class="comment">//</span>
<a name="l02211"></a>02211 <span class="comment">//   TEST_F(FooTest, InitializesCorrectly) {</span>
<a name="l02212"></a>02212 <span class="comment">//     EXPECT_TRUE(a_.StatusIsOK());</span>
<a name="l02213"></a>02213 <span class="comment">//   }</span>
<a name="l02214"></a>02214 <span class="comment">//</span>
<a name="l02215"></a>02215 <span class="comment">//   TEST_F(FooTest, ReturnsElementCountCorrectly) {</span>
<a name="l02216"></a>02216 <span class="comment">//     EXPECT_EQ(0, a_.size());</span>
<a name="l02217"></a>02217 <span class="comment">//     EXPECT_EQ(1, b_.size());</span>
<a name="l02218"></a>02218 <span class="comment">//   }</span>
<a name="l02219"></a>02219 
<a name="l02220"></a><a class="code" href="gtest_8h.html#a0ee66d464d1a06c20c1929cae09d8758">02220</a> <span class="preprocessor">#define TEST_F(test_fixture, test_name)\</span>
<a name="l02221"></a>02221 <span class="preprocessor">  GTEST_TEST_(test_fixture, test_name, test_fixture, \</span>
<a name="l02222"></a>02222 <span class="preprocessor">              ::testing::internal::GetTypeId&lt;test_fixture&gt;())</span>
<a name="l02223"></a>02223 <span class="preprocessor"></span>
<a name="l02224"></a>02224 }  <span class="comment">// namespace testing</span>
<a name="l02225"></a>02225 
<a name="l02226"></a>02226 <span class="comment">// Use this function in main() to run all tests.  It returns 0 if all</span>
<a name="l02227"></a>02227 <span class="comment">// tests are successful, or 1 otherwise.</span>
<a name="l02228"></a>02228 <span class="comment">//</span>
<a name="l02229"></a>02229 <span class="comment">// RUN_ALL_TESTS() should be invoked after the command line has been</span>
<a name="l02230"></a>02230 <span class="comment">// parsed by InitGoogleTest().</span>
<a name="l02231"></a>02231 <span class="comment">//</span>
<a name="l02232"></a>02232 <span class="comment">// This function was formerly a macro; thus, it is in the global</span>
<a name="l02233"></a>02233 <span class="comment">// namespace and has an all-caps name.</span>
<a name="l02234"></a>02234 <span class="keywordtype">int</span> <a class="code" href="gtest_8h.html#a853a3792807489591d3d4a2f2ff9359f">RUN_ALL_TESTS</a>() <a class="code" href="gtest-port_8h.html#a8e5aab8276b2645f64f41c9e3021b935">GTEST_MUST_USE_RESULT_</a>;
<a name="l02235"></a>02235 
<a name="l02236"></a><a class="code" href="gtest_8h.html#a853a3792807489591d3d4a2f2ff9359f">02236</a> inline <span class="keywordtype">int</span> <a class="code" href="gtest_8h.html#a853a3792807489591d3d4a2f2ff9359f">RUN_ALL_TESTS</a>() {
<a name="l02237"></a>02237   return ::testing::UnitTest::GetInstance()-&gt;Run();
<a name="l02238"></a>02238 }
<a name="l02239"></a>02239 
<a name="l02240"></a>02240 <span class="preprocessor">#endif  // GTEST_INCLUDE_GTEST_GTEST_H_</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 6 2015 20:59:13 for ZNC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
