<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ZNC: gmock-actions.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ZNC
   &#160;<span id="projectnumber">trunk</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">gmock-actions.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="gmock-actions_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Copyright 2007, Google Inc.</span>
<a name="l00002"></a>00002 <span class="comment">// All rights reserved.</span>
<a name="l00003"></a>00003 <span class="comment">//</span>
<a name="l00004"></a>00004 <span class="comment">// Redistribution and use in source and binary forms, with or without</span>
<a name="l00005"></a>00005 <span class="comment">// modification, are permitted provided that the following conditions are</span>
<a name="l00006"></a>00006 <span class="comment">// met:</span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment">//     * Redistributions of source code must retain the above copyright</span>
<a name="l00009"></a>00009 <span class="comment">// notice, this list of conditions and the following disclaimer.</span>
<a name="l00010"></a>00010 <span class="comment">//     * Redistributions in binary form must reproduce the above</span>
<a name="l00011"></a>00011 <span class="comment">// copyright notice, this list of conditions and the following disclaimer</span>
<a name="l00012"></a>00012 <span class="comment">// in the documentation and/or other materials provided with the</span>
<a name="l00013"></a>00013 <span class="comment">// distribution.</span>
<a name="l00014"></a>00014 <span class="comment">//     * Neither the name of Google Inc. nor the names of its</span>
<a name="l00015"></a>00015 <span class="comment">// contributors may be used to endorse or promote products derived from</span>
<a name="l00016"></a>00016 <span class="comment">// this software without specific prior written permission.</span>
<a name="l00017"></a>00017 <span class="comment">//</span>
<a name="l00018"></a>00018 <span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00019"></a>00019 <span class="comment">// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00020"></a>00020 <span class="comment">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00021"></a>00021 <span class="comment">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00022"></a>00022 <span class="comment">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00023"></a>00023 <span class="comment">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00024"></a>00024 <span class="comment">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00025"></a>00025 <span class="comment">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00026"></a>00026 <span class="comment">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00027"></a>00027 <span class="comment">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<a name="l00028"></a>00028 <span class="comment">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00029"></a>00029 <span class="comment">//</span>
<a name="l00030"></a>00030 <span class="comment">// Author: wan@google.com (Zhanyong Wan)</span>
<a name="l00031"></a>00031 
<a name="l00032"></a>00032 <span class="comment">// Google Mock - a framework for writing C++ mock classes.</span>
<a name="l00033"></a>00033 <span class="comment">//</span>
<a name="l00034"></a>00034 <span class="comment">// This file implements some commonly used actions.</span>
<a name="l00035"></a>00035 
<a name="l00036"></a>00036 <span class="preprocessor">#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_</span>
<a name="l00037"></a>00037 <span class="preprocessor"></span><span class="preprocessor">#define GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_</span>
<a name="l00038"></a>00038 <span class="preprocessor"></span>
<a name="l00039"></a>00039 <span class="preprocessor">#ifndef _WIN32_WCE</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span><span class="preprocessor"># include &lt;errno.h&gt;</span>
<a name="l00041"></a>00041 <span class="preprocessor">#endif</span>
<a name="l00042"></a>00042 <span class="preprocessor"></span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;algorithm&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00045"></a>00045 
<a name="l00046"></a>00046 <span class="preprocessor">#include &quot;<a class="code" href="gmock-internal-utils_8h.html">gmock/internal/gmock-internal-utils.h</a>&quot;</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include &quot;<a class="code" href="gmock-port_8h.html">gmock/internal/gmock-port.h</a>&quot;</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <span class="preprocessor">#if GTEST_LANG_CXX11  // Defined by gtest-port.h via gmock-port.h.</span>
<a name="l00050"></a>00050 <span class="preprocessor"></span><span class="preprocessor">#include &lt;type_traits&gt;</span>
<a name="l00051"></a>00051 <span class="preprocessor">#endif</span>
<a name="l00052"></a>00052 <span class="preprocessor"></span>
<a name="l00053"></a><a class="code" href="namespacetesting.html">00053</a> <span class="keyword">namespace </span>testing {
<a name="l00054"></a>00054 
<a name="l00055"></a>00055 <span class="comment">// To implement an action Foo, define:</span>
<a name="l00056"></a>00056 <span class="comment">//   1. a class FooAction that implements the ActionInterface interface, and</span>
<a name="l00057"></a>00057 <span class="comment">//   2. a factory function that creates an Action object from a</span>
<a name="l00058"></a>00058 <span class="comment">//      const FooAction*.</span>
<a name="l00059"></a>00059 <span class="comment">//</span>
<a name="l00060"></a>00060 <span class="comment">// The two-level delegation design follows that of Matcher, providing</span>
<a name="l00061"></a>00061 <span class="comment">// consistency for extension developers.  It also eases ownership</span>
<a name="l00062"></a>00062 <span class="comment">// management as Action objects can now be copied like plain values.</span>
<a name="l00063"></a>00063 
<a name="l00064"></a><a class="code" href="namespacetesting_1_1internal.html">00064</a> <span class="keyword">namespace </span>internal {
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2&gt;
<a name="l00067"></a>00067 <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html">ActionAdaptor</a>;
<a name="l00068"></a>00068 
<a name="l00069"></a>00069 <span class="comment">// BuiltInDefaultValueGetter&lt;T, true&gt;::Get() returns a</span>
<a name="l00070"></a>00070 <span class="comment">// default-constructed T value.  BuiltInDefaultValueGetter&lt;T,</span>
<a name="l00071"></a>00071 <span class="comment">// false&gt;::Get() crashes with an error.</span>
<a name="l00072"></a>00072 <span class="comment">//</span>
<a name="l00073"></a>00073 <span class="comment">// This primary template is used when kDefaultConstructible is true.</span>
<a name="l00074"></a>00074 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keywordtype">bool</span> kDefaultConstructible&gt;
<a name="l00075"></a><a class="code" href="structtesting_1_1internal_1_1BuiltInDefaultValueGetter.html">00075</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1BuiltInDefaultValueGetter.html">BuiltInDefaultValueGetter</a> {
<a name="l00076"></a><a class="code" href="structtesting_1_1internal_1_1BuiltInDefaultValueGetter.html#a61c47c50cdb6ab488dabe2cec3b97fc8">00076</a>   <span class="keyword">static</span> T <a class="code" href="structtesting_1_1internal_1_1BuiltInDefaultValueGetter.html#a61c47c50cdb6ab488dabe2cec3b97fc8">Get</a>() { <span class="keywordflow">return</span> T(); }
<a name="l00077"></a>00077 };
<a name="l00078"></a>00078 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00079"></a><a class="code" href="structtesting_1_1internal_1_1BuiltInDefaultValueGetter_3_01T_00_01false_01_4.html">00079</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1BuiltInDefaultValueGetter.html">BuiltInDefaultValueGetter</a>&lt;T, false&gt; {
<a name="l00080"></a><a class="code" href="structtesting_1_1internal_1_1BuiltInDefaultValueGetter_3_01T_00_01false_01_4.html#a8c8e929666f61272961eea21a60de4ad">00080</a>   <span class="keyword">static</span> T <a class="code" href="structtesting_1_1internal_1_1BuiltInDefaultValueGetter_3_01T_00_01false_01_4.html#a8c8e929666f61272961eea21a60de4ad">Get</a>() {
<a name="l00081"></a>00081     <a class="code" href="namespacetesting_1_1internal.html#a7a259643b7f2d23ce2b757728df42c99">Assert</a>(<span class="keyword">false</span>, __FILE__, __LINE__,
<a name="l00082"></a>00082            <span class="stringliteral">&quot;Default action undefined for the function return type.&quot;</span>);
<a name="l00083"></a>00083     <span class="keywordflow">return</span> internal::Invalid&lt;T&gt;();
<a name="l00084"></a>00084     <span class="comment">// The above statement will never be reached, but is required in</span>
<a name="l00085"></a>00085     <span class="comment">// order for this function to compile.</span>
<a name="l00086"></a>00086   }
<a name="l00087"></a>00087 };
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="comment">// BuiltInDefaultValue&lt;T&gt;::Get() returns the &quot;built-in&quot; default value</span>
<a name="l00090"></a>00090 <span class="comment">// for type T, which is NULL when T is a raw pointer type, 0 when T is</span>
<a name="l00091"></a>00091 <span class="comment">// a numeric type, false when T is bool, or &quot;&quot; when T is string or</span>
<a name="l00092"></a>00092 <span class="comment">// std::string.  In addition, in C++11 and above, it turns a</span>
<a name="l00093"></a>00093 <span class="comment">// default-constructed T value if T is default constructible.  For any</span>
<a name="l00094"></a>00094 <span class="comment">// other type T, the built-in default T value is undefined, and the</span>
<a name="l00095"></a>00095 <span class="comment">// function will abort the process.</span>
<a name="l00096"></a>00096 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00097"></a><a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html">00097</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html">BuiltInDefaultValue</a> {
<a name="l00098"></a>00098  <span class="keyword">public</span>:
<a name="l00099"></a>00099 <span class="preprocessor">#if GTEST_LANG_CXX11</span>
<a name="l00100"></a>00100 <span class="preprocessor"></span>  <span class="comment">// This function returns true iff type T has a built-in default value.</span>
<a name="l00101"></a>00101   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html#a35207bc20a493b0efb3980eb9a08dd2f">Exists</a>() {
<a name="l00102"></a>00102     return ::std::is_default_constructible&lt;T&gt;::value;
<a name="l00103"></a>00103   }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105   <span class="keyword">static</span> T <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html#a7e26c1df14a887c8f393b29d6ea162e6">Get</a>() {
<a name="l00106"></a>00106     <span class="keywordflow">return</span> <a class="code" href="structtesting_1_1internal_1_1BuiltInDefaultValueGetter.html">BuiltInDefaultValueGetter</a>&lt;
<a name="l00107"></a>00107         T, ::std::is_default_constructible&lt;T&gt;::value&gt;<a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html#a7e26c1df14a887c8f393b29d6ea162e6">::Get</a>();
<a name="l00108"></a>00108   }
<a name="l00109"></a>00109 
<a name="l00110"></a>00110 <span class="preprocessor">#else  // GTEST_LANG_CXX11</span>
<a name="l00111"></a>00111 <span class="preprocessor"></span>  <span class="comment">// This function returns true iff type T has a built-in default value.</span>
<a name="l00112"></a><a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html#a35207bc20a493b0efb3980eb9a08dd2f">00112</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html#a35207bc20a493b0efb3980eb9a08dd2f">Exists</a>() {
<a name="l00113"></a>00113     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00114"></a>00114   }
<a name="l00115"></a>00115 
<a name="l00116"></a><a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html#a7e26c1df14a887c8f393b29d6ea162e6">00116</a>   <span class="keyword">static</span> T <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html#a7e26c1df14a887c8f393b29d6ea162e6">Get</a>() {
<a name="l00117"></a>00117     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html#a7e26c1df14a887c8f393b29d6ea162e6">BuiltInDefaultValueGetter&lt;T, false&gt;::Get</a>();
<a name="l00118"></a>00118   }
<a name="l00119"></a>00119 
<a name="l00120"></a>00120 <span class="preprocessor">#endif  // GTEST_LANG_CXX11</span>
<a name="l00121"></a>00121 <span class="preprocessor"></span>};
<a name="l00122"></a>00122 
<a name="l00123"></a>00123 <span class="comment">// This partial specialization says that we use the same built-in</span>
<a name="l00124"></a>00124 <span class="comment">// default value for T and const T.</span>
<a name="l00125"></a>00125 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00126"></a><a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue_3_01const_01T_01_4.html">00126</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html">BuiltInDefaultValue</a>&lt;const T&gt; {
<a name="l00127"></a>00127  <span class="keyword">public</span>:
<a name="l00128"></a><a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue_3_01const_01T_01_4.html#a1814803ec5dcc660ee1f1092a96b79fa">00128</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue_3_01const_01T_01_4.html#a1814803ec5dcc660ee1f1092a96b79fa">Exists</a>() { <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html#a35207bc20a493b0efb3980eb9a08dd2f">BuiltInDefaultValue&lt;T&gt;::Exists</a>(); }
<a name="l00129"></a><a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue_3_01const_01T_01_4.html#a5996754952ecbcc5da77a2cebd4722de">00129</a>   <span class="keyword">static</span> T <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue_3_01const_01T_01_4.html#a5996754952ecbcc5da77a2cebd4722de">Get</a>() { <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html#a7e26c1df14a887c8f393b29d6ea162e6">BuiltInDefaultValue&lt;T&gt;::Get</a>(); }
<a name="l00130"></a>00130 };
<a name="l00131"></a>00131 
<a name="l00132"></a>00132 <span class="comment">// This partial specialization defines the default values for pointer</span>
<a name="l00133"></a>00133 <span class="comment">// types.</span>
<a name="l00134"></a>00134 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00135"></a><a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue_3_01T_01_5_01_4.html">00135</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html">BuiltInDefaultValue</a>&lt;T*&gt; {
<a name="l00136"></a>00136  <span class="keyword">public</span>:
<a name="l00137"></a><a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue_3_01T_01_5_01_4.html#aafa7172f63d068305fb37d5db40bb543">00137</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue_3_01T_01_5_01_4.html#aafa7172f63d068305fb37d5db40bb543">Exists</a>() { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00138"></a><a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue_3_01T_01_5_01_4.html#adc2fa2bdae767589d171ae3a117e3a9f">00138</a>   <span class="keyword">static</span> T* <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue_3_01T_01_5_01_4.html#adc2fa2bdae767589d171ae3a117e3a9f">Get</a>() { <span class="keywordflow">return</span> NULL; }
<a name="l00139"></a>00139 };
<a name="l00140"></a>00140 
<a name="l00141"></a>00141 <span class="comment">// The following specializations define the default values for</span>
<a name="l00142"></a>00142 <span class="comment">// specific types we care about.</span>
<a name="l00143"></a><a class="code" href="gmock-actions_8h.html#a06b1e6cd1145acf7849e4a112976016b">00143</a> <span class="preprocessor">#define GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_(type, value) \</span>
<a name="l00144"></a>00144 <span class="preprocessor">  template &lt;&gt; \</span>
<a name="l00145"></a>00145 <span class="preprocessor">  class BuiltInDefaultValue&lt;type&gt; { \</span>
<a name="l00146"></a>00146 <span class="preprocessor">   public: \</span>
<a name="l00147"></a>00147 <span class="preprocessor">    static bool Exists() { return true; } \</span>
<a name="l00148"></a>00148 <span class="preprocessor">    static type Get() { return value; } \</span>
<a name="l00149"></a>00149 <span class="preprocessor">  }</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span>
<a name="l00151"></a>00151 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">void</span>, );  <span class="comment">// NOLINT</span>
<a name="l00152"></a>00152 <span class="preprocessor">#if GTEST_HAS_GLOBAL_STRING</span>
<a name="l00153"></a>00153 <span class="preprocessor"></span><a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(::<span class="keywordtype">string</span>, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00154"></a>00154 <span class="preprocessor">#endif  // GTEST_HAS_GLOBAL_STRING</span>
<a name="l00155"></a>00155 <span class="preprocessor"></span><a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(::<a class="code" href="namespacetesting_1_1internal.html#a8e8ff5b11e64078831112677156cb111">std::string</a>, <span class="stringliteral">&quot;&quot;</span>);
<a name="l00156"></a>00156 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">bool</span>, <span class="keyword">false</span>);
<a name="l00157"></a>00157 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">char</span>, <span class="charliteral">&#39;\0&#39;</span>);
<a name="l00158"></a>00158 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">signed</span> <span class="keywordtype">char</span>, <span class="charliteral">&#39;\0&#39;</span>);
<a name="l00159"></a>00159 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">char</span>, <span class="charliteral">&#39;\0&#39;</span>);
<a name="l00160"></a>00160 
<a name="l00161"></a>00161 <span class="comment">// There&#39;s no need for a default action for signed wchar_t, as that</span>
<a name="l00162"></a>00162 <span class="comment">// type is the same as wchar_t for gcc, and invalid for MSVC.</span>
<a name="l00163"></a>00163 <span class="comment">//</span>
<a name="l00164"></a>00164 <span class="comment">// There&#39;s also no need for a default action for unsigned wchar_t, as</span>
<a name="l00165"></a>00165 <span class="comment">// that type is the same as unsigned int for gcc, and invalid for</span>
<a name="l00166"></a>00166 <span class="comment">// MSVC.</span>
<a name="l00167"></a>00167 <span class="preprocessor">#if GMOCK_WCHAR_T_IS_NATIVE_</span>
<a name="l00168"></a>00168 <span class="preprocessor"></span><a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">wchar_t</span>, 0U);  <span class="comment">// NOLINT</span>
<a name="l00169"></a>00169 <span class="preprocessor">#endif</span>
<a name="l00170"></a>00170 <span class="preprocessor"></span>
<a name="l00171"></a>00171 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span>, 0U);  <span class="comment">// NOLINT</span>
<a name="l00172"></a>00172 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">signed</span> <span class="keywordtype">short</span>, 0);     <span class="comment">// NOLINT</span>
<a name="l00173"></a>00173 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>, 0U);
<a name="l00174"></a>00174 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">signed</span> <span class="keywordtype">int</span>, 0);
<a name="l00175"></a>00175 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>, 0UL);  <span class="comment">// NOLINT</span>
<a name="l00176"></a>00176 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">signed</span> <span class="keywordtype">long</span>, 0L);     <span class="comment">// NOLINT</span>
<a name="l00177"></a>00177 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<a class="code" href="namespacetesting_1_1internal.html#aa6a1ac454e6d7e550fa4925c62c35caa">UInt64</a>, 0);
<a name="l00178"></a>00178 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<a class="code" href="namespacetesting_1_1internal.html#a271c563fec38b804ddab0677f51f70a8">Int64</a>, 0);
<a name="l00179"></a>00179 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">float</span>, 0);
<a name="l00180"></a>00180 <a class="code" href="namespacetesting_1_1internal.html#a8fe6f7c11d6d3dd6e42b75c9a5b43861">GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</a>(<span class="keywordtype">double</span>, 0);
<a name="l00181"></a>00181 
<a name="l00182"></a>00182 <span class="preprocessor">#undef GMOCK_DEFINE_DEFAULT_ACTION_FOR_RETURN_TYPE_</span>
<a name="l00183"></a>00183 <span class="preprocessor"></span>
<a name="l00184"></a>00184 }  <span class="comment">// namespace internal</span>
<a name="l00185"></a>00185 
<a name="l00186"></a>00186 <span class="comment">// When an unexpected function call is encountered, Google Mock will</span>
<a name="l00187"></a>00187 <span class="comment">// let it return a default value if the user has specified one for its</span>
<a name="l00188"></a>00188 <span class="comment">// return type, or if the return type has a built-in default value;</span>
<a name="l00189"></a>00189 <span class="comment">// otherwise Google Mock won&#39;t know what value to return and will have</span>
<a name="l00190"></a>00190 <span class="comment">// to abort the process.</span>
<a name="l00191"></a>00191 <span class="comment">//</span>
<a name="l00192"></a>00192 <span class="comment">// The DefaultValue&lt;T&gt; class allows a user to specify the</span>
<a name="l00193"></a>00193 <span class="comment">// default value for a type T that is both copyable and publicly</span>
<a name="l00194"></a>00194 <span class="comment">// destructible (i.e. anything that can be used as a function return</span>
<a name="l00195"></a>00195 <span class="comment">// type).  The usage is:</span>
<a name="l00196"></a>00196 <span class="comment">//</span>
<a name="l00197"></a>00197 <span class="comment">//   // Sets the default value for type T to be foo.</span>
<a name="l00198"></a>00198 <span class="comment">//   DefaultValue&lt;T&gt;::Set(foo);</span>
<a name="l00199"></a>00199 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00200"></a><a class="code" href="classtesting_1_1DefaultValue.html">00200</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1DefaultValue.html">DefaultValue</a> {
<a name="l00201"></a>00201  <span class="keyword">public</span>:
<a name="l00202"></a>00202   <span class="comment">// Sets the default value for type T; requires T to be</span>
<a name="l00203"></a>00203   <span class="comment">// copy-constructable and have a public destructor.</span>
<a name="l00204"></a><a class="code" href="classtesting_1_1DefaultValue.html#a5698814be364b9ac26e72ad37d6ff14e">00204</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1DefaultValue.html#a5698814be364b9ac26e72ad37d6ff14e">Set</a>(T x) {
<a name="l00205"></a>00205     <span class="keyword">delete</span> producer_;
<a name="l00206"></a>00206     producer_ = <span class="keyword">new</span> FixedValueProducer(x);
<a name="l00207"></a>00207   }
<a name="l00208"></a>00208 
<a name="l00209"></a>00209   <span class="comment">// Provides a factory function to be called to generate the default value.</span>
<a name="l00210"></a>00210   <span class="comment">// This method can be used even if T is only move-constructible, but it is not</span>
<a name="l00211"></a>00211   <span class="comment">// limited to that case.</span>
<a name="l00212"></a><a class="code" href="classtesting_1_1DefaultValue.html#a5d7a466bff8eb3a2de47017d65ddd646">00212</a>   <span class="keyword">typedef</span> T (*<a class="code" href="classtesting_1_1DefaultValue.html#a5d7a466bff8eb3a2de47017d65ddd646">FactoryFunction</a>)();
<a name="l00213"></a><a class="code" href="classtesting_1_1DefaultValue.html#af012445ff5b194940c1427529707cb91">00213</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1DefaultValue.html#af012445ff5b194940c1427529707cb91">SetFactory</a>(<a class="code" href="classtesting_1_1DefaultValue.html#a5d7a466bff8eb3a2de47017d65ddd646">FactoryFunction</a> factory) {
<a name="l00214"></a>00214     <span class="keyword">delete</span> producer_;
<a name="l00215"></a>00215     producer_ = <span class="keyword">new</span> FactoryValueProducer(factory);
<a name="l00216"></a>00216   }
<a name="l00217"></a>00217 
<a name="l00218"></a>00218   <span class="comment">// Unsets the default value for type T.</span>
<a name="l00219"></a><a class="code" href="classtesting_1_1DefaultValue.html#a8163037b60311177cb211f070c512ee3">00219</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1DefaultValue.html#a8163037b60311177cb211f070c512ee3">Clear</a>() {
<a name="l00220"></a>00220     <span class="keyword">delete</span> producer_;
<a name="l00221"></a>00221     producer_ = NULL;
<a name="l00222"></a>00222   }
<a name="l00223"></a>00223 
<a name="l00224"></a>00224   <span class="comment">// Returns true iff the user has set the default value for type T.</span>
<a name="l00225"></a><a class="code" href="classtesting_1_1DefaultValue.html#ad49febe2c944cbbd06451ba7d0366ca1">00225</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1DefaultValue.html#ad49febe2c944cbbd06451ba7d0366ca1">IsSet</a>() { <span class="keywordflow">return</span> producer_ != NULL; }
<a name="l00226"></a>00226 
<a name="l00227"></a>00227   <span class="comment">// Returns true if T has a default return value set by the user or there</span>
<a name="l00228"></a>00228   <span class="comment">// exists a built-in default value.</span>
<a name="l00229"></a><a class="code" href="classtesting_1_1DefaultValue.html#aec1ff9b510af7dbb86c837fd2409fd70">00229</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1DefaultValue.html#aec1ff9b510af7dbb86c837fd2409fd70">Exists</a>() {
<a name="l00230"></a>00230     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1DefaultValue.html#ad49febe2c944cbbd06451ba7d0366ca1">IsSet</a>() || <a class="code" href="classtesting_1_1DefaultValue.html#aec1ff9b510af7dbb86c837fd2409fd70">internal::BuiltInDefaultValue&lt;T&gt;::Exists</a>();
<a name="l00231"></a>00231   }
<a name="l00232"></a>00232 
<a name="l00233"></a>00233   <span class="comment">// Returns the default value for type T if the user has set one;</span>
<a name="l00234"></a>00234   <span class="comment">// otherwise returns the built-in default value. Requires that Exists()</span>
<a name="l00235"></a>00235   <span class="comment">// is true, which ensures that the return value is well-defined.</span>
<a name="l00236"></a><a class="code" href="classtesting_1_1DefaultValue.html#a4dc6dfee4cbc9cdb36f5c9cde5cf2b83">00236</a>   <span class="keyword">static</span> T <a class="code" href="classtesting_1_1DefaultValue.html#a4dc6dfee4cbc9cdb36f5c9cde5cf2b83">Get</a>() {
<a name="l00237"></a>00237     <span class="keywordflow">return</span> producer_ == NULL ?
<a name="l00238"></a>00238         <a class="code" href="classtesting_1_1DefaultValue.html#a4dc6dfee4cbc9cdb36f5c9cde5cf2b83">internal::BuiltInDefaultValue&lt;T&gt;::Get</a>() : producer_-&gt;Produce();
<a name="l00239"></a>00239   }
<a name="l00240"></a>00240 
<a name="l00241"></a>00241  <span class="keyword">private</span>:
<a name="l00242"></a>00242   <span class="keyword">class </span>ValueProducer {
<a name="l00243"></a>00243    <span class="keyword">public</span>:
<a name="l00244"></a>00244     <span class="keyword">virtual</span> ~ValueProducer() {}
<a name="l00245"></a>00245     <span class="keyword">virtual</span> T Produce() = 0;
<a name="l00246"></a>00246   };
<a name="l00247"></a>00247 
<a name="l00248"></a>00248   <span class="keyword">class </span>FixedValueProducer : <span class="keyword">public</span> ValueProducer {
<a name="l00249"></a>00249    <span class="keyword">public</span>:
<a name="l00250"></a>00250     <span class="keyword">explicit</span> FixedValueProducer(T value) : value_(value) {}
<a name="l00251"></a>00251     <span class="keyword">virtual</span> T Produce() { <span class="keywordflow">return</span> value_; }
<a name="l00252"></a>00252 
<a name="l00253"></a>00253    <span class="keyword">private</span>:
<a name="l00254"></a>00254     <span class="keyword">const</span> T value_;
<a name="l00255"></a>00255     <a class="code" href="gtest-port_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(FixedValueProducer);
<a name="l00256"></a>00256   };
<a name="l00257"></a>00257 
<a name="l00258"></a>00258   <span class="keyword">class </span>FactoryValueProducer : <span class="keyword">public</span> ValueProducer {
<a name="l00259"></a>00259    <span class="keyword">public</span>:
<a name="l00260"></a>00260     <span class="keyword">explicit</span> FactoryValueProducer(<a class="code" href="classtesting_1_1DefaultValue.html#a5d7a466bff8eb3a2de47017d65ddd646">FactoryFunction</a> factory)
<a name="l00261"></a>00261         : factory_(factory) {}
<a name="l00262"></a>00262     <span class="keyword">virtual</span> T Produce() { <span class="keywordflow">return</span> factory_(); }
<a name="l00263"></a>00263 
<a name="l00264"></a>00264    <span class="keyword">private</span>:
<a name="l00265"></a>00265     <span class="keyword">const</span> <a class="code" href="classtesting_1_1DefaultValue.html#a5d7a466bff8eb3a2de47017d65ddd646">FactoryFunction</a> factory_;
<a name="l00266"></a>00266     <a class="code" href="gtest-port_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(FactoryValueProducer);
<a name="l00267"></a>00267   };
<a name="l00268"></a>00268 
<a name="l00269"></a>00269   <span class="keyword">static</span> ValueProducer* producer_;
<a name="l00270"></a>00270 };
<a name="l00271"></a>00271 
<a name="l00272"></a>00272 <span class="comment">// This partial specialization allows a user to set default values for</span>
<a name="l00273"></a>00273 <span class="comment">// reference types.</span>
<a name="l00274"></a>00274 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00275"></a><a class="code" href="classtesting_1_1DefaultValue_3_01T_01_6_01_4.html">00275</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1DefaultValue.html">DefaultValue</a>&lt;T&amp;&gt; {
<a name="l00276"></a>00276  <span class="keyword">public</span>:
<a name="l00277"></a>00277   <span class="comment">// Sets the default value for type T&amp;.</span>
<a name="l00278"></a><a class="code" href="classtesting_1_1DefaultValue_3_01T_01_6_01_4.html#a9863abf3d311ce5007d7e57dfce2f252">00278</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1DefaultValue_3_01T_01_6_01_4.html#a9863abf3d311ce5007d7e57dfce2f252">Set</a>(T&amp; x) {  <span class="comment">// NOLINT</span>
<a name="l00279"></a>00279     address_ = &amp;x;
<a name="l00280"></a>00280   }
<a name="l00281"></a>00281 
<a name="l00282"></a>00282   <span class="comment">// Unsets the default value for type T&amp;.</span>
<a name="l00283"></a><a class="code" href="classtesting_1_1DefaultValue_3_01T_01_6_01_4.html#a3c8f9f81e591370f9b33798f58ca1a10">00283</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1DefaultValue_3_01T_01_6_01_4.html#a3c8f9f81e591370f9b33798f58ca1a10">Clear</a>() {
<a name="l00284"></a>00284     address_ = NULL;
<a name="l00285"></a>00285   }
<a name="l00286"></a>00286 
<a name="l00287"></a>00287   <span class="comment">// Returns true iff the user has set the default value for type T&amp;.</span>
<a name="l00288"></a><a class="code" href="classtesting_1_1DefaultValue_3_01T_01_6_01_4.html#a3e61547c2f0141cc8004385f3a9c817d">00288</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1DefaultValue_3_01T_01_6_01_4.html#a3e61547c2f0141cc8004385f3a9c817d">IsSet</a>() { <span class="keywordflow">return</span> address_ != NULL; }
<a name="l00289"></a>00289 
<a name="l00290"></a>00290   <span class="comment">// Returns true if T has a default return value set by the user or there</span>
<a name="l00291"></a>00291   <span class="comment">// exists a built-in default value.</span>
<a name="l00292"></a><a class="code" href="classtesting_1_1DefaultValue_3_01T_01_6_01_4.html#a38420499e17d2fb4146ae6c4265f0d55">00292</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1DefaultValue_3_01T_01_6_01_4.html#a38420499e17d2fb4146ae6c4265f0d55">Exists</a>() {
<a name="l00293"></a>00293     <span class="keywordflow">return</span> IsSet() || <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html#a35207bc20a493b0efb3980eb9a08dd2f">internal::BuiltInDefaultValue&lt;T&amp;&gt;::Exists</a>();
<a name="l00294"></a>00294   }
<a name="l00295"></a>00295 
<a name="l00296"></a>00296   <span class="comment">// Returns the default value for type T&amp; if the user has set one;</span>
<a name="l00297"></a>00297   <span class="comment">// otherwise returns the built-in default value if there is one;</span>
<a name="l00298"></a>00298   <span class="comment">// otherwise aborts the process.</span>
<a name="l00299"></a><a class="code" href="classtesting_1_1DefaultValue_3_01T_01_6_01_4.html#a1310448dd8c171aecfcbf7c8df5de7bd">00299</a>   <span class="keyword">static</span> T&amp; <a class="code" href="classtesting_1_1DefaultValue_3_01T_01_6_01_4.html#a1310448dd8c171aecfcbf7c8df5de7bd">Get</a>() {
<a name="l00300"></a>00300     <span class="keywordflow">return</span> address_ == NULL ?
<a name="l00301"></a>00301         <a class="code" href="classtesting_1_1internal_1_1BuiltInDefaultValue.html#a7e26c1df14a887c8f393b29d6ea162e6">internal::BuiltInDefaultValue&lt;T&amp;&gt;::Get</a>() : *address_;
<a name="l00302"></a>00302   }
<a name="l00303"></a>00303 
<a name="l00304"></a>00304  <span class="keyword">private</span>:
<a name="l00305"></a>00305   <span class="keyword">static</span> T* address_;
<a name="l00306"></a>00306 };
<a name="l00307"></a>00307 
<a name="l00308"></a>00308 <span class="comment">// This specialization allows DefaultValue&lt;void&gt;::Get() to</span>
<a name="l00309"></a>00309 <span class="comment">// compile.</span>
<a name="l00310"></a>00310 <span class="keyword">template</span> &lt;&gt;
<a name="l00311"></a><a class="code" href="classtesting_1_1DefaultValue_3_01void_01_4.html">00311</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1DefaultValue.html">DefaultValue</a>&lt;void&gt; {
<a name="l00312"></a>00312  <span class="keyword">public</span>:
<a name="l00313"></a><a class="code" href="classtesting_1_1DefaultValue_3_01void_01_4.html#ae18ea46cbf928b820c91f15fa7aa317b">00313</a>   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1DefaultValue_3_01void_01_4.html#ae18ea46cbf928b820c91f15fa7aa317b">Exists</a>() { <span class="keywordflow">return</span> <span class="keyword">true</span>; }
<a name="l00314"></a><a class="code" href="classtesting_1_1DefaultValue_3_01void_01_4.html#acda4c367a5b0c0cfb28bc2289f385eed">00314</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1DefaultValue_3_01void_01_4.html#acda4c367a5b0c0cfb28bc2289f385eed">Get</a>() {}
<a name="l00315"></a>00315 };
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <span class="comment">// Points to the user-set default value for type T.</span>
<a name="l00318"></a>00318 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00319"></a>00319 <span class="keyword">typename</span> DefaultValue&lt;T&gt;::ValueProducer* DefaultValue&lt;T&gt;::producer_ = NULL;
<a name="l00320"></a>00320 
<a name="l00321"></a>00321 <span class="comment">// Points to the user-set default value for type T&amp;.</span>
<a name="l00322"></a>00322 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00323"></a>00323 T* DefaultValue&lt;T&amp;&gt;::address_ = NULL;
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="comment">// Implement this interface to define an action for function type F.</span>
<a name="l00326"></a>00326 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00327"></a><a class="code" href="classtesting_1_1ActionInterface.html">00327</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1ActionInterface.html">ActionInterface</a> {
<a name="l00328"></a>00328  <span class="keyword">public</span>:
<a name="l00329"></a><a class="code" href="classtesting_1_1ActionInterface.html#a7477de2fe3e4e01c59db698203acaee7">00329</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::Function&lt;F&gt;::Result <a class="code" href="classtesting_1_1ActionInterface.html#a7477de2fe3e4e01c59db698203acaee7">Result</a>;
<a name="l00330"></a><a class="code" href="classtesting_1_1ActionInterface.html#af72720d864da4d606629e83edc003511">00330</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::Function&lt;F&gt;::ArgumentTuple <a class="code" href="classtesting_1_1ActionInterface.html#af72720d864da4d606629e83edc003511">ArgumentTuple</a>;
<a name="l00331"></a>00331 
<a name="l00332"></a><a class="code" href="classtesting_1_1ActionInterface.html#a0f1d44e4c669a9cae5ee5b28419a6f52">00332</a>   <a class="code" href="classtesting_1_1ActionInterface.html#a0f1d44e4c669a9cae5ee5b28419a6f52">ActionInterface</a>() {}
<a name="l00333"></a><a class="code" href="classtesting_1_1ActionInterface.html#a7dd0a5fc93d86ae3c9d04963b9f3a93f">00333</a>   <span class="keyword">virtual</span> <a class="code" href="classtesting_1_1ActionInterface.html#a7dd0a5fc93d86ae3c9d04963b9f3a93f">~ActionInterface</a>() {}
<a name="l00334"></a>00334 
<a name="l00335"></a>00335   <span class="comment">// Performs the action.  This method is not const, as in general an</span>
<a name="l00336"></a>00336   <span class="comment">// action can have side effects and be stateful.  For example, a</span>
<a name="l00337"></a>00337   <span class="comment">// get-the-next-element-from-the-collection action will need to</span>
<a name="l00338"></a>00338   <span class="comment">// remember the current element.</span>
<a name="l00339"></a>00339   <span class="keyword">virtual</span> <a class="code" href="classtesting_1_1ActionInterface.html#a7477de2fe3e4e01c59db698203acaee7">Result</a> <a class="code" href="classtesting_1_1ActionInterface.html#a20f8624fcea1786f2992b358760422a0">Perform</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1ActionInterface.html#af72720d864da4d606629e83edc003511">ArgumentTuple</a>&amp; args) = 0;
<a name="l00340"></a>00340 
<a name="l00341"></a>00341  <span class="keyword">private</span>:
<a name="l00342"></a>00342   GTEST_DISALLOW_COPY_AND_ASSIGN_(<a class="code" href="classtesting_1_1ActionInterface.html">ActionInterface</a>);
<a name="l00343"></a>00343 };
<a name="l00344"></a>00344 
<a name="l00345"></a>00345 <span class="comment">// An Action&lt;F&gt; is a copyable and IMMUTABLE (except by assignment)</span>
<a name="l00346"></a>00346 <span class="comment">// object that represents an action to be taken when a mock function</span>
<a name="l00347"></a>00347 <span class="comment">// of type F is called.  The implementation of Action&lt;T&gt; is just a</span>
<a name="l00348"></a>00348 <span class="comment">// linked_ptr to const ActionInterface&lt;T&gt;, so copying is fairly cheap.</span>
<a name="l00349"></a>00349 <span class="comment">// Don&#39;t inherit from Action!</span>
<a name="l00350"></a>00350 <span class="comment">//</span>
<a name="l00351"></a>00351 <span class="comment">// You can view an object implementing ActionInterface&lt;F&gt; as a</span>
<a name="l00352"></a>00352 <span class="comment">// concrete action (including its current state), and an Action&lt;F&gt;</span>
<a name="l00353"></a>00353 <span class="comment">// object as a handle to it.</span>
<a name="l00354"></a>00354 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00355"></a><a class="code" href="classtesting_1_1Action.html">00355</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1Action.html">Action</a> {
<a name="l00356"></a>00356  <span class="keyword">public</span>:
<a name="l00357"></a><a class="code" href="classtesting_1_1Action.html#a9af08a21ad329331fde856cba9b6dea2">00357</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::Function&lt;F&gt;::Result <a class="code" href="classtesting_1_1Action.html#a9af08a21ad329331fde856cba9b6dea2">Result</a>;
<a name="l00358"></a><a class="code" href="classtesting_1_1Action.html#ae27fda510696a9294f991de5b1abfaf2">00358</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::Function&lt;F&gt;::ArgumentTuple <a class="code" href="classtesting_1_1Action.html#ae27fda510696a9294f991de5b1abfaf2">ArgumentTuple</a>;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360   <span class="comment">// Constructs a null Action.  Needed for storing Action objects in</span>
<a name="l00361"></a>00361   <span class="comment">// STL containers.</span>
<a name="l00362"></a><a class="code" href="classtesting_1_1Action.html#a967772922a39dd7098bee429d749f277">00362</a>   <a class="code" href="classtesting_1_1Action.html#a967772922a39dd7098bee429d749f277">Action</a>() : impl_(NULL) {}
<a name="l00363"></a>00363 
<a name="l00364"></a>00364   <span class="comment">// Constructs an Action from its implementation.  A NULL impl is</span>
<a name="l00365"></a>00365   <span class="comment">// used to represent the &quot;do-default&quot; action.</span>
<a name="l00366"></a><a class="code" href="classtesting_1_1Action.html#a5ce44c673e3f91378777b954d88917cd">00366</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1Action.html#a5ce44c673e3f91378777b954d88917cd">Action</a>(<a class="code" href="classtesting_1_1ActionInterface.html">ActionInterface&lt;F&gt;</a>* impl) : impl_(impl) {}
<a name="l00367"></a>00367 
<a name="l00368"></a>00368   <span class="comment">// Copy constructor.</span>
<a name="l00369"></a><a class="code" href="classtesting_1_1Action.html#a7027316ea3a6972ce7847496eb360ccd">00369</a>   <a class="code" href="classtesting_1_1Action.html#a7027316ea3a6972ce7847496eb360ccd">Action</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1Action.html">Action</a>&amp; action) : impl_(action.impl_) {}
<a name="l00370"></a>00370 
<a name="l00371"></a>00371   <span class="comment">// This constructor allows us to turn an Action&lt;Func&gt; object into an</span>
<a name="l00372"></a>00372   <span class="comment">// Action&lt;F&gt;, as long as F&#39;s arguments can be implicitly converted</span>
<a name="l00373"></a>00373   <span class="comment">// to Func&#39;s and Func&#39;s return type can be implicitly converted to</span>
<a name="l00374"></a>00374   <span class="comment">// F&#39;s.</span>
<a name="l00375"></a>00375   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Func&gt;
<a name="l00376"></a>00376   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1Action.html#a967772922a39dd7098bee429d749f277">Action</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;Func&gt;</a>&amp; action);
<a name="l00377"></a>00377 
<a name="l00378"></a>00378   <span class="comment">// Returns true iff this is the DoDefault() action.</span>
<a name="l00379"></a><a class="code" href="classtesting_1_1Action.html#ae9c02b07e99272733c871a270d1db320">00379</a>   <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1Action.html#ae9c02b07e99272733c871a270d1db320">IsDoDefault</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> impl_.<a class="code" href="classtesting_1_1internal_1_1linked__ptr.html#a6ea8584d9bcad13c3266834f5ce5e771">get</a>() == NULL; }
<a name="l00380"></a>00380 
<a name="l00381"></a>00381   <span class="comment">// Performs the action.  Note that this method is const even though</span>
<a name="l00382"></a>00382   <span class="comment">// the corresponding method in ActionInterface is not.  The reason</span>
<a name="l00383"></a>00383   <span class="comment">// is that a const Action&lt;F&gt; means that it cannot be re-bound to</span>
<a name="l00384"></a>00384   <span class="comment">// another concrete action, not that the concrete action it binds to</span>
<a name="l00385"></a>00385   <span class="comment">// cannot change state.  (Think of the difference between a const</span>
<a name="l00386"></a>00386   <span class="comment">// pointer and a pointer to const.)</span>
<a name="l00387"></a><a class="code" href="classtesting_1_1Action.html#a304209ac946a1966164e3d109bc16189">00387</a>   <a class="code" href="classtesting_1_1Action.html#a9af08a21ad329331fde856cba9b6dea2">Result</a> <a class="code" href="classtesting_1_1Action.html#a304209ac946a1966164e3d109bc16189">Perform</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1Action.html#ae27fda510696a9294f991de5b1abfaf2">ArgumentTuple</a>&amp; args)<span class="keyword"> const </span>{
<a name="l00388"></a>00388     <a class="code" href="namespacetesting_1_1internal.html#a7a259643b7f2d23ce2b757728df42c99">internal::Assert</a>(
<a name="l00389"></a>00389         !<a class="code" href="classtesting_1_1Action.html#ae9c02b07e99272733c871a270d1db320">IsDoDefault</a>(), __FILE__, __LINE__,
<a name="l00390"></a>00390         <span class="stringliteral">&quot;You are using DoDefault() inside a composite action like &quot;</span>
<a name="l00391"></a>00391         <span class="stringliteral">&quot;DoAll() or WithArgs().  This is not supported for technical &quot;</span>
<a name="l00392"></a>00392         <span class="stringliteral">&quot;reasons.  Please instead spell out the default action, or &quot;</span>
<a name="l00393"></a>00393         <span class="stringliteral">&quot;assign the default action to an Action variable and use &quot;</span>
<a name="l00394"></a>00394         <span class="stringliteral">&quot;the variable in various places.&quot;</span>);
<a name="l00395"></a>00395     <span class="keywordflow">return</span> impl_-&gt;Perform(args);
<a name="l00396"></a>00396   }
<a name="l00397"></a>00397 
<a name="l00398"></a>00398  <span class="keyword">private</span>:
<a name="l00399"></a>00399   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2&gt;
<a name="l00400"></a><a class="code" href="classtesting_1_1Action.html#a646438634803938d72de3a3fee5bb271">00400</a>   <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html">internal::ActionAdaptor</a>;
<a name="l00401"></a>00401 
<a name="l00402"></a>00402   <a class="code" href="classtesting_1_1internal_1_1linked__ptr.html">internal::linked_ptr&lt;ActionInterface&lt;F&gt;</a> &gt; impl_;
<a name="l00403"></a>00403 };
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="comment">// The PolymorphicAction class template makes it easy to implement a</span>
<a name="l00406"></a>00406 <span class="comment">// polymorphic action (i.e. an action that can be used in mock</span>
<a name="l00407"></a>00407 <span class="comment">// functions of than one type, e.g. Return()).</span>
<a name="l00408"></a>00408 <span class="comment">//</span>
<a name="l00409"></a>00409 <span class="comment">// To define a polymorphic action, a user first provides a COPYABLE</span>
<a name="l00410"></a>00410 <span class="comment">// implementation class that has a Perform() method template:</span>
<a name="l00411"></a>00411 <span class="comment">//</span>
<a name="l00412"></a>00412 <span class="comment">//   class FooAction {</span>
<a name="l00413"></a>00413 <span class="comment">//    public:</span>
<a name="l00414"></a>00414 <span class="comment">//     template &lt;typename Result, typename ArgumentTuple&gt;</span>
<a name="l00415"></a>00415 <span class="comment">//     Result Perform(const ArgumentTuple&amp; args) const {</span>
<a name="l00416"></a>00416 <span class="comment">//       // Processes the arguments and returns a result, using</span>
<a name="l00417"></a>00417 <span class="comment">//       // tr1::get&lt;N&gt;(args) to get the N-th (0-based) argument in the tuple.</span>
<a name="l00418"></a>00418 <span class="comment">//     }</span>
<a name="l00419"></a>00419 <span class="comment">//     ...</span>
<a name="l00420"></a>00420 <span class="comment">//   };</span>
<a name="l00421"></a>00421 <span class="comment">//</span>
<a name="l00422"></a>00422 <span class="comment">// Then the user creates the polymorphic action using</span>
<a name="l00423"></a>00423 <span class="comment">// MakePolymorphicAction(object) where object has type FooAction.  See</span>
<a name="l00424"></a>00424 <span class="comment">// the definition of Return(void) and SetArgumentPointee&lt;N&gt;(value) for</span>
<a name="l00425"></a>00425 <span class="comment">// complete examples.</span>
<a name="l00426"></a>00426 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Impl&gt;
<a name="l00427"></a><a class="code" href="classtesting_1_1PolymorphicAction.html">00427</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1PolymorphicAction.html">PolymorphicAction</a> {
<a name="l00428"></a>00428  <span class="keyword">public</span>:
<a name="l00429"></a><a class="code" href="classtesting_1_1PolymorphicAction.html#a062e5a45ad61dcf8085b15cc882ca0ae">00429</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1PolymorphicAction.html#a062e5a45ad61dcf8085b15cc882ca0ae">PolymorphicAction</a>(<span class="keyword">const</span> Impl&amp; impl) : impl_(impl) {}
<a name="l00430"></a>00430 
<a name="l00431"></a>00431   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00432"></a><a class="code" href="classtesting_1_1PolymorphicAction.html#a40a074d559aceae2afcf53a305cfdcb5">00432</a>   <a class="code" href="classtesting_1_1PolymorphicAction.html#a40a074d559aceae2afcf53a305cfdcb5">operator Action&lt;F&gt;</a>()<span class="keyword"> const </span>{
<a name="l00433"></a>00433     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;F&gt;</a>(<span class="keyword">new</span> MonomorphicImpl&lt;F&gt;(impl_));
<a name="l00434"></a>00434   }
<a name="l00435"></a>00435 
<a name="l00436"></a>00436  <span class="keyword">private</span>:
<a name="l00437"></a>00437   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00438"></a>00438   <span class="keyword">class </span>MonomorphicImpl : <span class="keyword">public</span> <a class="code" href="classtesting_1_1ActionInterface.html">ActionInterface</a>&lt;F&gt; {
<a name="l00439"></a>00439    <span class="keyword">public</span>:
<a name="l00440"></a>00440     <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::Function&lt;F&gt;::Result Result;
<a name="l00441"></a>00441     <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
<a name="l00442"></a>00442 
<a name="l00443"></a>00443     <span class="keyword">explicit</span> MonomorphicImpl(<span class="keyword">const</span> Impl&amp; impl) : impl_(impl) {}
<a name="l00444"></a>00444 
<a name="l00445"></a>00445     <span class="keyword">virtual</span> Result Perform(<span class="keyword">const</span> ArgumentTuple&amp; args) {
<a name="l00446"></a>00446       <span class="keywordflow">return</span> impl_.template Perform&lt;Result&gt;(args);
<a name="l00447"></a>00447     }
<a name="l00448"></a>00448 
<a name="l00449"></a>00449    <span class="keyword">private</span>:
<a name="l00450"></a>00450     Impl impl_;
<a name="l00451"></a>00451 
<a name="l00452"></a>00452     <a class="code" href="gtest-port_8h.html#ac593b50ce24257d5b6aa84845c344c9e">GTEST_DISALLOW_ASSIGN_</a>(MonomorphicImpl);
<a name="l00453"></a>00453   };
<a name="l00454"></a>00454 
<a name="l00455"></a>00455   Impl impl_;
<a name="l00456"></a>00456 
<a name="l00457"></a>00457   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1PolymorphicAction.html#a062e5a45ad61dcf8085b15cc882ca0ae">PolymorphicAction</a>);
<a name="l00458"></a>00458 };
<a name="l00459"></a>00459 
<a name="l00460"></a>00460 <span class="comment">// Creates an Action from its implementation and returns it.  The</span>
<a name="l00461"></a>00461 <span class="comment">// created Action object owns the implementation.</span>
<a name="l00462"></a>00462 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00463"></a><a class="code" href="namespacetesting.html#ae6b9960db2b2685e043ce5215291f5b8">00463</a> <a class="code" href="classtesting_1_1Action.html">Action&lt;F&gt;</a> <a class="code" href="namespacetesting.html#ae6b9960db2b2685e043ce5215291f5b8">MakeAction</a>(<a class="code" href="classtesting_1_1ActionInterface.html">ActionInterface&lt;F&gt;</a>* impl) {
<a name="l00464"></a>00464   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;F&gt;</a>(impl);
<a name="l00465"></a>00465 }
<a name="l00466"></a>00466 
<a name="l00467"></a>00467 <span class="comment">// Creates a polymorphic action from its implementation.  This is</span>
<a name="l00468"></a>00468 <span class="comment">// easier to use than the PolymorphicAction&lt;Impl&gt; constructor as it</span>
<a name="l00469"></a>00469 <span class="comment">// doesn&#39;t require you to explicitly write the template argument, e.g.</span>
<a name="l00470"></a>00470 <span class="comment">//</span>
<a name="l00471"></a>00471 <span class="comment">//   MakePolymorphicAction(foo);</span>
<a name="l00472"></a>00472 <span class="comment">// vs</span>
<a name="l00473"></a>00473 <span class="comment">//   PolymorphicAction&lt;TypeOfFoo&gt;(foo);</span>
<a name="l00474"></a>00474 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Impl&gt;
<a name="l00475"></a><a class="code" href="namespacetesting.html#a36bd06c5ea972c6df0bd9f40a7a94c65">00475</a> <span class="keyword">inline</span> <a class="code" href="classtesting_1_1PolymorphicAction.html">PolymorphicAction&lt;Impl&gt;</a> <a class="code" href="namespacetesting.html#a36bd06c5ea972c6df0bd9f40a7a94c65">MakePolymorphicAction</a>(<span class="keyword">const</span> Impl&amp; impl) {
<a name="l00476"></a>00476   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1PolymorphicAction.html">PolymorphicAction&lt;Impl&gt;</a>(impl);
<a name="l00477"></a>00477 }
<a name="l00478"></a>00478 
<a name="l00479"></a>00479 <span class="keyword">namespace </span>internal {
<a name="l00480"></a>00480 
<a name="l00481"></a>00481 <span class="comment">// Allows an Action&lt;F2&gt; object to pose as an Action&lt;F1&gt;, as long as F2</span>
<a name="l00482"></a>00482 <span class="comment">// and F1 are compatible.</span>
<a name="l00483"></a>00483 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F1, <span class="keyword">typename</span> F2&gt;
<a name="l00484"></a><a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html">00484</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html">ActionAdaptor</a> : <span class="keyword">public</span> <a class="code" href="classtesting_1_1ActionInterface.html">ActionInterface</a>&lt;F1&gt; {
<a name="l00485"></a>00485  <span class="keyword">public</span>:
<a name="l00486"></a><a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html#afa8f7872b6db3d8f1545fd98b45b0b95">00486</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::Function&lt;F1&gt;::Result <a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html#afa8f7872b6db3d8f1545fd98b45b0b95">Result</a>;
<a name="l00487"></a><a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html#a4f78fb73f97b72fea8a93b78a8ab5704">00487</a>   <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::Function&lt;F1&gt;::ArgumentTuple <a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html#a4f78fb73f97b72fea8a93b78a8ab5704">ArgumentTuple</a>;
<a name="l00488"></a>00488 
<a name="l00489"></a><a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html#a24ba3330ef3cc365b956c50ec73e4177">00489</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html#a24ba3330ef3cc365b956c50ec73e4177">ActionAdaptor</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;F2&gt;</a>&amp; from) : impl_(from.impl_) {}
<a name="l00490"></a>00490 
<a name="l00491"></a><a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html#a8d8a47a31f068cf6e0c95b91605d5540">00491</a>   <span class="keyword">virtual</span> <a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html#afa8f7872b6db3d8f1545fd98b45b0b95">Result</a> <a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html#a8d8a47a31f068cf6e0c95b91605d5540">Perform</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html#a4f78fb73f97b72fea8a93b78a8ab5704">ArgumentTuple</a>&amp; args) {
<a name="l00492"></a>00492     <span class="keywordflow">return</span> impl_-&gt;<a class="code" href="classtesting_1_1ActionInterface.html#a20f8624fcea1786f2992b358760422a0">Perform</a>(args);
<a name="l00493"></a>00493   }
<a name="l00494"></a>00494 
<a name="l00495"></a>00495  <span class="keyword">private</span>:
<a name="l00496"></a>00496   <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1linked__ptr.html">internal::linked_ptr&lt;ActionInterface&lt;F2&gt;</a> &gt; impl_;
<a name="l00497"></a>00497 
<a name="l00498"></a>00498   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1ActionAdaptor.html">ActionAdaptor</a>);
<a name="l00499"></a>00499 };
<a name="l00500"></a>00500 
<a name="l00501"></a>00501 <span class="comment">// Helper struct to specialize ReturnAction to execute a move instead of a copy</span>
<a name="l00502"></a>00502 <span class="comment">// on return. Useful for move-only types, but could be used on any type.</span>
<a name="l00503"></a>00503 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00504"></a><a class="code" href="structtesting_1_1internal_1_1ByMoveWrapper.html">00504</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1ByMoveWrapper.html">ByMoveWrapper</a> {
<a name="l00505"></a><a class="code" href="structtesting_1_1internal_1_1ByMoveWrapper.html#a60df33395785e0bfc5f72fba32376349">00505</a>   <span class="keyword">explicit</span> <a class="code" href="structtesting_1_1internal_1_1ByMoveWrapper.html#a60df33395785e0bfc5f72fba32376349">ByMoveWrapper</a>(T value) : <a class="code" href="structtesting_1_1internal_1_1ByMoveWrapper.html#ae8407b1ae99db3f00797d68b9ee9e870">payload</a>(internal::<a class="code" href="namespacetesting_1_1internal.html#a0f6d06bf8c3093b9c22bb08723db201e">move</a>(value)) {}
<a name="l00506"></a><a class="code" href="structtesting_1_1internal_1_1ByMoveWrapper.html#ae8407b1ae99db3f00797d68b9ee9e870">00506</a>   T <a class="code" href="structtesting_1_1internal_1_1ByMoveWrapper.html#ae8407b1ae99db3f00797d68b9ee9e870">payload</a>;
<a name="l00507"></a>00507 };
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 <span class="comment">// Implements the polymorphic Return(x) action, which can be used in</span>
<a name="l00510"></a>00510 <span class="comment">// any function that returns the type of x, regardless of the argument</span>
<a name="l00511"></a>00511 <span class="comment">// types.</span>
<a name="l00512"></a>00512 <span class="comment">//</span>
<a name="l00513"></a>00513 <span class="comment">// Note: The value passed into Return must be converted into</span>
<a name="l00514"></a>00514 <span class="comment">// Function&lt;F&gt;::Result when this action is cast to Action&lt;F&gt; rather than</span>
<a name="l00515"></a>00515 <span class="comment">// when that action is performed. This is important in scenarios like</span>
<a name="l00516"></a>00516 <span class="comment">//</span>
<a name="l00517"></a>00517 <span class="comment">// MOCK_METHOD1(Method, T(U));</span>
<a name="l00518"></a>00518 <span class="comment">// ...</span>
<a name="l00519"></a>00519 <span class="comment">// {</span>
<a name="l00520"></a>00520 <span class="comment">//   Foo foo;</span>
<a name="l00521"></a>00521 <span class="comment">//   X x(&amp;foo);</span>
<a name="l00522"></a>00522 <span class="comment">//   EXPECT_CALL(mock, Method(_)).WillOnce(Return(x));</span>
<a name="l00523"></a>00523 <span class="comment">// }</span>
<a name="l00524"></a>00524 <span class="comment">//</span>
<a name="l00525"></a>00525 <span class="comment">// In the example above the variable x holds reference to foo which leaves</span>
<a name="l00526"></a>00526 <span class="comment">// scope and gets destroyed.  If copying X just copies a reference to foo,</span>
<a name="l00527"></a>00527 <span class="comment">// that copy will be left with a hanging reference.  If conversion to T</span>
<a name="l00528"></a>00528 <span class="comment">// makes a copy of foo, the above code is safe. To support that scenario, we</span>
<a name="l00529"></a>00529 <span class="comment">// need to make sure that the type conversion happens inside the EXPECT_CALL</span>
<a name="l00530"></a>00530 <span class="comment">// statement, and conversion of the result of Return to Action&lt;T(U)&gt; is a</span>
<a name="l00531"></a>00531 <span class="comment">// good place for that.</span>
<a name="l00532"></a>00532 <span class="comment">//</span>
<a name="l00533"></a>00533 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;
<a name="l00534"></a><a class="code" href="classtesting_1_1internal_1_1ReturnAction.html">00534</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ReturnAction.html">ReturnAction</a> {
<a name="l00535"></a>00535  <span class="keyword">public</span>:
<a name="l00536"></a>00536   <span class="comment">// Constructs a ReturnAction object from the value to be returned.</span>
<a name="l00537"></a>00537   <span class="comment">// &#39;value&#39; is passed by value instead of by const reference in order</span>
<a name="l00538"></a>00538   <span class="comment">// to allow Return(&quot;string literal&quot;) to compile.</span>
<a name="l00539"></a><a class="code" href="classtesting_1_1internal_1_1ReturnAction.html#af65344e503dae3ab36b4fd6d1ede6fb7">00539</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1internal_1_1ReturnAction.html#af65344e503dae3ab36b4fd6d1ede6fb7">ReturnAction</a>(R value) : value_(new R(internal::<a class="code" href="namespacetesting_1_1internal.html#a0f6d06bf8c3093b9c22bb08723db201e">move</a>(value))) {}
<a name="l00540"></a>00540 
<a name="l00541"></a>00541   <span class="comment">// This template type conversion operator allows Return(x) to be</span>
<a name="l00542"></a>00542   <span class="comment">// used in ANY function that returns x&#39;s type.</span>
<a name="l00543"></a>00543   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00544"></a><a class="code" href="classtesting_1_1internal_1_1ReturnAction.html#a321155ed26bb50aea20d26f8603fb2ae">00544</a>   <a class="code" href="classtesting_1_1internal_1_1ReturnAction.html#a321155ed26bb50aea20d26f8603fb2ae">operator Action&lt;F&gt;</a>()<span class="keyword"> const </span>{
<a name="l00545"></a>00545     <span class="comment">// Assert statement belongs here because this is the best place to verify</span>
<a name="l00546"></a>00546     <span class="comment">// conditions on F. It produces the clearest error messages</span>
<a name="l00547"></a>00547     <span class="comment">// in most compilers.</span>
<a name="l00548"></a>00548     <span class="comment">// Impl really belongs in this scope as a local class but can&#39;t</span>
<a name="l00549"></a>00549     <span class="comment">// because MSVC produces duplicate symbols in different translation units</span>
<a name="l00550"></a>00550     <span class="comment">// in this case. Until MS fixes that bug we put Impl into the class scope</span>
<a name="l00551"></a>00551     <span class="comment">// and put the typedef both here (for use in assert statement) and</span>
<a name="l00552"></a>00552     <span class="comment">// in the Impl class. But both definitions must be the same.</span>
<a name="l00553"></a>00553     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::Result Result;
<a name="l00554"></a>00554     <a class="code" href="gtest-port_8h.html#ae1f37dc71d5daa6fb49ca1b6047d4a8c">GTEST_COMPILE_ASSERT_</a>(
<a name="l00555"></a>00555         !<a class="code" href="structtesting_1_1internal_1_1is__reference.html">is_reference&lt;Result&gt;::value</a>,
<a name="l00556"></a>00556         use_ReturnRef_instead_of_Return_to_return_a_reference);
<a name="l00557"></a>00557     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;F&gt;</a>(<span class="keyword">new</span> Impl&lt;R, F&gt;(value_));
<a name="l00558"></a>00558   }
<a name="l00559"></a>00559 
<a name="l00560"></a>00560  <span class="keyword">private</span>:
<a name="l00561"></a>00561   <span class="comment">// Implements the Return(x) action for a particular function type F.</span>
<a name="l00562"></a>00562   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R_, <span class="keyword">typename</span> F&gt;
<a name="l00563"></a>00563   <span class="keyword">class </span>Impl : <span class="keyword">public</span> <a class="code" href="classtesting_1_1ActionInterface.html">ActionInterface</a>&lt;F&gt; {
<a name="l00564"></a>00564    <span class="keyword">public</span>:
<a name="l00565"></a>00565     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::Result Result;
<a name="l00566"></a>00566     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568     <span class="comment">// The implicit cast is necessary when Result has more than one</span>
<a name="l00569"></a>00569     <span class="comment">// single-argument constructor (e.g. Result is std::vector&lt;int&gt;) and R</span>
<a name="l00570"></a>00570     <span class="comment">// has a type conversion operator template.  In that case, value_(value)</span>
<a name="l00571"></a>00571     <span class="comment">// won&#39;t compile as the compiler doesn&#39;t known which constructor of</span>
<a name="l00572"></a>00572     <span class="comment">// Result to call.  ImplicitCast_ forces the compiler to convert R to</span>
<a name="l00573"></a>00573     <span class="comment">// Result without considering explicit constructors, thus resolving the</span>
<a name="l00574"></a>00574     <span class="comment">// ambiguity. value_ is then initialized using its copy constructor.</span>
<a name="l00575"></a>00575     <span class="keyword">explicit</span> Impl(<span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1linked__ptr.html">linked_ptr&lt;R&gt;</a>&amp; value)
<a name="l00576"></a>00576         : value_before_cast_(*value),
<a name="l00577"></a>00577           value_(<a class="code" href="namespacetesting_1_1internal.html#a982df3f369643b175f79cda4048bc3b9">ImplicitCast_</a>&lt;Result&gt;(value_before_cast_)) {}
<a name="l00578"></a>00578 
<a name="l00579"></a>00579     <span class="keyword">virtual</span> Result Perform(<span class="keyword">const</span> ArgumentTuple&amp;) { <span class="keywordflow">return</span> value_; }
<a name="l00580"></a>00580 
<a name="l00581"></a>00581    <span class="keyword">private</span>:
<a name="l00582"></a>00582     <a class="code" href="gtest-port_8h.html#ae1f37dc71d5daa6fb49ca1b6047d4a8c">GTEST_COMPILE_ASSERT_</a>(!is_reference&lt;Result&gt;::value,
<a name="l00583"></a>00583                           Result_cannot_be_a_reference_type);
<a name="l00584"></a>00584     <span class="comment">// We save the value before casting just in case it is being cast to a</span>
<a name="l00585"></a>00585     <span class="comment">// wrapper type.</span>
<a name="l00586"></a>00586     R value_before_cast_;
<a name="l00587"></a>00587     Result value_;
<a name="l00588"></a>00588 
<a name="l00589"></a>00589     <a class="code" href="gtest-port_8h.html#aed8c1888c32b588b0681e88b95031e29">GTEST_DISALLOW_COPY_AND_ASSIGN_</a>(Impl);
<a name="l00590"></a>00590   };
<a name="l00591"></a>00591 
<a name="l00592"></a>00592   <span class="comment">// Partially specialize for ByMoveWrapper. This version of ReturnAction will</span>
<a name="l00593"></a>00593   <span class="comment">// move its contents instead.</span>
<a name="l00594"></a>00594   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R_, <span class="keyword">typename</span> F&gt;
<a name="l00595"></a>00595   <span class="keyword">class </span>Impl&lt;ByMoveWrapper&lt;R_&gt;, F&gt; : <span class="keyword">public</span> ActionInterface&lt;F&gt; {
<a name="l00596"></a>00596    <span class="keyword">public</span>:
<a name="l00597"></a>00597     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::Result Result;
<a name="l00598"></a>00598     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
<a name="l00599"></a>00599 
<a name="l00600"></a>00600     <span class="keyword">explicit</span> Impl(<span class="keyword">const</span> linked_ptr&lt;R&gt;&amp; wrapper)
<a name="l00601"></a>00601         : performed_(false), wrapper_(wrapper) {}
<a name="l00602"></a>00602 
<a name="l00603"></a>00603     <span class="keyword">virtual</span> Result Perform(<span class="keyword">const</span> ArgumentTuple&amp;) {
<a name="l00604"></a>00604       <a class="code" href="gtest-port_8h.html#ab54343f0a36dc4cb0ce8a478dd7847b8">GTEST_CHECK_</a>(!performed_)
<a name="l00605"></a>00605           &lt;&lt; <span class="stringliteral">&quot;A ByMove() action should only be performed once.&quot;</span>;
<a name="l00606"></a>00606       performed_ = <span class="keyword">true</span>;
<a name="l00607"></a>00607       <span class="keywordflow">return</span> <a class="code" href="namespacetesting_1_1internal.html#a0f6d06bf8c3093b9c22bb08723db201e">internal::move</a>(wrapper_-&gt;payload);
<a name="l00608"></a>00608     }
<a name="l00609"></a>00609 
<a name="l00610"></a>00610    <span class="keyword">private</span>:
<a name="l00611"></a>00611     <span class="keywordtype">bool</span> performed_;
<a name="l00612"></a>00612     <span class="keyword">const</span> linked_ptr&lt;R&gt; wrapper_;
<a name="l00613"></a>00613 
<a name="l00614"></a>00614     <a class="code" href="gtest-port_8h.html#ac593b50ce24257d5b6aa84845c344c9e">GTEST_DISALLOW_ASSIGN_</a>(Impl);
<a name="l00615"></a>00615   };
<a name="l00616"></a>00616 
<a name="l00617"></a>00617   <span class="keyword">const</span> linked_ptr&lt;R&gt; value_;
<a name="l00618"></a>00618 
<a name="l00619"></a>00619   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1ReturnAction.html#af65344e503dae3ab36b4fd6d1ede6fb7">ReturnAction</a>);
<a name="l00620"></a>00620 };
<a name="l00621"></a>00621 
<a name="l00622"></a>00622 <span class="comment">// Implements the ReturnNull() action.</span>
<a name="l00623"></a><a class="code" href="classtesting_1_1internal_1_1ReturnNullAction.html">00623</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ReturnNullAction.html">ReturnNullAction</a> {
<a name="l00624"></a>00624  <span class="keyword">public</span>:
<a name="l00625"></a>00625   <span class="comment">// Allows ReturnNull() to be used in any pointer-returning function. In C++11</span>
<a name="l00626"></a>00626   <span class="comment">// this is enforced by returning nullptr, and in non-C++11 by asserting a</span>
<a name="l00627"></a>00627   <span class="comment">// pointer type on compile time.</span>
<a name="l00628"></a>00628   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> ArgumentTuple&gt;
<a name="l00629"></a><a class="code" href="classtesting_1_1internal_1_1ReturnNullAction.html#a6ce1fba236686df93070320b399e4f32">00629</a>   <span class="keyword">static</span> Result <a class="code" href="classtesting_1_1internal_1_1ReturnNullAction.html#a6ce1fba236686df93070320b399e4f32">Perform</a>(<span class="keyword">const</span> ArgumentTuple&amp;) {
<a name="l00630"></a>00630 <span class="preprocessor">#if GTEST_LANG_CXX11</span>
<a name="l00631"></a>00631 <span class="preprocessor"></span>    <span class="keywordflow">return</span> <span class="keyword">nullptr</span>;
<a name="l00632"></a>00632 <span class="preprocessor">#else</span>
<a name="l00633"></a>00633 <span class="preprocessor"></span>    <a class="code" href="gtest-port_8h.html#ae1f37dc71d5daa6fb49ca1b6047d4a8c">GTEST_COMPILE_ASSERT_</a>(<a class="code" href="structtesting_1_1internal_1_1is__pointer.html">internal::is_pointer&lt;Result&gt;::value</a>,
<a name="l00634"></a>00634                           ReturnNull_can_be_used_to_return_a_pointer_only);
<a name="l00635"></a>00635     <span class="keywordflow">return</span> NULL;
<a name="l00636"></a>00636 <span class="preprocessor">#endif  // GTEST_LANG_CXX11</span>
<a name="l00637"></a>00637 <span class="preprocessor"></span>  }
<a name="l00638"></a>00638 };
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 <span class="comment">// Implements the Return() action.</span>
<a name="l00641"></a><a class="code" href="classtesting_1_1internal_1_1ReturnVoidAction.html">00641</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ReturnVoidAction.html">ReturnVoidAction</a> {
<a name="l00642"></a>00642  <span class="keyword">public</span>:
<a name="l00643"></a>00643   <span class="comment">// Allows Return() to be used in any void-returning function.</span>
<a name="l00644"></a>00644   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> ArgumentTuple&gt;
<a name="l00645"></a><a class="code" href="classtesting_1_1internal_1_1ReturnVoidAction.html#ab9ea50ff501225b7510a623d0f0a405e">00645</a>   <span class="keyword">static</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1internal_1_1ReturnVoidAction.html#ab9ea50ff501225b7510a623d0f0a405e">Perform</a>(<span class="keyword">const</span> ArgumentTuple&amp;) {
<a name="l00646"></a>00646     CompileAssertTypesEqual&lt;void, Result&gt;();
<a name="l00647"></a>00647   }
<a name="l00648"></a>00648 };
<a name="l00649"></a>00649 
<a name="l00650"></a>00650 <span class="comment">// Implements the polymorphic ReturnRef(x) action, which can be used</span>
<a name="l00651"></a>00651 <span class="comment">// in any function that returns a reference to the type of x,</span>
<a name="l00652"></a>00652 <span class="comment">// regardless of the argument types.</span>
<a name="l00653"></a>00653 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00654"></a><a class="code" href="classtesting_1_1internal_1_1ReturnRefAction.html">00654</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ReturnRefAction.html">ReturnRefAction</a> {
<a name="l00655"></a>00655  <span class="keyword">public</span>:
<a name="l00656"></a>00656   <span class="comment">// Constructs a ReturnRefAction object from the reference to be returned.</span>
<a name="l00657"></a><a class="code" href="classtesting_1_1internal_1_1ReturnRefAction.html#a1384b1cd78f3069f0493e2302f143701">00657</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1internal_1_1ReturnRefAction.html#a1384b1cd78f3069f0493e2302f143701">ReturnRefAction</a>(T&amp; ref) : ref_(ref) {}  <span class="comment">// NOLINT</span>
<a name="l00658"></a>00658 
<a name="l00659"></a>00659   <span class="comment">// This template type conversion operator allows ReturnRef(x) to be</span>
<a name="l00660"></a>00660   <span class="comment">// used in ANY function that returns a reference to x&#39;s type.</span>
<a name="l00661"></a>00661   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00662"></a><a class="code" href="classtesting_1_1internal_1_1ReturnRefAction.html#a7b0df67b47a9e973fd80f7e2f90ba1bc">00662</a>   <a class="code" href="classtesting_1_1internal_1_1ReturnRefAction.html#a7b0df67b47a9e973fd80f7e2f90ba1bc">operator Action&lt;F&gt;</a>()<span class="keyword"> const </span>{
<a name="l00663"></a>00663     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::Result Result;
<a name="l00664"></a>00664     <span class="comment">// Asserts that the function return type is a reference.  This</span>
<a name="l00665"></a>00665     <span class="comment">// catches the user error of using ReturnRef(x) when Return(x)</span>
<a name="l00666"></a>00666     <span class="comment">// should be used, and generates some helpful error message.</span>
<a name="l00667"></a>00667     <a class="code" href="gtest-port_8h.html#ae1f37dc71d5daa6fb49ca1b6047d4a8c">GTEST_COMPILE_ASSERT_</a>(<a class="code" href="structtesting_1_1internal_1_1is__reference.html">internal::is_reference&lt;Result&gt;::value</a>,
<a name="l00668"></a>00668                           use_Return_instead_of_ReturnRef_to_return_a_value);
<a name="l00669"></a>00669     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;F&gt;</a>(<span class="keyword">new</span> Impl&lt;F&gt;(ref_));
<a name="l00670"></a>00670   }
<a name="l00671"></a>00671 
<a name="l00672"></a>00672  <span class="keyword">private</span>:
<a name="l00673"></a>00673   <span class="comment">// Implements the ReturnRef(x) action for a particular function type F.</span>
<a name="l00674"></a>00674   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00675"></a>00675   <span class="keyword">class </span>Impl : <span class="keyword">public</span> <a class="code" href="classtesting_1_1ActionInterface.html">ActionInterface</a>&lt;F&gt; {
<a name="l00676"></a>00676    <span class="keyword">public</span>:
<a name="l00677"></a>00677     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::Result Result;
<a name="l00678"></a>00678     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
<a name="l00679"></a>00679 
<a name="l00680"></a>00680     <span class="keyword">explicit</span> Impl(T&amp; ref) : ref_(ref) {}  <span class="comment">// NOLINT</span>
<a name="l00681"></a>00681 
<a name="l00682"></a>00682     <span class="keyword">virtual</span> Result Perform(<span class="keyword">const</span> ArgumentTuple&amp;) {
<a name="l00683"></a>00683       <span class="keywordflow">return</span> ref_;
<a name="l00684"></a>00684     }
<a name="l00685"></a>00685 
<a name="l00686"></a>00686    <span class="keyword">private</span>:
<a name="l00687"></a>00687     T&amp; ref_;
<a name="l00688"></a>00688 
<a name="l00689"></a>00689     <a class="code" href="gtest-port_8h.html#ac593b50ce24257d5b6aa84845c344c9e">GTEST_DISALLOW_ASSIGN_</a>(Impl);
<a name="l00690"></a>00690   };
<a name="l00691"></a>00691 
<a name="l00692"></a>00692   T&amp; ref_;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1ReturnRefAction.html#a1384b1cd78f3069f0493e2302f143701">ReturnRefAction</a>);
<a name="l00695"></a>00695 };
<a name="l00696"></a>00696 
<a name="l00697"></a>00697 <span class="comment">// Implements the polymorphic ReturnRefOfCopy(x) action, which can be</span>
<a name="l00698"></a>00698 <span class="comment">// used in any function that returns a reference to the type of x,</span>
<a name="l00699"></a>00699 <span class="comment">// regardless of the argument types.</span>
<a name="l00700"></a>00700 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00701"></a><a class="code" href="classtesting_1_1internal_1_1ReturnRefOfCopyAction.html">00701</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ReturnRefOfCopyAction.html">ReturnRefOfCopyAction</a> {
<a name="l00702"></a>00702  <span class="keyword">public</span>:
<a name="l00703"></a>00703   <span class="comment">// Constructs a ReturnRefOfCopyAction object from the reference to</span>
<a name="l00704"></a>00704   <span class="comment">// be returned.</span>
<a name="l00705"></a><a class="code" href="classtesting_1_1internal_1_1ReturnRefOfCopyAction.html#a073c18a8b50423b08f6603e860622839">00705</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1internal_1_1ReturnRefOfCopyAction.html#a073c18a8b50423b08f6603e860622839">ReturnRefOfCopyAction</a>(<span class="keyword">const</span> T&amp; value) : value_(value) {}  <span class="comment">// NOLINT</span>
<a name="l00706"></a>00706 
<a name="l00707"></a>00707   <span class="comment">// This template type conversion operator allows ReturnRefOfCopy(x) to be</span>
<a name="l00708"></a>00708   <span class="comment">// used in ANY function that returns a reference to x&#39;s type.</span>
<a name="l00709"></a>00709   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00710"></a><a class="code" href="classtesting_1_1internal_1_1ReturnRefOfCopyAction.html#a9d7625cff3c84eedcbbf8ad976d28814">00710</a>   <a class="code" href="classtesting_1_1internal_1_1ReturnRefOfCopyAction.html#a9d7625cff3c84eedcbbf8ad976d28814">operator Action&lt;F&gt;</a>()<span class="keyword"> const </span>{
<a name="l00711"></a>00711     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::Result Result;
<a name="l00712"></a>00712     <span class="comment">// Asserts that the function return type is a reference.  This</span>
<a name="l00713"></a>00713     <span class="comment">// catches the user error of using ReturnRefOfCopy(x) when Return(x)</span>
<a name="l00714"></a>00714     <span class="comment">// should be used, and generates some helpful error message.</span>
<a name="l00715"></a>00715     <a class="code" href="gtest-port_8h.html#ae1f37dc71d5daa6fb49ca1b6047d4a8c">GTEST_COMPILE_ASSERT_</a>(
<a name="l00716"></a>00716         <a class="code" href="structtesting_1_1internal_1_1is__reference.html">internal::is_reference&lt;Result&gt;::value</a>,
<a name="l00717"></a>00717         use_Return_instead_of_ReturnRefOfCopy_to_return_a_value);
<a name="l00718"></a>00718     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;F&gt;</a>(<span class="keyword">new</span> Impl&lt;F&gt;(value_));
<a name="l00719"></a>00719   }
<a name="l00720"></a>00720 
<a name="l00721"></a>00721  <span class="keyword">private</span>:
<a name="l00722"></a>00722   <span class="comment">// Implements the ReturnRefOfCopy(x) action for a particular function type F.</span>
<a name="l00723"></a>00723   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00724"></a>00724   <span class="keyword">class </span>Impl : <span class="keyword">public</span> <a class="code" href="classtesting_1_1ActionInterface.html">ActionInterface</a>&lt;F&gt; {
<a name="l00725"></a>00725    <span class="keyword">public</span>:
<a name="l00726"></a>00726     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::Result Result;
<a name="l00727"></a>00727     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
<a name="l00728"></a>00728 
<a name="l00729"></a>00729     <span class="keyword">explicit</span> Impl(<span class="keyword">const</span> T&amp; value) : value_(value) {}  <span class="comment">// NOLINT</span>
<a name="l00730"></a>00730 
<a name="l00731"></a>00731     <span class="keyword">virtual</span> Result Perform(<span class="keyword">const</span> ArgumentTuple&amp;) {
<a name="l00732"></a>00732       <span class="keywordflow">return</span> value_;
<a name="l00733"></a>00733     }
<a name="l00734"></a>00734 
<a name="l00735"></a>00735    <span class="keyword">private</span>:
<a name="l00736"></a>00736     T value_;
<a name="l00737"></a>00737 
<a name="l00738"></a>00738     <a class="code" href="gtest-port_8h.html#ac593b50ce24257d5b6aa84845c344c9e">GTEST_DISALLOW_ASSIGN_</a>(Impl);
<a name="l00739"></a>00739   };
<a name="l00740"></a>00740 
<a name="l00741"></a>00741   <span class="keyword">const</span> T value_;
<a name="l00742"></a>00742 
<a name="l00743"></a>00743   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1ReturnRefOfCopyAction.html#a073c18a8b50423b08f6603e860622839">ReturnRefOfCopyAction</a>);
<a name="l00744"></a>00744 };
<a name="l00745"></a>00745 
<a name="l00746"></a>00746 <span class="comment">// Implements the polymorphic DoDefault() action.</span>
<a name="l00747"></a><a class="code" href="classtesting_1_1internal_1_1DoDefaultAction.html">00747</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1DoDefaultAction.html">DoDefaultAction</a> {
<a name="l00748"></a>00748  <span class="keyword">public</span>:
<a name="l00749"></a>00749   <span class="comment">// This template type conversion operator allows DoDefault() to be</span>
<a name="l00750"></a>00750   <span class="comment">// used in any function.</span>
<a name="l00751"></a>00751   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00752"></a><a class="code" href="classtesting_1_1internal_1_1DoDefaultAction.html#a3f49c529814b98a1a7037793115fbb49">00752</a>   <a class="code" href="classtesting_1_1internal_1_1DoDefaultAction.html#a3f49c529814b98a1a7037793115fbb49">operator Action&lt;F&gt;</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;F&gt;</a>(NULL); }
<a name="l00753"></a>00753 };
<a name="l00754"></a>00754 
<a name="l00755"></a>00755 <span class="comment">// Implements the Assign action to set a given pointer referent to a</span>
<a name="l00756"></a>00756 <span class="comment">// particular value.</span>
<a name="l00757"></a>00757 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l00758"></a><a class="code" href="classtesting_1_1internal_1_1AssignAction.html">00758</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1AssignAction.html">AssignAction</a> {
<a name="l00759"></a>00759  <span class="keyword">public</span>:
<a name="l00760"></a><a class="code" href="classtesting_1_1internal_1_1AssignAction.html#ae5a8fe8954ff3f8b26a08b57c3afdf9a">00760</a>   <a class="code" href="classtesting_1_1internal_1_1AssignAction.html#ae5a8fe8954ff3f8b26a08b57c3afdf9a">AssignAction</a>(T1* ptr, T2 value) : ptr_(ptr), value_(value) {}
<a name="l00761"></a>00761 
<a name="l00762"></a>00762   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> ArgumentTuple&gt;
<a name="l00763"></a><a class="code" href="classtesting_1_1internal_1_1AssignAction.html#affbedc9143889ce5ce2cc099a8d69226">00763</a>   <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1internal_1_1AssignAction.html#affbedc9143889ce5ce2cc099a8d69226">Perform</a>(<span class="keyword">const</span> ArgumentTuple&amp; <span class="comment">/* args */</span>)<span class="keyword"> const </span>{
<a name="l00764"></a>00764     *ptr_ = value_;
<a name="l00765"></a>00765   }
<a name="l00766"></a>00766 
<a name="l00767"></a>00767  <span class="keyword">private</span>:
<a name="l00768"></a>00768   T1* <span class="keyword">const</span> ptr_;
<a name="l00769"></a>00769   <span class="keyword">const</span> T2 value_;
<a name="l00770"></a>00770 
<a name="l00771"></a>00771   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1AssignAction.html">AssignAction</a>);
<a name="l00772"></a>00772 };
<a name="l00773"></a>00773 
<a name="l00774"></a>00774 <span class="preprocessor">#if !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l00775"></a>00775 <span class="preprocessor"></span>
<a name="l00776"></a>00776 <span class="comment">// Implements the SetErrnoAndReturn action to simulate return from</span>
<a name="l00777"></a>00777 <span class="comment">// various system calls and libc functions.</span>
<a name="l00778"></a>00778 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00779"></a><a class="code" href="classtesting_1_1internal_1_1SetErrnoAndReturnAction.html">00779</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1SetErrnoAndReturnAction.html">SetErrnoAndReturnAction</a> {
<a name="l00780"></a>00780  <span class="keyword">public</span>:
<a name="l00781"></a><a class="code" href="classtesting_1_1internal_1_1SetErrnoAndReturnAction.html#abfe5a194a9b8f2b303c635ad99b3a257">00781</a>   <a class="code" href="classtesting_1_1internal_1_1SetErrnoAndReturnAction.html#abfe5a194a9b8f2b303c635ad99b3a257">SetErrnoAndReturnAction</a>(<span class="keywordtype">int</span> errno_value, T result)
<a name="l00782"></a>00782       : errno_(errno_value),
<a name="l00783"></a>00783         result_(result) {}
<a name="l00784"></a>00784   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> ArgumentTuple&gt;
<a name="l00785"></a><a class="code" href="classtesting_1_1internal_1_1SetErrnoAndReturnAction.html#aced34306c80406663b57465f85ef70a9">00785</a>   Result <a class="code" href="classtesting_1_1internal_1_1SetErrnoAndReturnAction.html#aced34306c80406663b57465f85ef70a9">Perform</a>(<span class="keyword">const</span> ArgumentTuple&amp; <span class="comment">/* args */</span>)<span class="keyword"> const </span>{
<a name="l00786"></a>00786     errno = errno_;
<a name="l00787"></a>00787     <span class="keywordflow">return</span> result_;
<a name="l00788"></a>00788   }
<a name="l00789"></a>00789 
<a name="l00790"></a>00790  <span class="keyword">private</span>:
<a name="l00791"></a>00791   <span class="keyword">const</span> <span class="keywordtype">int</span> errno_;
<a name="l00792"></a>00792   <span class="keyword">const</span> T result_;
<a name="l00793"></a>00793 
<a name="l00794"></a>00794   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1SetErrnoAndReturnAction.html">SetErrnoAndReturnAction</a>);
<a name="l00795"></a>00795 };
<a name="l00796"></a>00796 
<a name="l00797"></a>00797 <span class="preprocessor">#endif  // !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l00798"></a>00798 <span class="preprocessor"></span>
<a name="l00799"></a>00799 <span class="comment">// Implements the SetArgumentPointee&lt;N&gt;(x) action for any function</span>
<a name="l00800"></a>00800 <span class="comment">// whose N-th argument (0-based) is a pointer to x&#39;s type.  The</span>
<a name="l00801"></a>00801 <span class="comment">// template parameter kIsProto is true iff type A is ProtocolMessage,</span>
<a name="l00802"></a>00802 <span class="comment">// proto2::Message, or a sub-class of those.</span>
<a name="l00803"></a>00803 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> N, <span class="keyword">typename</span> A, <span class="keywordtype">bool</span> kIsProto&gt;
<a name="l00804"></a><a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html">00804</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html">SetArgumentPointeeAction</a> {
<a name="l00805"></a>00805  <span class="keyword">public</span>:
<a name="l00806"></a>00806   <span class="comment">// Constructs an action that sets the variable pointed to by the</span>
<a name="l00807"></a>00807   <span class="comment">// N-th function argument to &#39;value&#39;.</span>
<a name="l00808"></a><a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html#a5a4119ed113667bd4a003ab0bec2cdff">00808</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html#a5a4119ed113667bd4a003ab0bec2cdff">SetArgumentPointeeAction</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting.html#a5e9134d655d2fc9323902348083282e7">A</a>&amp; value) : value_(value) {}
<a name="l00809"></a>00809 
<a name="l00810"></a>00810   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> ArgumentTuple&gt;
<a name="l00811"></a><a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html#a2bb0bc420cbd3d742853c1a4dab00b15">00811</a>   <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html#a2bb0bc420cbd3d742853c1a4dab00b15">Perform</a>(<span class="keyword">const</span> ArgumentTuple&amp; args)<span class="keyword"> const </span>{
<a name="l00812"></a>00812     CompileAssertTypesEqual&lt;void, Result&gt;();
<a name="l00813"></a>00813     *::testing::get&lt;N&gt;(args) = value_;
<a name="l00814"></a>00814   }
<a name="l00815"></a>00815 
<a name="l00816"></a>00816  <span class="keyword">private</span>:
<a name="l00817"></a>00817   <span class="keyword">const</span> <a class="code" href="namespacetesting.html#a5e9134d655d2fc9323902348083282e7">A</a> value_;
<a name="l00818"></a>00818 
<a name="l00819"></a>00819   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html">SetArgumentPointeeAction</a>);
<a name="l00820"></a>00820 };
<a name="l00821"></a>00821 
<a name="l00822"></a>00822 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> N, <span class="keyword">typename</span> Proto&gt;
<a name="l00823"></a><a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction_3_01N_00_01Proto_00_01true_01_4.html">00823</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html">SetArgumentPointeeAction</a>&lt;N, Proto, true&gt; {
<a name="l00824"></a>00824  <span class="keyword">public</span>:
<a name="l00825"></a>00825   <span class="comment">// Constructs an action that sets the variable pointed to by the</span>
<a name="l00826"></a>00826   <span class="comment">// N-th function argument to &#39;proto&#39;.  Both ProtocolMessage and</span>
<a name="l00827"></a>00827   <span class="comment">// proto2::Message have the CopyFrom() method, so the same</span>
<a name="l00828"></a>00828   <span class="comment">// implementation works for both.</span>
<a name="l00829"></a><a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction_3_01N_00_01Proto_00_01true_01_4.html#af08b3a61e483f704e93872987d30ade0">00829</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction_3_01N_00_01Proto_00_01true_01_4.html#af08b3a61e483f704e93872987d30ade0">SetArgumentPointeeAction</a>(<span class="keyword">const</span> Proto&amp; proto) : proto_(new Proto) {
<a name="l00830"></a>00830     proto_-&gt;CopyFrom(proto);
<a name="l00831"></a>00831   }
<a name="l00832"></a>00832 
<a name="l00833"></a>00833   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> ArgumentTuple&gt;
<a name="l00834"></a><a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction_3_01N_00_01Proto_00_01true_01_4.html#a77f33bf36443aba70e77d515b162ae24">00834</a>   <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction_3_01N_00_01Proto_00_01true_01_4.html#a77f33bf36443aba70e77d515b162ae24">Perform</a>(<span class="keyword">const</span> ArgumentTuple&amp; args)<span class="keyword"> const </span>{
<a name="l00835"></a>00835     CompileAssertTypesEqual&lt;void, Result&gt;();
<a name="l00836"></a>00836     ::testing::get&lt;N&gt;(args)-&gt;CopyFrom(*proto_);
<a name="l00837"></a>00837   }
<a name="l00838"></a>00838 
<a name="l00839"></a>00839  <span class="keyword">private</span>:
<a name="l00840"></a>00840   <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1linked__ptr.html">internal::linked_ptr&lt;Proto&gt;</a> proto_;
<a name="l00841"></a>00841 
<a name="l00842"></a>00842   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html">SetArgumentPointeeAction</a>);
<a name="l00843"></a>00843 };
<a name="l00844"></a>00844 
<a name="l00845"></a>00845 <span class="comment">// Implements the InvokeWithoutArgs(f) action.  The template argument</span>
<a name="l00846"></a>00846 <span class="comment">// FunctionImpl is the implementation type of f, which can be either a</span>
<a name="l00847"></a>00847 <span class="comment">// function pointer or a functor.  InvokeWithoutArgs(f) can be used as an</span>
<a name="l00848"></a>00848 <span class="comment">// Action&lt;F&gt; as long as f&#39;s type is compatible with F (i.e. f can be</span>
<a name="l00849"></a>00849 <span class="comment">// assigned to a tr1::function&lt;F&gt;).</span>
<a name="l00850"></a>00850 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctionImpl&gt;
<a name="l00851"></a><a class="code" href="classtesting_1_1internal_1_1InvokeWithoutArgsAction.html">00851</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1InvokeWithoutArgsAction.html">InvokeWithoutArgsAction</a> {
<a name="l00852"></a>00852  <span class="keyword">public</span>:
<a name="l00853"></a>00853   <span class="comment">// The c&#39;tor makes a copy of function_impl (either a function</span>
<a name="l00854"></a>00854   <span class="comment">// pointer or a functor).</span>
<a name="l00855"></a><a class="code" href="classtesting_1_1internal_1_1InvokeWithoutArgsAction.html#a05d4006d8ab70e78172bf678b1d15f18">00855</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1internal_1_1InvokeWithoutArgsAction.html#a05d4006d8ab70e78172bf678b1d15f18">InvokeWithoutArgsAction</a>(FunctionImpl function_impl)
<a name="l00856"></a>00856       : function_impl_(function_impl) {}
<a name="l00857"></a>00857 
<a name="l00858"></a>00858   <span class="comment">// Allows InvokeWithoutArgs(f) to be used as any action whose type is</span>
<a name="l00859"></a>00859   <span class="comment">// compatible with f.</span>
<a name="l00860"></a>00860   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> ArgumentTuple&gt;
<a name="l00861"></a><a class="code" href="classtesting_1_1internal_1_1InvokeWithoutArgsAction.html#abdad2b7d19ff1cbd1d07a4bd585e3f4c">00861</a>   Result <a class="code" href="classtesting_1_1internal_1_1InvokeWithoutArgsAction.html#abdad2b7d19ff1cbd1d07a4bd585e3f4c">Perform</a>(<span class="keyword">const</span> ArgumentTuple&amp;) { <span class="keywordflow">return</span> function_impl_(); }
<a name="l00862"></a>00862 
<a name="l00863"></a>00863  <span class="keyword">private</span>:
<a name="l00864"></a>00864   FunctionImpl function_impl_;
<a name="l00865"></a>00865 
<a name="l00866"></a>00866   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1InvokeWithoutArgsAction.html">InvokeWithoutArgsAction</a>);
<a name="l00867"></a>00867 };
<a name="l00868"></a>00868 
<a name="l00869"></a>00869 <span class="comment">// Implements the InvokeWithoutArgs(object_ptr, &amp;Class::Method) action.</span>
<a name="l00870"></a>00870 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Class, <span class="keyword">typename</span> MethodPtr&gt;
<a name="l00871"></a><a class="code" href="classtesting_1_1internal_1_1InvokeMethodWithoutArgsAction.html">00871</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1InvokeMethodWithoutArgsAction.html">InvokeMethodWithoutArgsAction</a> {
<a name="l00872"></a>00872  <span class="keyword">public</span>:
<a name="l00873"></a><a class="code" href="classtesting_1_1internal_1_1InvokeMethodWithoutArgsAction.html#ac4d655e386f47a96c7a6e1670b20e991">00873</a>   <a class="code" href="classtesting_1_1internal_1_1InvokeMethodWithoutArgsAction.html#ac4d655e386f47a96c7a6e1670b20e991">InvokeMethodWithoutArgsAction</a>(Class* obj_ptr, MethodPtr method_ptr)
<a name="l00874"></a>00874       : obj_ptr_(obj_ptr), method_ptr_(method_ptr) {}
<a name="l00875"></a>00875 
<a name="l00876"></a>00876   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Result, <span class="keyword">typename</span> ArgumentTuple&gt;
<a name="l00877"></a><a class="code" href="classtesting_1_1internal_1_1InvokeMethodWithoutArgsAction.html#ad33ed69b4b6aade57c8b51ae41dfe276">00877</a>   Result <a class="code" href="classtesting_1_1internal_1_1InvokeMethodWithoutArgsAction.html#ad33ed69b4b6aade57c8b51ae41dfe276">Perform</a>(<span class="keyword">const</span> ArgumentTuple&amp;)<span class="keyword"> const </span>{
<a name="l00878"></a>00878     <span class="keywordflow">return</span> (obj_ptr_-&gt;*method_ptr_)();
<a name="l00879"></a>00879   }
<a name="l00880"></a>00880 
<a name="l00881"></a>00881  <span class="keyword">private</span>:
<a name="l00882"></a>00882   Class* <span class="keyword">const</span> obj_ptr_;
<a name="l00883"></a>00883   <span class="keyword">const</span> MethodPtr method_ptr_;
<a name="l00884"></a>00884 
<a name="l00885"></a>00885   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1InvokeMethodWithoutArgsAction.html">InvokeMethodWithoutArgsAction</a>);
<a name="l00886"></a>00886 };
<a name="l00887"></a>00887 
<a name="l00888"></a>00888 <span class="comment">// Implements the IgnoreResult(action) action.</span>
<a name="l00889"></a>00889 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> A&gt;
<a name="l00890"></a><a class="code" href="classtesting_1_1internal_1_1IgnoreResultAction.html">00890</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1IgnoreResultAction.html">IgnoreResultAction</a> {
<a name="l00891"></a>00891  <span class="keyword">public</span>:
<a name="l00892"></a><a class="code" href="classtesting_1_1internal_1_1IgnoreResultAction.html#a9199f7b1b7771b2e2a5fd28caf624623">00892</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1internal_1_1IgnoreResultAction.html#a9199f7b1b7771b2e2a5fd28caf624623">IgnoreResultAction</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting.html#a5e9134d655d2fc9323902348083282e7">A</a>&amp; action) : action_(action) {}
<a name="l00893"></a>00893 
<a name="l00894"></a>00894   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00895"></a><a class="code" href="classtesting_1_1internal_1_1IgnoreResultAction.html#a95b6a067a3b2fa43ab229b695f5cb4d2">00895</a>   <a class="code" href="classtesting_1_1internal_1_1IgnoreResultAction.html#a95b6a067a3b2fa43ab229b695f5cb4d2">operator Action&lt;F&gt;</a>()<span class="keyword"> const </span>{
<a name="l00896"></a>00896     <span class="comment">// Assert statement belongs here because this is the best place to verify</span>
<a name="l00897"></a>00897     <span class="comment">// conditions on F. It produces the clearest error messages</span>
<a name="l00898"></a>00898     <span class="comment">// in most compilers.</span>
<a name="l00899"></a>00899     <span class="comment">// Impl really belongs in this scope as a local class but can&#39;t</span>
<a name="l00900"></a>00900     <span class="comment">// because MSVC produces duplicate symbols in different translation units</span>
<a name="l00901"></a>00901     <span class="comment">// in this case. Until MS fixes that bug we put Impl into the class scope</span>
<a name="l00902"></a>00902     <span class="comment">// and put the typedef both here (for use in assert statement) and</span>
<a name="l00903"></a>00903     <span class="comment">// in the Impl class. But both definitions must be the same.</span>
<a name="l00904"></a>00904     <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::Function&lt;F&gt;::Result Result;
<a name="l00905"></a>00905 
<a name="l00906"></a>00906     <span class="comment">// Asserts at compile time that F returns void.</span>
<a name="l00907"></a>00907     CompileAssertTypesEqual&lt;void, Result&gt;();
<a name="l00908"></a>00908 
<a name="l00909"></a>00909     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;F&gt;</a>(<span class="keyword">new</span> Impl&lt;F&gt;(action_));
<a name="l00910"></a>00910   }
<a name="l00911"></a>00911 
<a name="l00912"></a>00912  <span class="keyword">private</span>:
<a name="l00913"></a>00913   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00914"></a>00914   <span class="keyword">class </span>Impl : <span class="keyword">public</span> <a class="code" href="classtesting_1_1ActionInterface.html">ActionInterface</a>&lt;F&gt; {
<a name="l00915"></a>00915    <span class="keyword">public</span>:
<a name="l00916"></a>00916     <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::Function&lt;F&gt;::Result Result;
<a name="l00917"></a>00917     <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
<a name="l00918"></a>00918 
<a name="l00919"></a>00919     <span class="keyword">explicit</span> Impl(<span class="keyword">const</span> <a class="code" href="namespacetesting.html#a5e9134d655d2fc9323902348083282e7">A</a>&amp; action) : action_(action) {}
<a name="l00920"></a>00920 
<a name="l00921"></a>00921     <span class="keyword">virtual</span> <span class="keywordtype">void</span> Perform(<span class="keyword">const</span> ArgumentTuple&amp; args) {
<a name="l00922"></a>00922       <span class="comment">// Performs the action and ignores its result.</span>
<a name="l00923"></a>00923       action_.Perform(args);
<a name="l00924"></a>00924     }
<a name="l00925"></a>00925 
<a name="l00926"></a>00926    <span class="keyword">private</span>:
<a name="l00927"></a>00927     <span class="comment">// Type OriginalFunction is the same as F except that its return</span>
<a name="l00928"></a>00928     <span class="comment">// type is IgnoredValue.</span>
<a name="l00929"></a>00929     <span class="keyword">typedef</span> <span class="keyword">typename</span> internal::Function&lt;F&gt;::MakeResultIgnoredValue
<a name="l00930"></a>00930         OriginalFunction;
<a name="l00931"></a>00931 
<a name="l00932"></a>00932     <span class="keyword">const</span> Action&lt;OriginalFunction&gt; action_;
<a name="l00933"></a>00933 
<a name="l00934"></a>00934     <a class="code" href="gtest-port_8h.html#ac593b50ce24257d5b6aa84845c344c9e">GTEST_DISALLOW_ASSIGN_</a>(Impl);
<a name="l00935"></a>00935   };
<a name="l00936"></a>00936 
<a name="l00937"></a>00937   <span class="keyword">const</span> <a class="code" href="namespacetesting.html#a5e9134d655d2fc9323902348083282e7">A</a> action_;
<a name="l00938"></a>00938 
<a name="l00939"></a>00939   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1IgnoreResultAction.html#a9199f7b1b7771b2e2a5fd28caf624623">IgnoreResultAction</a>);
<a name="l00940"></a>00940 };
<a name="l00941"></a>00941 
<a name="l00942"></a>00942 <span class="comment">// A ReferenceWrapper&lt;T&gt; object represents a reference to type T,</span>
<a name="l00943"></a>00943 <span class="comment">// which can be either const or not.  It can be explicitly converted</span>
<a name="l00944"></a>00944 <span class="comment">// from, and implicitly converted to, a T&amp;.  Unlike a reference,</span>
<a name="l00945"></a>00945 <span class="comment">// ReferenceWrapper&lt;T&gt; can be copied and can survive template type</span>
<a name="l00946"></a>00946 <span class="comment">// inference.  This is used to support by-reference arguments in the</span>
<a name="l00947"></a>00947 <span class="comment">// InvokeArgument&lt;N&gt;(...) action.  The idea was from &quot;reference</span>
<a name="l00948"></a>00948 <span class="comment">// wrappers&quot; in tr1, which we don&#39;t have in our source tree yet.</span>
<a name="l00949"></a>00949 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00950"></a><a class="code" href="classtesting_1_1internal_1_1ReferenceWrapper.html">00950</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ReferenceWrapper.html">ReferenceWrapper</a> {
<a name="l00951"></a>00951  <span class="keyword">public</span>:
<a name="l00952"></a>00952   <span class="comment">// Constructs a ReferenceWrapper&lt;T&gt; object from a T&amp;.</span>
<a name="l00953"></a><a class="code" href="classtesting_1_1internal_1_1ReferenceWrapper.html#ad33597ffc478c3af9190d1a288a76d39">00953</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1internal_1_1ReferenceWrapper.html#ad33597ffc478c3af9190d1a288a76d39">ReferenceWrapper</a>(T&amp; l_value) : pointer_(&amp;l_value) {}  <span class="comment">// NOLINT</span>
<a name="l00954"></a>00954 
<a name="l00955"></a>00955   <span class="comment">// Allows a ReferenceWrapper&lt;T&gt; object to be implicitly converted to</span>
<a name="l00956"></a>00956   <span class="comment">// a T&amp;.</span>
<a name="l00957"></a><a class="code" href="classtesting_1_1internal_1_1ReferenceWrapper.html#ac9a45f88ba592f05b0c0c90103812872">00957</a>   <a class="code" href="classtesting_1_1internal_1_1ReferenceWrapper.html#ac9a45f88ba592f05b0c0c90103812872">operator T&amp;</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> *pointer_; }
<a name="l00958"></a>00958  <span class="keyword">private</span>:
<a name="l00959"></a>00959   T* pointer_;
<a name="l00960"></a>00960 };
<a name="l00961"></a>00961 
<a name="l00962"></a>00962 <span class="comment">// Allows the expression ByRef(x) to be printed as a reference to x.</span>
<a name="l00963"></a>00963 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00964"></a><a class="code" href="namespacetesting_1_1internal.html#a880d891d434f918b29a382f90e47cecb">00964</a> <span class="keywordtype">void</span> <a class="code" href="namespacetesting_1_1internal.html#a880d891d434f918b29a382f90e47cecb">PrintTo</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1ReferenceWrapper.html">ReferenceWrapper&lt;T&gt;</a>&amp; ref, ::std::ostream* os) {
<a name="l00965"></a>00965   T&amp; value = ref;
<a name="l00966"></a>00966   <a class="code" href="classtesting_1_1internal_1_1UniversalPrinter.html#a6a7d29444412467c14931bc55a046138">UniversalPrinter&lt;T&amp;&gt;::Print</a>(value, os);
<a name="l00967"></a>00967 }
<a name="l00968"></a>00968 
<a name="l00969"></a>00969 <span class="comment">// Does two actions sequentially.  Used for implementing the DoAll(a1,</span>
<a name="l00970"></a>00970 <span class="comment">// a2, ...) action.</span>
<a name="l00971"></a>00971 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> Action1, <span class="keyword">typename</span> Action2&gt;
<a name="l00972"></a><a class="code" href="classtesting_1_1internal_1_1DoBothAction.html">00972</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1DoBothAction.html">DoBothAction</a> {
<a name="l00973"></a>00973  <span class="keyword">public</span>:
<a name="l00974"></a><a class="code" href="classtesting_1_1internal_1_1DoBothAction.html#a55727c4dbdc1816ba6f1fe124e96088b">00974</a>   <a class="code" href="classtesting_1_1internal_1_1DoBothAction.html#a55727c4dbdc1816ba6f1fe124e96088b">DoBothAction</a>(Action1 action1, Action2 action2)
<a name="l00975"></a>00975       : action1_(action1), action2_(action2) {}
<a name="l00976"></a>00976 
<a name="l00977"></a>00977   <span class="comment">// This template type conversion operator allows DoAll(a1, ..., a_n)</span>
<a name="l00978"></a>00978   <span class="comment">// to be used in ANY function of compatible type.</span>
<a name="l00979"></a>00979   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00980"></a><a class="code" href="classtesting_1_1internal_1_1DoBothAction.html#a5e416375c3d61b268d27cf594c135344">00980</a>   <a class="code" href="classtesting_1_1internal_1_1DoBothAction.html#a5e416375c3d61b268d27cf594c135344">operator Action&lt;F&gt;</a>()<span class="keyword"> const </span>{
<a name="l00981"></a>00981     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;F&gt;</a>(<span class="keyword">new</span> Impl&lt;F&gt;(action1_, action2_));
<a name="l00982"></a>00982   }
<a name="l00983"></a>00983 
<a name="l00984"></a>00984  <span class="keyword">private</span>:
<a name="l00985"></a>00985   <span class="comment">// Implements the DoAll(...) action for a particular function type F.</span>
<a name="l00986"></a>00986   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> F&gt;
<a name="l00987"></a>00987   <span class="keyword">class </span>Impl : <span class="keyword">public</span> <a class="code" href="classtesting_1_1ActionInterface.html">ActionInterface</a>&lt;F&gt; {
<a name="l00988"></a>00988    <span class="keyword">public</span>:
<a name="l00989"></a>00989     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::Result Result;
<a name="l00990"></a>00990     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::ArgumentTuple ArgumentTuple;
<a name="l00991"></a>00991     <span class="keyword">typedef</span> <span class="keyword">typename</span> Function&lt;F&gt;::MakeResultVoid VoidResult;
<a name="l00992"></a>00992 
<a name="l00993"></a>00993     Impl(<span class="keyword">const</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;VoidResult&gt;</a>&amp; action1, <span class="keyword">const</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;F&gt;</a>&amp; action2)
<a name="l00994"></a>00994         : action1_(action1), action2_(action2) {}
<a name="l00995"></a>00995 
<a name="l00996"></a>00996     <span class="keyword">virtual</span> Result Perform(<span class="keyword">const</span> ArgumentTuple&amp; args) {
<a name="l00997"></a>00997       action1_.Perform(args);
<a name="l00998"></a>00998       <span class="keywordflow">return</span> action2_.Perform(args);
<a name="l00999"></a>00999     }
<a name="l01000"></a>01000 
<a name="l01001"></a>01001    <span class="keyword">private</span>:
<a name="l01002"></a>01002     <span class="keyword">const</span> Action&lt;VoidResult&gt; action1_;
<a name="l01003"></a>01003     <span class="keyword">const</span> Action&lt;F&gt; action2_;
<a name="l01004"></a>01004 
<a name="l01005"></a>01005     <a class="code" href="gtest-port_8h.html#ac593b50ce24257d5b6aa84845c344c9e">GTEST_DISALLOW_ASSIGN_</a>(Impl);
<a name="l01006"></a>01006   };
<a name="l01007"></a>01007 
<a name="l01008"></a>01008   Action1 action1_;
<a name="l01009"></a>01009   Action2 action2_;
<a name="l01010"></a>01010 
<a name="l01011"></a>01011   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1DoBothAction.html#a55727c4dbdc1816ba6f1fe124e96088b">DoBothAction</a>);
<a name="l01012"></a>01012 };
<a name="l01013"></a>01013 
<a name="l01014"></a>01014 }  <span class="comment">// namespace internal</span>
<a name="l01015"></a>01015 
<a name="l01016"></a>01016 <span class="comment">// An Unused object can be implicitly constructed from ANY value.</span>
<a name="l01017"></a>01017 <span class="comment">// This is handy when defining actions that ignore some or all of the</span>
<a name="l01018"></a>01018 <span class="comment">// mock function arguments.  For example, given</span>
<a name="l01019"></a>01019 <span class="comment">//</span>
<a name="l01020"></a>01020 <span class="comment">//   MOCK_METHOD3(Foo, double(const string&amp; label, double x, double y));</span>
<a name="l01021"></a>01021 <span class="comment">//   MOCK_METHOD3(Bar, double(int index, double x, double y));</span>
<a name="l01022"></a>01022 <span class="comment">//</span>
<a name="l01023"></a>01023 <span class="comment">// instead of</span>
<a name="l01024"></a>01024 <span class="comment">//</span>
<a name="l01025"></a>01025 <span class="comment">//   double DistanceToOriginWithLabel(const string&amp; label, double x, double y) {</span>
<a name="l01026"></a>01026 <span class="comment">//     return sqrt(x*x + y*y);</span>
<a name="l01027"></a>01027 <span class="comment">//   }</span>
<a name="l01028"></a>01028 <span class="comment">//   double DistanceToOriginWithIndex(int index, double x, double y) {</span>
<a name="l01029"></a>01029 <span class="comment">//     return sqrt(x*x + y*y);</span>
<a name="l01030"></a>01030 <span class="comment">//   }</span>
<a name="l01031"></a>01031 <span class="comment">//   ...</span>
<a name="l01032"></a>01032 <span class="comment">//   EXEPCT_CALL(mock, Foo(&quot;abc&quot;, _, _))</span>
<a name="l01033"></a>01033 <span class="comment">//       .WillOnce(Invoke(DistanceToOriginWithLabel));</span>
<a name="l01034"></a>01034 <span class="comment">//   EXEPCT_CALL(mock, Bar(5, _, _))</span>
<a name="l01035"></a>01035 <span class="comment">//       .WillOnce(Invoke(DistanceToOriginWithIndex));</span>
<a name="l01036"></a>01036 <span class="comment">//</span>
<a name="l01037"></a>01037 <span class="comment">// you could write</span>
<a name="l01038"></a>01038 <span class="comment">//</span>
<a name="l01039"></a>01039 <span class="comment">//   // We can declare any uninteresting argument as Unused.</span>
<a name="l01040"></a>01040 <span class="comment">//   double DistanceToOrigin(Unused, double x, double y) {</span>
<a name="l01041"></a>01041 <span class="comment">//     return sqrt(x*x + y*y);</span>
<a name="l01042"></a>01042 <span class="comment">//   }</span>
<a name="l01043"></a>01043 <span class="comment">//   ...</span>
<a name="l01044"></a>01044 <span class="comment">//   EXEPCT_CALL(mock, Foo(&quot;abc&quot;, _, _)).WillOnce(Invoke(DistanceToOrigin));</span>
<a name="l01045"></a>01045 <span class="comment">//   EXEPCT_CALL(mock, Bar(5, _, _)).WillOnce(Invoke(DistanceToOrigin));</span>
<a name="l01046"></a><a class="code" href="namespacetesting.html#a603e329ec0263ebfcf16f712810bd511">01046</a> <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1IgnoredValue.html">internal::IgnoredValue</a> <a class="code" href="namespacetesting.html#a603e329ec0263ebfcf16f712810bd511">Unused</a>;
<a name="l01047"></a>01047 
<a name="l01048"></a>01048 <span class="comment">// This constructor allows us to turn an Action&lt;From&gt; object into an</span>
<a name="l01049"></a>01049 <span class="comment">// Action&lt;To&gt;, as long as To&#39;s arguments can be implicitly converted</span>
<a name="l01050"></a>01050 <span class="comment">// to From&#39;s and From&#39;s return type cann be implicitly converted to</span>
<a name="l01051"></a>01051 <span class="comment">// To&#39;s.</span>
<a name="l01052"></a>01052 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> To&gt;
<a name="l01053"></a>01053 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> From&gt;
<a name="l01054"></a><a class="code" href="classtesting_1_1Action.html#af23eef2fff5a92d8ff2ed7ac7a542005">01054</a> <a class="code" href="classtesting_1_1Action.html#a967772922a39dd7098bee429d749f277">Action&lt;To&gt;::Action</a>(<span class="keyword">const</span> <a class="code" href="classtesting_1_1Action.html">Action&lt;From&gt;</a>&amp; from)
<a name="l01055"></a>01055     : impl_(new internal::ActionAdaptor&lt;To, From&gt;(from)) {}
<a name="l01056"></a>01056 
<a name="l01057"></a>01057 <span class="comment">// Creates an action that returns &#39;value&#39;.  &#39;value&#39; is passed by value</span>
<a name="l01058"></a>01058 <span class="comment">// instead of const reference - otherwise Return(&quot;string literal&quot;)</span>
<a name="l01059"></a>01059 <span class="comment">// will trigger a compiler error about using array as initializer.</span>
<a name="l01060"></a>01060 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;
<a name="l01061"></a><a class="code" href="namespacetesting.html#af6d1c13e9376c77671e37545cd84359c">01061</a> <a class="code" href="classtesting_1_1internal_1_1ReturnAction.html">internal::ReturnAction&lt;R&gt;</a> <a class="code" href="namespacetesting.html#af6d1c13e9376c77671e37545cd84359c">Return</a>(R value) {
<a name="l01062"></a>01062   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ReturnAction.html">internal::ReturnAction&lt;R&gt;</a>(<a class="code" href="namespacetesting_1_1internal.html#a0f6d06bf8c3093b9c22bb08723db201e">internal::move</a>(value));
<a name="l01063"></a>01063 }
<a name="l01064"></a>01064 
<a name="l01065"></a>01065 <span class="comment">// Creates an action that returns NULL.</span>
<a name="l01066"></a><a class="code" href="namespacetesting.html#aa0331596e269114da101f810d3a1b88b">01066</a> <span class="keyword">inline</span> <a class="code" href="classtesting_1_1PolymorphicAction.html">PolymorphicAction&lt;internal::ReturnNullAction&gt;</a> <a class="code" href="namespacetesting.html#aa0331596e269114da101f810d3a1b88b">ReturnNull</a>() {
<a name="l01067"></a>01067   <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a36bd06c5ea972c6df0bd9f40a7a94c65">MakePolymorphicAction</a>(<a class="code" href="classtesting_1_1internal_1_1ReturnNullAction.html">internal::ReturnNullAction</a>());
<a name="l01068"></a>01068 }
<a name="l01069"></a>01069 
<a name="l01070"></a>01070 <span class="comment">// Creates an action that returns from a void function.</span>
<a name="l01071"></a><a class="code" href="namespacetesting.html#a8da8e53d2e7bc4e3c531f7435ad04823">01071</a> <span class="keyword">inline</span> <a class="code" href="classtesting_1_1PolymorphicAction.html">PolymorphicAction&lt;internal::ReturnVoidAction&gt;</a> <a class="code" href="namespacetesting.html#af6d1c13e9376c77671e37545cd84359c">Return</a>() {
<a name="l01072"></a>01072   <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a36bd06c5ea972c6df0bd9f40a7a94c65">MakePolymorphicAction</a>(<a class="code" href="classtesting_1_1internal_1_1ReturnVoidAction.html">internal::ReturnVoidAction</a>());
<a name="l01073"></a>01073 }
<a name="l01074"></a>01074 
<a name="l01075"></a>01075 <span class="comment">// Creates an action that returns the reference to a variable.</span>
<a name="l01076"></a>01076 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;
<a name="l01077"></a><a class="code" href="namespacetesting.html#a18eda8fe9c89ee856c199a2e04ca1641">01077</a> <span class="keyword">inline</span> <a class="code" href="classtesting_1_1internal_1_1ReturnRefAction.html">internal::ReturnRefAction&lt;R&gt;</a> <a class="code" href="namespacetesting.html#a18eda8fe9c89ee856c199a2e04ca1641">ReturnRef</a>(R&amp; x) {  <span class="comment">// NOLINT</span>
<a name="l01078"></a>01078   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ReturnRefAction.html">internal::ReturnRefAction&lt;R&gt;</a>(x);
<a name="l01079"></a>01079 }
<a name="l01080"></a>01080 
<a name="l01081"></a>01081 <span class="comment">// Creates an action that returns the reference to a copy of the</span>
<a name="l01082"></a>01082 <span class="comment">// argument.  The copy is created when the action is constructed and</span>
<a name="l01083"></a>01083 <span class="comment">// lives as long as the action.</span>
<a name="l01084"></a>01084 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;
<a name="l01085"></a><a class="code" href="namespacetesting.html#ac1b75444c89371dc25ebcfcc48336201">01085</a> <span class="keyword">inline</span> <a class="code" href="classtesting_1_1internal_1_1ReturnRefOfCopyAction.html">internal::ReturnRefOfCopyAction&lt;R&gt;</a> <a class="code" href="namespacetesting.html#ac1b75444c89371dc25ebcfcc48336201">ReturnRefOfCopy</a>(<span class="keyword">const</span> R&amp; x) {
<a name="l01086"></a>01086   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ReturnRefOfCopyAction.html">internal::ReturnRefOfCopyAction&lt;R&gt;</a>(x);
<a name="l01087"></a>01087 }
<a name="l01088"></a>01088 
<a name="l01089"></a>01089 <span class="comment">// Modifies the parent action (a Return() action) to perform a move of the</span>
<a name="l01090"></a>01090 <span class="comment">// argument instead of a copy.</span>
<a name="l01091"></a>01091 <span class="comment">// Return(ByMove()) actions can only be executed once and will assert this</span>
<a name="l01092"></a>01092 <span class="comment">// invariant.</span>
<a name="l01093"></a>01093 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> R&gt;
<a name="l01094"></a><a class="code" href="namespacetesting.html#acaa432211a3aec62e3d0f24b47bd2dae">01094</a> <a class="code" href="structtesting_1_1internal_1_1ByMoveWrapper.html">internal::ByMoveWrapper&lt;R&gt;</a> <a class="code" href="namespacetesting.html#acaa432211a3aec62e3d0f24b47bd2dae">ByMove</a>(R x) {
<a name="l01095"></a>01095   <span class="keywordflow">return</span> <a class="code" href="structtesting_1_1internal_1_1ByMoveWrapper.html">internal::ByMoveWrapper&lt;R&gt;</a>(<a class="code" href="namespacetesting_1_1internal.html#a0f6d06bf8c3093b9c22bb08723db201e">internal::move</a>(x));
<a name="l01096"></a>01096 }
<a name="l01097"></a>01097 
<a name="l01098"></a>01098 <span class="comment">// Creates an action that does the default action for the give mock function.</span>
<a name="l01099"></a><a class="code" href="namespacetesting.html#ae041df61ff61ccb9753ba15b4309e1a6">01099</a> <span class="keyword">inline</span> <a class="code" href="classtesting_1_1internal_1_1DoDefaultAction.html">internal::DoDefaultAction</a> <a class="code" href="namespacetesting.html#ae041df61ff61ccb9753ba15b4309e1a6">DoDefault</a>() {
<a name="l01100"></a>01100   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1DoDefaultAction.html">internal::DoDefaultAction</a>();
<a name="l01101"></a>01101 }
<a name="l01102"></a>01102 
<a name="l01103"></a>01103 <span class="comment">// Creates an action that sets the variable pointed by the N-th</span>
<a name="l01104"></a>01104 <span class="comment">// (0-based) function argument to &#39;value&#39;.</span>
<a name="l01105"></a>01105 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> N, <span class="keyword">typename</span> T&gt;
<a name="l01106"></a>01106 PolymorphicAction&lt;
<a name="l01107"></a>01107   internal::SetArgumentPointeeAction&lt;
<a name="l01108"></a>01108     N, T, internal::IsAProtocolMessage&lt;T&gt;::value&gt; &gt;
<a name="l01109"></a><a class="code" href="namespacetesting.html#a5740a5033b88c37666fcd09a269d123f">01109</a> <a class="code" href="namespacetesting.html#a5740a5033b88c37666fcd09a269d123f">SetArgPointee</a>(<span class="keyword">const</span> T&amp; x) {
<a name="l01110"></a>01110   <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a36bd06c5ea972c6df0bd9f40a7a94c65">MakePolymorphicAction</a>(<a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html">internal::SetArgumentPointeeAction</a>&lt;
<a name="l01111"></a>01111       N, T, <a class="code" href="structtesting_1_1internal_1_1IsAProtocolMessage.html">internal::IsAProtocolMessage&lt;T&gt;::value</a>&gt;(x));
<a name="l01112"></a>01112 }
<a name="l01113"></a>01113 
<a name="l01114"></a>01114 <span class="preprocessor">#if !((GTEST_GCC_VER_ &amp;&amp; GTEST_GCC_VER_ &lt; 40000) || GTEST_OS_SYMBIAN)</span>
<a name="l01115"></a>01115 <span class="preprocessor"></span><span class="comment">// This overload allows SetArgPointee() to accept a string literal.</span>
<a name="l01116"></a>01116 <span class="comment">// GCC prior to the version 4.0 and Symbian C++ compiler cannot distinguish</span>
<a name="l01117"></a>01117 <span class="comment">// this overload from the templated version and emit a compile error.</span>
<a name="l01118"></a>01118 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> N&gt;
<a name="l01119"></a>01119 PolymorphicAction&lt;
<a name="l01120"></a>01120   internal::SetArgumentPointeeAction&lt;N, const char*, false&gt; &gt;
<a name="l01121"></a><a class="code" href="namespacetesting.html#a4a190fd2d02fb7cd79c5b3df3f80b647">01121</a> <a class="code" href="namespacetesting.html#a5740a5033b88c37666fcd09a269d123f">SetArgPointee</a>(<span class="keyword">const</span> <span class="keywordtype">char</span>* p) {
<a name="l01122"></a>01122   <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a36bd06c5ea972c6df0bd9f40a7a94c65">MakePolymorphicAction</a>(<a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html">internal::SetArgumentPointeeAction</a>&lt;
<a name="l01123"></a>01123       N, <span class="keyword">const</span> <span class="keywordtype">char</span>*, <span class="keyword">false</span>&gt;(p));
<a name="l01124"></a>01124 }
<a name="l01125"></a>01125 
<a name="l01126"></a>01126 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> N&gt;
<a name="l01127"></a>01127 PolymorphicAction&lt;
<a name="l01128"></a>01128   internal::SetArgumentPointeeAction&lt;N, const wchar_t*, false&gt; &gt;
<a name="l01129"></a><a class="code" href="namespacetesting.html#ac128085b4a8d64563fd5ccef324ea177">01129</a> <a class="code" href="namespacetesting.html#a5740a5033b88c37666fcd09a269d123f">SetArgPointee</a>(<span class="keyword">const</span> <span class="keywordtype">wchar_t</span>* p) {
<a name="l01130"></a>01130   <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a36bd06c5ea972c6df0bd9f40a7a94c65">MakePolymorphicAction</a>(<a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html">internal::SetArgumentPointeeAction</a>&lt;
<a name="l01131"></a>01131       N, <span class="keyword">const</span> <span class="keywordtype">wchar_t</span>*, <span class="keyword">false</span>&gt;(p));
<a name="l01132"></a>01132 }
<a name="l01133"></a>01133 <span class="preprocessor">#endif</span>
<a name="l01134"></a>01134 <span class="preprocessor"></span>
<a name="l01135"></a>01135 <span class="comment">// The following version is DEPRECATED.</span>
<a name="l01136"></a>01136 <span class="keyword">template</span> &lt;<span class="keywordtype">size_t</span> N, <span class="keyword">typename</span> T&gt;
<a name="l01137"></a>01137 PolymorphicAction&lt;
<a name="l01138"></a>01138   internal::SetArgumentPointeeAction&lt;
<a name="l01139"></a>01139     N, T, internal::IsAProtocolMessage&lt;T&gt;::value&gt; &gt;
<a name="l01140"></a><a class="code" href="namespacetesting.html#a03b315d27c91a8e719f2b6c09964130b">01140</a> <a class="code" href="namespacetesting.html#a03b315d27c91a8e719f2b6c09964130b">SetArgumentPointee</a>(<span class="keyword">const</span> T&amp; x) {
<a name="l01141"></a>01141   <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a36bd06c5ea972c6df0bd9f40a7a94c65">MakePolymorphicAction</a>(<a class="code" href="classtesting_1_1internal_1_1SetArgumentPointeeAction.html">internal::SetArgumentPointeeAction</a>&lt;
<a name="l01142"></a>01142       N, T, <a class="code" href="structtesting_1_1internal_1_1IsAProtocolMessage.html">internal::IsAProtocolMessage&lt;T&gt;::value</a>&gt;(x));
<a name="l01143"></a>01143 }
<a name="l01144"></a>01144 
<a name="l01145"></a>01145 <span class="comment">// Creates an action that sets a pointer referent to a given value.</span>
<a name="l01146"></a>01146 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l01147"></a><a class="code" href="namespacetesting.html#abfc4121b8708e8b22a096ff8be88a9d0">01147</a> <a class="code" href="classtesting_1_1PolymorphicAction.html">PolymorphicAction&lt;internal::AssignAction&lt;T1, T2&gt;</a> &gt; <a class="code" href="namespacetesting.html#abfc4121b8708e8b22a096ff8be88a9d0">Assign</a>(T1* ptr, T2 val) {
<a name="l01148"></a>01148   <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a36bd06c5ea972c6df0bd9f40a7a94c65">MakePolymorphicAction</a>(<a class="code" href="classtesting_1_1internal_1_1AssignAction.html">internal::AssignAction&lt;T1, T2&gt;</a>(ptr, val));
<a name="l01149"></a>01149 }
<a name="l01150"></a>01150 
<a name="l01151"></a>01151 <span class="preprocessor">#if !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l01152"></a>01152 <span class="preprocessor"></span>
<a name="l01153"></a>01153 <span class="comment">// Creates an action that sets errno and returns the appropriate error.</span>
<a name="l01154"></a>01154 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01155"></a>01155 PolymorphicAction&lt;internal::SetErrnoAndReturnAction&lt;T&gt; &gt;
<a name="l01156"></a><a class="code" href="namespacetesting.html#a31095e421f167fade2e6d4d60df1f4da">01156</a> <a class="code" href="namespacetesting.html#a31095e421f167fade2e6d4d60df1f4da">SetErrnoAndReturn</a>(<span class="keywordtype">int</span> errval, T result) {
<a name="l01157"></a>01157   <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a36bd06c5ea972c6df0bd9f40a7a94c65">MakePolymorphicAction</a>(
<a name="l01158"></a>01158       <a class="code" href="classtesting_1_1internal_1_1SetErrnoAndReturnAction.html">internal::SetErrnoAndReturnAction&lt;T&gt;</a>(errval, result));
<a name="l01159"></a>01159 }
<a name="l01160"></a>01160 
<a name="l01161"></a>01161 <span class="preprocessor">#endif  // !GTEST_OS_WINDOWS_MOBILE</span>
<a name="l01162"></a>01162 <span class="preprocessor"></span>
<a name="l01163"></a>01163 <span class="comment">// Various overloads for InvokeWithoutArgs().</span>
<a name="l01164"></a>01164 
<a name="l01165"></a>01165 <span class="comment">// Creates an action that invokes &#39;function_impl&#39; with no argument.</span>
<a name="l01166"></a>01166 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> FunctionImpl&gt;
<a name="l01167"></a>01167 PolymorphicAction&lt;internal::InvokeWithoutArgsAction&lt;FunctionImpl&gt; &gt;
<a name="l01168"></a><a class="code" href="namespacetesting.html#a88cc1999296bc630f6a49cdf66bb21f9">01168</a> <a class="code" href="namespacetesting.html#a88cc1999296bc630f6a49cdf66bb21f9">InvokeWithoutArgs</a>(FunctionImpl function_impl) {
<a name="l01169"></a>01169   <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a36bd06c5ea972c6df0bd9f40a7a94c65">MakePolymorphicAction</a>(
<a name="l01170"></a>01170       <a class="code" href="classtesting_1_1internal_1_1InvokeWithoutArgsAction.html">internal::InvokeWithoutArgsAction&lt;FunctionImpl&gt;</a>(function_impl));
<a name="l01171"></a>01171 }
<a name="l01172"></a>01172 
<a name="l01173"></a>01173 <span class="comment">// Creates an action that invokes the given method on the given object</span>
<a name="l01174"></a>01174 <span class="comment">// with no argument.</span>
<a name="l01175"></a>01175 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Class, <span class="keyword">typename</span> MethodPtr&gt;
<a name="l01176"></a>01176 PolymorphicAction&lt;internal::InvokeMethodWithoutArgsAction&lt;Class, MethodPtr&gt; &gt;
<a name="l01177"></a><a class="code" href="namespacetesting.html#ab75325d71a8c37db94f349243815c728">01177</a> <a class="code" href="namespacetesting.html#a88cc1999296bc630f6a49cdf66bb21f9">InvokeWithoutArgs</a>(Class* obj_ptr, MethodPtr method_ptr) {
<a name="l01178"></a>01178   <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a36bd06c5ea972c6df0bd9f40a7a94c65">MakePolymorphicAction</a>(
<a name="l01179"></a>01179       <a class="code" href="classtesting_1_1internal_1_1InvokeMethodWithoutArgsAction.html">internal::InvokeMethodWithoutArgsAction&lt;Class, MethodPtr&gt;</a>(
<a name="l01180"></a>01180           obj_ptr, method_ptr));
<a name="l01181"></a>01181 }
<a name="l01182"></a>01182 
<a name="l01183"></a>01183 <span class="comment">// Creates an action that performs an_action and throws away its</span>
<a name="l01184"></a>01184 <span class="comment">// result.  In other words, it changes the return type of an_action to</span>
<a name="l01185"></a>01185 <span class="comment">// void.  an_action MUST NOT return void, or the code won&#39;t compile.</span>
<a name="l01186"></a>01186 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> A&gt;
<a name="l01187"></a><a class="code" href="namespacetesting.html#a50ae42540a31047c7fddd32df8d835f5">01187</a> <span class="keyword">inline</span> <a class="code" href="classtesting_1_1internal_1_1IgnoreResultAction.html">internal::IgnoreResultAction&lt;A&gt;</a> <a class="code" href="namespacetesting.html#a50ae42540a31047c7fddd32df8d835f5">IgnoreResult</a>(<span class="keyword">const</span> <a class="code" href="namespacetesting.html#a5e9134d655d2fc9323902348083282e7">A</a>&amp; an_action) {
<a name="l01188"></a>01188   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1IgnoreResultAction.html">internal::IgnoreResultAction&lt;A&gt;</a>(an_action);
<a name="l01189"></a>01189 }
<a name="l01190"></a>01190 
<a name="l01191"></a>01191 <span class="comment">// Creates a reference wrapper for the given L-value.  If necessary,</span>
<a name="l01192"></a>01192 <span class="comment">// you can explicitly specify the type of the reference.  For example,</span>
<a name="l01193"></a>01193 <span class="comment">// suppose &#39;derived&#39; is an object of type Derived, ByRef(derived)</span>
<a name="l01194"></a>01194 <span class="comment">// would wrap a Derived&amp;.  If you want to wrap a const Base&amp; instead,</span>
<a name="l01195"></a>01195 <span class="comment">// where Base is a base class of Derived, just write:</span>
<a name="l01196"></a>01196 <span class="comment">//</span>
<a name="l01197"></a>01197 <span class="comment">//   ByRef&lt;const Base&gt;(derived)</span>
<a name="l01198"></a>01198 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l01199"></a><a class="code" href="namespacetesting.html#aaee6d42dcd69de6e7a1459c5c71222c3">01199</a> <span class="keyword">inline</span> <a class="code" href="classtesting_1_1internal_1_1ReferenceWrapper.html">internal::ReferenceWrapper&lt;T&gt;</a> <a class="code" href="namespacetesting.html#aaee6d42dcd69de6e7a1459c5c71222c3">ByRef</a>(T&amp; l_value) {  <span class="comment">// NOLINT</span>
<a name="l01200"></a>01200   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ReferenceWrapper.html">internal::ReferenceWrapper&lt;T&gt;</a>(l_value);
<a name="l01201"></a>01201 }
<a name="l01202"></a>01202 
<a name="l01203"></a>01203 }  <span class="comment">// namespace testing</span>
<a name="l01204"></a>01204 
<a name="l01205"></a>01205 <span class="preprocessor">#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_ACTIONS_H_</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 6 2015 20:59:11 for ZNC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
