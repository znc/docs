<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>ZNC: gmock-generated-matchers.h Source File</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">ZNC
   &#160;<span id="projectnumber">trunk</span>
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="dynsections.js"></script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">gmock-generated-matchers.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="gmock-generated-matchers_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// This file was GENERATED by command:</span>
<a name="l00002"></a>00002 <span class="comment">//     pump.py gmock-generated-matchers.h.pump</span>
<a name="l00003"></a>00003 <span class="comment">// DO NOT EDIT BY HAND!!!</span>
<a name="l00004"></a>00004 
<a name="l00005"></a>00005 <span class="comment">// Copyright 2008, Google Inc.</span>
<a name="l00006"></a>00006 <span class="comment">// All rights reserved.</span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment">// Redistribution and use in source and binary forms, with or without</span>
<a name="l00009"></a>00009 <span class="comment">// modification, are permitted provided that the following conditions are</span>
<a name="l00010"></a>00010 <span class="comment">// met:</span>
<a name="l00011"></a>00011 <span class="comment">//</span>
<a name="l00012"></a>00012 <span class="comment">//     * Redistributions of source code must retain the above copyright</span>
<a name="l00013"></a>00013 <span class="comment">// notice, this list of conditions and the following disclaimer.</span>
<a name="l00014"></a>00014 <span class="comment">//     * Redistributions in binary form must reproduce the above</span>
<a name="l00015"></a>00015 <span class="comment">// copyright notice, this list of conditions and the following disclaimer</span>
<a name="l00016"></a>00016 <span class="comment">// in the documentation and/or other materials provided with the</span>
<a name="l00017"></a>00017 <span class="comment">// distribution.</span>
<a name="l00018"></a>00018 <span class="comment">//     * Neither the name of Google Inc. nor the names of its</span>
<a name="l00019"></a>00019 <span class="comment">// contributors may be used to endorse or promote products derived from</span>
<a name="l00020"></a>00020 <span class="comment">// this software without specific prior written permission.</span>
<a name="l00021"></a>00021 <span class="comment">//</span>
<a name="l00022"></a>00022 <span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</span>
<a name="l00023"></a>00023 <span class="comment">// &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</span>
<a name="l00024"></a>00024 <span class="comment">// LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</span>
<a name="l00025"></a>00025 <span class="comment">// A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</span>
<a name="l00026"></a>00026 <span class="comment">// OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
<a name="l00027"></a>00027 <span class="comment">// SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
<a name="l00028"></a>00028 <span class="comment">// LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,</span>
<a name="l00029"></a>00029 <span class="comment">// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY</span>
<a name="l00030"></a>00030 <span class="comment">// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT</span>
<a name="l00031"></a>00031 <span class="comment">// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<a name="l00032"></a>00032 <span class="comment">// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 <span class="comment">// Google Mock - a framework for writing C++ mock classes.</span>
<a name="l00035"></a>00035 <span class="comment">//</span>
<a name="l00036"></a>00036 <span class="comment">// This file implements some commonly used variadic matchers.</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#ifndef GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_</span>
<a name="l00039"></a>00039 <span class="preprocessor"></span><span class="preprocessor">#define GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_</span>
<a name="l00040"></a>00040 <span class="preprocessor"></span>
<a name="l00041"></a>00041 <span class="preprocessor">#include &lt;iterator&gt;</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include &lt;sstream&gt;</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include &quot;<a class="code" href="gmock-matchers_8h.html">gmock/gmock-matchers.h</a>&quot;</span>
<a name="l00046"></a>00046 
<a name="l00047"></a>00047 <span class="keyword">namespace </span>testing {
<a name="l00048"></a>00048 <span class="keyword">namespace </span>internal {
<a name="l00049"></a>00049 
<a name="l00050"></a>00050 <span class="comment">// The type of the i-th (0-based) field of Tuple.</span>
<a name="l00051"></a><a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">00051</a> <span class="preprocessor">#define GMOCK_FIELD_TYPE_(Tuple, i) \</span>
<a name="l00052"></a>00052 <span class="preprocessor">    typename ::testing::tuple_element&lt;i, Tuple&gt;::type</span>
<a name="l00053"></a>00053 <span class="preprocessor"></span>
<a name="l00054"></a>00054 <span class="comment">// TupleFields&lt;Tuple, k0, ..., kn&gt; is for selecting fields from a</span>
<a name="l00055"></a>00055 <span class="comment">// tuple of type Tuple.  It has two members:</span>
<a name="l00056"></a>00056 <span class="comment">//</span>
<a name="l00057"></a>00057 <span class="comment">//   type: a tuple type whose i-th field is the ki-th field of Tuple.</span>
<a name="l00058"></a>00058 <span class="comment">//   GetSelectedFields(t): returns fields k0, ..., and kn of t as a tuple.</span>
<a name="l00059"></a>00059 <span class="comment">//</span>
<a name="l00060"></a>00060 <span class="comment">// For example, in class TupleFields&lt;tuple&lt;bool, char, int&gt;, 2, 0&gt;, we have:</span>
<a name="l00061"></a>00061 <span class="comment">//</span>
<a name="l00062"></a>00062 <span class="comment">//   type is tuple&lt;int, bool&gt;, and</span>
<a name="l00063"></a>00063 <span class="comment">//   GetSelectedFields(make_tuple(true, &#39;a&#39;, 42)) is (42, true).</span>
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 <span class="keyword">template</span> &lt;<span class="keyword">class </span>Tuple, <span class="keywordtype">int</span> k0 = -1, <span class="keywordtype">int</span> k1 = -1, <span class="keywordtype">int</span> k2 = -1, <span class="keywordtype">int</span> k3 = -1,
<a name="l00066"></a>00066     <span class="keywordtype">int</span> k4 = -1, <span class="keywordtype">int</span> k5 = -1, <span class="keywordtype">int</span> k6 = -1, <span class="keywordtype">int</span> k7 = -1, <span class="keywordtype">int</span> k8 = -1,
<a name="l00067"></a>00067     <span class="keywordtype">int</span> k9 = -1&gt;
<a name="l00068"></a>00068 <span class="keyword">class </span>TupleFields;
<a name="l00069"></a>00069 
<a name="l00070"></a>00070 <span class="comment">// This generic version is used when there are 10 selectors.</span>
<a name="l00071"></a>00071 <span class="keyword">template</span> &lt;<span class="keyword">class </span>Tuple, <span class="keywordtype">int</span> k0, <span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4, <span class="keywordtype">int</span> k5, <span class="keywordtype">int</span> k6,
<a name="l00072"></a>00072     <span class="keywordtype">int</span> k7, <span class="keywordtype">int</span> k8, <span class="keywordtype">int</span> k9&gt;
<a name="l00073"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields.html">00073</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1TupleFields.html">TupleFields</a> {
<a name="l00074"></a>00074  <span class="keyword">public</span>:
<a name="l00075"></a>00075   typedef ::testing::tuple&lt;<a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k0),
<a name="l00076"></a>00076       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k1), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k2),
<a name="l00077"></a>00077       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k3), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k4),
<a name="l00078"></a>00078       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k5), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k6),
<a name="l00079"></a>00079       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k7), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k8),
<a name="l00080"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">00080</a>       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k9)&gt; <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a>;
<a name="l00081"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a020eefb4630e6dffe8bcadd0a70b1bab">00081</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a020eefb4630e6dffe8bcadd0a70b1bab">GetSelectedFields</a>(<span class="keyword">const</span> Tuple&amp; t) {
<a name="l00082"></a>00082     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a>(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t), get&lt;k4&gt;(t),
<a name="l00083"></a>00083         get&lt;k5&gt;(t), get&lt;k6&gt;(t), get&lt;k7&gt;(t), get&lt;k8&gt;(t), get&lt;k9&gt;(t));
<a name="l00084"></a>00084   }
<a name="l00085"></a>00085 };
<a name="l00086"></a>00086 
<a name="l00087"></a>00087 <span class="comment">// The following specialization is used for 0 ~ 9 selectors.</span>
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tuple&gt;
<a name="l00090"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html">00090</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1TupleFields.html">TupleFields</a>&lt;Tuple, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1&gt; {
<a name="l00091"></a>00091  <span class="keyword">public</span>:
<a name="l00092"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#addfc4b7d727aa8e4c7838a378a573bf6">00092</a>   typedef ::testing::tuple&lt;&gt; <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#addfc4b7d727aa8e4c7838a378a573bf6">type</a>;
<a name="l00093"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a903907f35d09b8b0f4e4e2778c1350f7">00093</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#addfc4b7d727aa8e4c7838a378a573bf6">type</a> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a903907f35d09b8b0f4e4e2778c1350f7">GetSelectedFields</a>(<span class="keyword">const</span> Tuple&amp; <span class="comment">/* t */</span>) {
<a name="l00094"></a>00094     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a>();
<a name="l00095"></a>00095   }
<a name="l00096"></a>00096 };
<a name="l00097"></a>00097 
<a name="l00098"></a>00098 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tuple, <span class="keywordtype">int</span> k0&gt;
<a name="l00099"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html">00099</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1TupleFields.html">TupleFields</a>&lt;Tuple, k0, -1, -1, -1, -1, -1, -1, -1, -1, -1&gt; {
<a name="l00100"></a>00100  <span class="keyword">public</span>:
<a name="l00101"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#aae8b0b52bdcdfeeaca4509a079ca0e89">00101</a>   typedef ::testing::tuple&lt;GMOCK_FIELD_TYPE_(Tuple, k0)&gt; <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#aae8b0b52bdcdfeeaca4509a079ca0e89">type</a>;
<a name="l00102"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#ab1f21f40fbfe71554403bf8a4c5bd980">00102</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#aae8b0b52bdcdfeeaca4509a079ca0e89">type</a> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#ab1f21f40fbfe71554403bf8a4c5bd980">GetSelectedFields</a>(<span class="keyword">const</span> Tuple&amp; t) {
<a name="l00103"></a>00103     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a>(get&lt;k0&gt;(t));
<a name="l00104"></a>00104   }
<a name="l00105"></a>00105 };
<a name="l00106"></a>00106 
<a name="l00107"></a>00107 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tuple, <span class="keywordtype">int</span> k0, <span class="keywordtype">int</span> k1&gt;
<a name="l00108"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html">00108</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1TupleFields.html">TupleFields</a>&lt;Tuple, k0, k1, -1, -1, -1, -1, -1, -1, -1, -1&gt; {
<a name="l00109"></a>00109  <span class="keyword">public</span>:
<a name="l00110"></a>00110   typedef ::testing::tuple&lt;<a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k0),
<a name="l00111"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a3b11f1a0cd0218f2d102b57c19cde352">00111</a>       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k1)&gt; <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a3b11f1a0cd0218f2d102b57c19cde352">type</a>;
<a name="l00112"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a97c0bf10d84e8773ff13857e287f9913">00112</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a3b11f1a0cd0218f2d102b57c19cde352">type</a> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a97c0bf10d84e8773ff13857e287f9913">GetSelectedFields</a>(<span class="keyword">const</span> Tuple&amp; t) {
<a name="l00113"></a>00113     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a>(get&lt;k0&gt;(t), get&lt;k1&gt;(t));
<a name="l00114"></a>00114   }
<a name="l00115"></a>00115 };
<a name="l00116"></a>00116 
<a name="l00117"></a>00117 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tuple, <span class="keywordtype">int</span> k0, <span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2&gt;
<a name="l00118"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html">00118</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1TupleFields.html">TupleFields</a>&lt;Tuple, k0, k1, k2, -1, -1, -1, -1, -1, -1, -1&gt; {
<a name="l00119"></a>00119  <span class="keyword">public</span>:
<a name="l00120"></a>00120   typedef ::testing::tuple&lt;<a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k0),
<a name="l00121"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a2c7151e3fa5ea105e18ab8a93c7d700e">00121</a>       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k1), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k2)&gt; <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a2c7151e3fa5ea105e18ab8a93c7d700e">type</a>;
<a name="l00122"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a331e96854627730e698fbeb4a31f1caa">00122</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a2c7151e3fa5ea105e18ab8a93c7d700e">type</a> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00-1_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a331e96854627730e698fbeb4a31f1caa">GetSelectedFields</a>(<span class="keyword">const</span> Tuple&amp; t) {
<a name="l00123"></a>00123     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a>(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t));
<a name="l00124"></a>00124   }
<a name="l00125"></a>00125 };
<a name="l00126"></a>00126 
<a name="l00127"></a>00127 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tuple, <span class="keywordtype">int</span> k0, <span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3&gt;
<a name="l00128"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html">00128</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1TupleFields.html">TupleFields</a>&lt;Tuple, k0, k1, k2, k3, -1, -1, -1, -1, -1, -1&gt; {
<a name="l00129"></a>00129  <span class="keyword">public</span>:
<a name="l00130"></a>00130   typedef ::testing::tuple&lt;<a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k0),
<a name="l00131"></a>00131       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k1), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k2),
<a name="l00132"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a9e082889b5cbbbc44c95a2cec23d4646">00132</a>       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k3)&gt; <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a9e082889b5cbbbc44c95a2cec23d4646">type</a>;
<a name="l00133"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a3ef0caad002de28085c87c65fcca983a">00133</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a9e082889b5cbbbc44c95a2cec23d4646">type</a> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00-1_00-1_00-1_00-1_00-1_00-1_01_4.html#a3ef0caad002de28085c87c65fcca983a">GetSelectedFields</a>(<span class="keyword">const</span> Tuple&amp; t) {
<a name="l00134"></a>00134     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a>(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t));
<a name="l00135"></a>00135   }
<a name="l00136"></a>00136 };
<a name="l00137"></a>00137 
<a name="l00138"></a>00138 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tuple, <span class="keywordtype">int</span> k0, <span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4&gt;
<a name="l00139"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00-1_00-1_00-1_00-1_00-1_01_4.html">00139</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1TupleFields.html">TupleFields</a>&lt;Tuple, k0, k1, k2, k3, k4, -1, -1, -1, -1, -1&gt; {
<a name="l00140"></a>00140  <span class="keyword">public</span>:
<a name="l00141"></a>00141   typedef ::testing::tuple&lt;<a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k0),
<a name="l00142"></a>00142       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k1), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k2),
<a name="l00143"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00-1_00-1_00-1_00-1_00-1_01_4.html#a0f2600b6a8009ead7c04545648de2033">00143</a>       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k3), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k4)&gt; <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00-1_00-1_00-1_00-1_00-1_01_4.html#a0f2600b6a8009ead7c04545648de2033">type</a>;
<a name="l00144"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00-1_00-1_00-1_00-1_00-1_01_4.html#a30807ca848bc2f05bf18c7837a82b9c3">00144</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00-1_00-1_00-1_00-1_00-1_01_4.html#a0f2600b6a8009ead7c04545648de2033">type</a> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00-1_00-1_00-1_00-1_00-1_01_4.html#a30807ca848bc2f05bf18c7837a82b9c3">GetSelectedFields</a>(<span class="keyword">const</span> Tuple&amp; t) {
<a name="l00145"></a>00145     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a>(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t), get&lt;k4&gt;(t));
<a name="l00146"></a>00146   }
<a name="l00147"></a>00147 };
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tuple, <span class="keywordtype">int</span> k0, <span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4, <span class="keywordtype">int</span> k5&gt;
<a name="l00150"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k5_00-1_00-1_00-1_00-1_01_4.html">00150</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1TupleFields.html">TupleFields</a>&lt;Tuple, k0, k1, k2, k3, k4, k5, -1, -1, -1, -1&gt; {
<a name="l00151"></a>00151  <span class="keyword">public</span>:
<a name="l00152"></a>00152   typedef ::testing::tuple&lt;<a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k0),
<a name="l00153"></a>00153       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k1), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k2),
<a name="l00154"></a>00154       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k3), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k4),
<a name="l00155"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k5_00-1_00-1_00-1_00-1_01_4.html#a213a853fe0796e7f054799b7b087bbfa">00155</a>       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k5)&gt; <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k5_00-1_00-1_00-1_00-1_01_4.html#a213a853fe0796e7f054799b7b087bbfa">type</a>;
<a name="l00156"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k5_00-1_00-1_00-1_00-1_01_4.html#af8ec2828a79528f9a366cdbe26289d7e">00156</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k5_00-1_00-1_00-1_00-1_01_4.html#a213a853fe0796e7f054799b7b087bbfa">type</a> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k5_00-1_00-1_00-1_00-1_01_4.html#af8ec2828a79528f9a366cdbe26289d7e">GetSelectedFields</a>(<span class="keyword">const</span> Tuple&amp; t) {
<a name="l00157"></a>00157     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a>(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t), get&lt;k4&gt;(t),
<a name="l00158"></a>00158         get&lt;k5&gt;(t));
<a name="l00159"></a>00159   }
<a name="l00160"></a>00160 };
<a name="l00161"></a>00161 
<a name="l00162"></a>00162 <span class="keyword">template</span> &lt;<span class="keyword">class</span> Tuple, <span class="keywordtype">int</span> k0, <span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4, <span class="keywordtype">int</span> k5, <span class="keywordtype">int</span> k6&gt;
<a name="l00163"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k5_00_01k6_00-1_00-1_00-1_01_4.html">00163</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1TupleFields.html">TupleFields</a>&lt;Tuple, k0, k1, k2, k3, k4, k5, k6, -1, -1, -1&gt; {
<a name="l00164"></a>00164  <span class="keyword">public</span>:
<a name="l00165"></a>00165   typedef ::testing::tuple&lt;<a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k0),
<a name="l00166"></a>00166       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k1), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k2),
<a name="l00167"></a>00167       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k3), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k4),
<a name="l00168"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k5_00_01k6_00-1_00-1_00-1_01_4.html#af88448437d5fc78f853662af70202380">00168</a>       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k5), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k6)&gt; <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k5_00_01k6_00-1_00-1_00-1_01_4.html#af88448437d5fc78f853662af70202380">type</a>;
<a name="l00169"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k5_00_01k6_00-1_00-1_00-1_01_4.html#a8408461aa8107794d3abc85e2cb2721e">00169</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k5_00_01k6_00-1_00-1_00-1_01_4.html#af88448437d5fc78f853662af70202380">type</a> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k5_00_01k6_00-1_00-1_00-1_01_4.html#a8408461aa8107794d3abc85e2cb2721e">GetSelectedFields</a>(<span class="keyword">const</span> Tuple&amp; t) {
<a name="l00170"></a>00170     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a>(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t), get&lt;k4&gt;(t),
<a name="l00171"></a>00171         get&lt;k5&gt;(t), get&lt;k6&gt;(t));
<a name="l00172"></a>00172   }
<a name="l00173"></a>00173 };
<a name="l00174"></a>00174 
<a name="l00175"></a>00175 <span class="keyword">template</span> &lt;<span class="keyword">class </span>Tuple, <span class="keywordtype">int</span> k0, <span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4, <span class="keywordtype">int</span> k5, <span class="keywordtype">int</span> k6,
<a name="l00176"></a>00176     <span class="keywordtype">int</span> k7&gt;
<a name="l00177"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k58e55129982dcbf796bc09f321e253b2.html">00177</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1TupleFields.html">TupleFields</a>&lt;Tuple, k0, k1, k2, k3, k4, k5, k6, k7, -1, -1&gt; {
<a name="l00178"></a>00178  <span class="keyword">public</span>:
<a name="l00179"></a>00179   typedef ::testing::tuple&lt;<a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k0),
<a name="l00180"></a>00180       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k1), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k2),
<a name="l00181"></a>00181       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k3), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k4),
<a name="l00182"></a>00182       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k5), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k6),
<a name="l00183"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k58e55129982dcbf796bc09f321e253b2.html#a391bb0758025c4f9238011be4bf6c1d1">00183</a>       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k7)&gt; <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k58e55129982dcbf796bc09f321e253b2.html#a391bb0758025c4f9238011be4bf6c1d1">type</a>;
<a name="l00184"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k58e55129982dcbf796bc09f321e253b2.html#aef8634866510cb440f26ec78f46538d5">00184</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k58e55129982dcbf796bc09f321e253b2.html#a391bb0758025c4f9238011be4bf6c1d1">type</a> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k58e55129982dcbf796bc09f321e253b2.html#aef8634866510cb440f26ec78f46538d5">GetSelectedFields</a>(<span class="keyword">const</span> Tuple&amp; t) {
<a name="l00185"></a>00185     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a>(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t), get&lt;k4&gt;(t),
<a name="l00186"></a>00186         get&lt;k5&gt;(t), get&lt;k6&gt;(t), get&lt;k7&gt;(t));
<a name="l00187"></a>00187   }
<a name="l00188"></a>00188 };
<a name="l00189"></a>00189 
<a name="l00190"></a>00190 <span class="keyword">template</span> &lt;<span class="keyword">class </span>Tuple, <span class="keywordtype">int</span> k0, <span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4, <span class="keywordtype">int</span> k5, <span class="keywordtype">int</span> k6,
<a name="l00191"></a>00191     <span class="keywordtype">int</span> k7, <span class="keywordtype">int</span> k8&gt;
<a name="l00192"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k7d05709aed2fdf4fd2f884d75b9bd5cd.html">00192</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1TupleFields.html">TupleFields</a>&lt;Tuple, k0, k1, k2, k3, k4, k5, k6, k7, k8, -1&gt; {
<a name="l00193"></a>00193  <span class="keyword">public</span>:
<a name="l00194"></a>00194   typedef ::testing::tuple&lt;<a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k0),
<a name="l00195"></a>00195       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k1), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k2),
<a name="l00196"></a>00196       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k3), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k4),
<a name="l00197"></a>00197       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k5), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k6),
<a name="l00198"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k7d05709aed2fdf4fd2f884d75b9bd5cd.html#a0bc5decc5653ee7a29fe8a6aeab9f3d4">00198</a>       <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k7), <a class="code" href="gmock-generated-matchers_8h.html#acf3e27de83a73f0d873da1cd471e505b">GMOCK_FIELD_TYPE_</a>(Tuple, k8)&gt; <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k7d05709aed2fdf4fd2f884d75b9bd5cd.html#a0bc5decc5653ee7a29fe8a6aeab9f3d4">type</a>;
<a name="l00199"></a><a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k7d05709aed2fdf4fd2f884d75b9bd5cd.html#a3474bb96dfb58d4447c974c79b3229b9">00199</a>   <span class="keyword">static</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k7d05709aed2fdf4fd2f884d75b9bd5cd.html#a0bc5decc5653ee7a29fe8a6aeab9f3d4">type</a> <a class="code" href="classtesting_1_1internal_1_1TupleFields_3_01Tuple_00_01k0_00_01k1_00_01k2_00_01k3_00_01k4_00_01k7d05709aed2fdf4fd2f884d75b9bd5cd.html#a3474bb96dfb58d4447c974c79b3229b9">GetSelectedFields</a>(<span class="keyword">const</span> Tuple&amp; t) {
<a name="l00200"></a>00200     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html#a5480877377ebc94bf3a6c6cab5c369bc">type</a>(get&lt;k0&gt;(t), get&lt;k1&gt;(t), get&lt;k2&gt;(t), get&lt;k3&gt;(t), get&lt;k4&gt;(t),
<a name="l00201"></a>00201         get&lt;k5&gt;(t), get&lt;k6&gt;(t), get&lt;k7&gt;(t), get&lt;k8&gt;(t));
<a name="l00202"></a>00202   }
<a name="l00203"></a>00203 };
<a name="l00204"></a>00204 
<a name="l00205"></a>00205 <span class="preprocessor">#undef GMOCK_FIELD_TYPE_</span>
<a name="l00206"></a>00206 <span class="preprocessor"></span>
<a name="l00207"></a>00207 <span class="comment">// Implements the Args() matcher.</span>
<a name="l00208"></a>00208 <span class="keyword">template</span> &lt;<span class="keyword">class </span>ArgsTuple, <span class="keywordtype">int</span> k0 = -1, <span class="keywordtype">int</span> k1 = -1, <span class="keywordtype">int</span> k2 = -1, <span class="keywordtype">int</span> k3 = -1,
<a name="l00209"></a>00209     <span class="keywordtype">int</span> k4 = -1, <span class="keywordtype">int</span> k5 = -1, <span class="keywordtype">int</span> k6 = -1, <span class="keywordtype">int</span> k7 = -1, <span class="keywordtype">int</span> k8 = -1,
<a name="l00210"></a>00210     <span class="keywordtype">int</span> k9 = -1&gt;
<a name="l00211"></a><a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html">00211</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html">ArgsMatcherImpl</a> : <span class="keyword">public</span> <a class="code" href="classtesting_1_1MatcherInterface.html">MatcherInterface</a>&lt;ArgsTuple&gt; {
<a name="l00212"></a>00212  <span class="keyword">public</span>:
<a name="l00213"></a>00213   <span class="comment">// ArgsTuple may have top-level const or reference modifiers.</span>
<a name="l00214"></a>00214   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#a7b0cadc369c0c20cd254cc2052782301">GTEST_REMOVE_REFERENCE_AND_CONST_</a>(ArgsTuple) RawArgsTuple;
<a name="l00215"></a>00215   <span class="keyword">typedef</span> <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html">internal::TupleFields</a>&lt;RawArgsTuple, k0, k1, k2, k3, k4, k5,
<a name="l00216"></a><a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#ab061679f6251e56ccbedaf0c316d00ff">00216</a>       k6, k7, k8, k9&gt;::type <a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#ab061679f6251e56ccbedaf0c316d00ff">SelectedArgs</a>;
<a name="l00217"></a><a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#ab90d2c074b2072d6c39bf26209fb941f">00217</a>   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1Matcher.html">Matcher&lt;const SelectedArgs&amp;&gt;</a> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#ab90d2c074b2072d6c39bf26209fb941f">MonomorphicInnerMatcher</a>;
<a name="l00218"></a>00218 
<a name="l00219"></a>00219   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InnerMatcher&gt;
<a name="l00220"></a><a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#a7f7a9a826d130d11fe30633d79f59a06">00220</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#a7f7a9a826d130d11fe30633d79f59a06">ArgsMatcherImpl</a>(<span class="keyword">const</span> InnerMatcher&amp; inner_matcher)
<a name="l00221"></a>00221       : inner_matcher_(<a class="code" href="namespacetesting.html#ac016ac22aa065a19b9ef95f0ccffc17b">SafeMatcherCast</a>&lt;const <a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#ab061679f6251e56ccbedaf0c316d00ff">SelectedArgs</a>&amp;&gt;(inner_matcher)) {}
<a name="l00222"></a>00222 
<a name="l00223"></a><a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#a9c9760b144a5e207082fe040c869ad39">00223</a>   <span class="keyword">virtual</span> <span class="keywordtype">bool</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#a9c9760b144a5e207082fe040c869ad39">MatchAndExplain</a>(ArgsTuple args,
<a name="l00224"></a>00224                                <a class="code" href="classtesting_1_1MatchResultListener.html">MatchResultListener</a>* listener)<span class="keyword"> const </span>{
<a name="l00225"></a>00225     <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#ab061679f6251e56ccbedaf0c316d00ff">SelectedArgs</a>&amp; selected_args = GetSelectedArgs(args);
<a name="l00226"></a>00226     <span class="keywordflow">if</span> (!listener-&gt;<a class="code" href="classtesting_1_1MatchResultListener.html#a68dc4f2f3c3425f4d4dd90ab02244615">IsInterested</a>())
<a name="l00227"></a>00227       <span class="keywordflow">return</span> inner_matcher_.<a class="code" href="classtesting_1_1internal_1_1MatcherBase.html#a105a9dae7afecee8898db8ad1887b0db">Matches</a>(selected_args);
<a name="l00228"></a>00228 
<a name="l00229"></a>00229     PrintIndices(listener-&gt;<a class="code" href="classtesting_1_1MatchResultListener.html#a5abecb247e005f7f50a94898e3f44ee3">stream</a>());
<a name="l00230"></a>00230     *listener &lt;&lt; <span class="stringliteral">&quot;are &quot;</span> &lt;&lt; <a class="code" href="namespacetesting.html#a58d19855b0e4ac0661feaa374052ac13">PrintToString</a>(selected_args);
<a name="l00231"></a>00231 
<a name="l00232"></a>00232     <a class="code" href="classtesting_1_1StringMatchResultListener.html">StringMatchResultListener</a> inner_listener;
<a name="l00233"></a>00233     <span class="keyword">const</span> <span class="keywordtype">bool</span> match = inner_matcher_.<a class="code" href="classtesting_1_1internal_1_1MatcherBase.html#ae3f5f3150a95cafb1c2ab7c864a42e65">MatchAndExplain</a>(selected_args,
<a name="l00234"></a>00234                                                       &amp;inner_listener);
<a name="l00235"></a>00235     <a class="code" href="namespacetesting_1_1internal.html#a77c9e2b66d2b2414db4763971180d53c">PrintIfNotEmpty</a>(inner_listener.<a class="code" href="classtesting_1_1StringMatchResultListener.html#a601171722243ac405f40c3efbec6f982">str</a>(), listener-&gt;<a class="code" href="classtesting_1_1MatchResultListener.html#a5abecb247e005f7f50a94898e3f44ee3">stream</a>());
<a name="l00236"></a>00236     <span class="keywordflow">return</span> match;
<a name="l00237"></a>00237   }
<a name="l00238"></a>00238 
<a name="l00239"></a><a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#a7e2acf3bee2d8038da0f87673bc82eb2">00239</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#a7e2acf3bee2d8038da0f87673bc82eb2">DescribeTo</a>(::std::ostream* os)<span class="keyword"> const </span>{
<a name="l00240"></a>00240     *os &lt;&lt; <span class="stringliteral">&quot;are a tuple &quot;</span>;
<a name="l00241"></a>00241     PrintIndices(os);
<a name="l00242"></a>00242     inner_matcher_.<a class="code" href="classtesting_1_1internal_1_1MatcherBase.html#afcb24e7d1ff27e147e0e607d2a122467">DescribeTo</a>(os);
<a name="l00243"></a>00243   }
<a name="l00244"></a>00244 
<a name="l00245"></a><a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#af22ab8bcd4baee6d1c79751d46240289">00245</a>   <span class="keyword">virtual</span> <span class="keywordtype">void</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#af22ab8bcd4baee6d1c79751d46240289">DescribeNegationTo</a>(::std::ostream* os)<span class="keyword"> const </span>{
<a name="l00246"></a>00246     *os &lt;&lt; <span class="stringliteral">&quot;are a tuple &quot;</span>;
<a name="l00247"></a>00247     PrintIndices(os);
<a name="l00248"></a>00248     inner_matcher_.<a class="code" href="classtesting_1_1internal_1_1MatcherBase.html#a47cc840bc783fc0ceafbfb68d0ea5758">DescribeNegationTo</a>(os);
<a name="l00249"></a>00249   }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251  <span class="keyword">private</span>:
<a name="l00252"></a>00252   <span class="keyword">static</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#ab061679f6251e56ccbedaf0c316d00ff">SelectedArgs</a> GetSelectedArgs(ArgsTuple args) {
<a name="l00253"></a>00253     <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1TupleFields.html">TupleFields</a>&lt;RawArgsTuple, k0, k1, k2, k3, k4, k5, k6, k7, k8,
<a name="l00254"></a>00254         k9&gt;::GetSelectedFields(args);
<a name="l00255"></a>00255   }
<a name="l00256"></a>00256 
<a name="l00257"></a>00257   <span class="comment">// Prints the indices of the selected fields.</span>
<a name="l00258"></a>00258   <span class="keyword">static</span> <span class="keywordtype">void</span> PrintIndices(::std::ostream* os) {
<a name="l00259"></a>00259     *os &lt;&lt; <span class="stringliteral">&quot;whose fields (&quot;</span>;
<a name="l00260"></a>00260     <span class="keyword">const</span> <span class="keywordtype">int</span> indices[10] = { k0, k1, k2, k3, k4, k5, k6, k7, k8, k9 };
<a name="l00261"></a>00261     <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; 10; i++) {
<a name="l00262"></a>00262       <span class="keywordflow">if</span> (indices[i] &lt; 0)
<a name="l00263"></a>00263         <span class="keywordflow">break</span>;
<a name="l00264"></a>00264 
<a name="l00265"></a>00265       <span class="keywordflow">if</span> (i &gt;= 1)
<a name="l00266"></a>00266         *os &lt;&lt; <span class="stringliteral">&quot;, &quot;</span>;
<a name="l00267"></a>00267 
<a name="l00268"></a>00268       *os &lt;&lt; <span class="stringliteral">&quot;#&quot;</span> &lt;&lt; indices[i];
<a name="l00269"></a>00269     }
<a name="l00270"></a>00270     *os &lt;&lt; <span class="stringliteral">&quot;) &quot;</span>;
<a name="l00271"></a>00271   }
<a name="l00272"></a>00272 
<a name="l00273"></a>00273   <span class="keyword">const</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#ab90d2c074b2072d6c39bf26209fb941f">MonomorphicInnerMatcher</a> inner_matcher_;
<a name="l00274"></a>00274 
<a name="l00275"></a>00275   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html#a7f7a9a826d130d11fe30633d79f59a06">ArgsMatcherImpl</a>);
<a name="l00276"></a>00276 };
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 <span class="keyword">template</span> &lt;<span class="keyword">class </span>InnerMatcher, <span class="keywordtype">int</span> k0 = -1, <span class="keywordtype">int</span> k1 = -1, <span class="keywordtype">int</span> k2 = -1,
<a name="l00279"></a>00279     <span class="keywordtype">int</span> k3 = -1, <span class="keywordtype">int</span> k4 = -1, <span class="keywordtype">int</span> k5 = -1, <span class="keywordtype">int</span> k6 = -1, <span class="keywordtype">int</span> k7 = -1,
<a name="l00280"></a>00280     <span class="keywordtype">int</span> k8 = -1, <span class="keywordtype">int</span> k9 = -1&gt;
<a name="l00281"></a><a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">00281</a> <span class="keyword">class </span><a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">ArgsMatcher</a> {
<a name="l00282"></a>00282  <span class="keyword">public</span>:
<a name="l00283"></a><a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html#a2879d7455f2da2a5a2f2b6759dbc0561">00283</a>   <span class="keyword">explicit</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html#a2879d7455f2da2a5a2f2b6759dbc0561">ArgsMatcher</a>(<span class="keyword">const</span> InnerMatcher&amp; inner_matcher)
<a name="l00284"></a>00284       : inner_matcher_(inner_matcher) {}
<a name="l00285"></a>00285 
<a name="l00286"></a>00286   <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ArgsTuple&gt;
<a name="l00287"></a><a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html#ae94d3e9b43d0102875a1494ca56e6d26">00287</a>   <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html#ae94d3e9b43d0102875a1494ca56e6d26">operator Matcher&lt;ArgsTuple&gt;</a>()<span class="keyword"> const </span>{
<a name="l00288"></a>00288     <span class="keywordflow">return</span> <a class="code" href="namespacetesting.html#a37fd8029ac00e60952440a3d9cca8166">MakeMatcher</a>(<span class="keyword">new</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcherImpl.html">ArgsMatcherImpl</a>&lt;ArgsTuple, k0, k1, k2, k3, k4, k5,
<a name="l00289"></a>00289         k6, k7, k8, k9&gt;(inner_matcher_));
<a name="l00290"></a>00290   }
<a name="l00291"></a>00291 
<a name="l00292"></a>00292  <span class="keyword">private</span>:
<a name="l00293"></a>00293   <span class="keyword">const</span> InnerMatcher inner_matcher_;
<a name="l00294"></a>00294 
<a name="l00295"></a>00295   GTEST_DISALLOW_ASSIGN_(<a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">ArgsMatcher</a>);
<a name="l00296"></a>00296 };
<a name="l00297"></a>00297 
<a name="l00298"></a>00298 <span class="comment">// A set of metafunctions for computing the result type of AllOf.</span>
<a name="l00299"></a>00299 <span class="comment">// AllOf(m1, ..., mN) returns</span>
<a name="l00300"></a>00300 <span class="comment">// AllOfResultN&lt;decltype(m1), ..., decltype(mN)&gt;::type.</span>
<a name="l00301"></a>00301 
<a name="l00302"></a>00302 <span class="comment">// Although AllOf isn&#39;t defined for one argument, AllOfResult1 is defined</span>
<a name="l00303"></a>00303 <span class="comment">// to simplify the implementation.</span>
<a name="l00304"></a>00304 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1&gt;
<a name="l00305"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult1.html">00305</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AllOfResult1.html">AllOfResult1</a> {
<a name="l00306"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult1.html#a19b95d4ddf7f4044a78665d9e253db10">00306</a>   <span class="keyword">typedef</span> M1 <a class="code" href="structtesting_1_1internal_1_1AllOfResult1.html#a19b95d4ddf7f4044a78665d9e253db10">type</a>;
<a name="l00307"></a>00307 };
<a name="l00308"></a>00308 
<a name="l00309"></a>00309 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2&gt;
<a name="l00310"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult2.html">00310</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AllOfResult2.html">AllOfResult2</a> {
<a name="l00311"></a>00311   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">BothOfMatcher</a>&lt;
<a name="l00312"></a>00312       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AllOfResult1.html#a19b95d4ddf7f4044a78665d9e253db10">AllOfResult1&lt;M1&gt;::type</a>,
<a name="l00313"></a>00313       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AllOfResult1.html#a19b95d4ddf7f4044a78665d9e253db10">AllOfResult1&lt;M2&gt;::type</a>
<a name="l00314"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult2.html#adec0b0ce2fdd07d398e1fdd2cdb88392">00314</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AllOfResult2.html#adec0b0ce2fdd07d398e1fdd2cdb88392">type</a>;
<a name="l00315"></a>00315 };
<a name="l00316"></a>00316 
<a name="l00317"></a>00317 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3&gt;
<a name="l00318"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult3.html">00318</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AllOfResult3.html">AllOfResult3</a> {
<a name="l00319"></a>00319   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">BothOfMatcher</a>&lt;
<a name="l00320"></a>00320       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AllOfResult1.html#a19b95d4ddf7f4044a78665d9e253db10">AllOfResult1&lt;M1&gt;::type</a>,
<a name="l00321"></a>00321       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult2&lt;M2, M3&gt;::type</a>
<a name="l00322"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult3.html#a18073a23acd542bccf3a6c5d7f72f957">00322</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AllOfResult3.html#a18073a23acd542bccf3a6c5d7f72f957">type</a>;
<a name="l00323"></a>00323 };
<a name="l00324"></a>00324 
<a name="l00325"></a>00325 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4&gt;
<a name="l00326"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult4.html">00326</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AllOfResult4.html">AllOfResult4</a> {
<a name="l00327"></a>00327   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">BothOfMatcher</a>&lt;
<a name="l00328"></a>00328       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult2&lt;M1, M2&gt;::type</a>,
<a name="l00329"></a>00329       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult2&lt;M3, M4&gt;::type</a>
<a name="l00330"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult4.html#ab277e20178bac632d4e5a39a1a407bbf">00330</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AllOfResult4.html#ab277e20178bac632d4e5a39a1a407bbf">type</a>;
<a name="l00331"></a>00331 };
<a name="l00332"></a>00332 
<a name="l00333"></a>00333 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5&gt;
<a name="l00334"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult5.html">00334</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AllOfResult5.html">AllOfResult5</a> {
<a name="l00335"></a>00335   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">BothOfMatcher</a>&lt;
<a name="l00336"></a>00336       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult2&lt;M1, M2&gt;::type</a>,
<a name="l00337"></a>00337       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult3&lt;M3, M4, M5&gt;::type</a>
<a name="l00338"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult5.html#aee2e1fb803f428741d147347b692d108">00338</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AllOfResult5.html#aee2e1fb803f428741d147347b692d108">type</a>;
<a name="l00339"></a>00339 };
<a name="l00340"></a>00340 
<a name="l00341"></a>00341 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l00342"></a>00342     <span class="keyword">typename</span> M6&gt;
<a name="l00343"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult6.html">00343</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AllOfResult6.html">AllOfResult6</a> {
<a name="l00344"></a>00344   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">BothOfMatcher</a>&lt;
<a name="l00345"></a>00345       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult3&lt;M1, M2, M3&gt;::type</a>,
<a name="l00346"></a>00346       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult3&lt;M4, M5, M6&gt;::type</a>
<a name="l00347"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult6.html#a5385655911ce2c1d3fccd802c1754139">00347</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AllOfResult6.html#a5385655911ce2c1d3fccd802c1754139">type</a>;
<a name="l00348"></a>00348 };
<a name="l00349"></a>00349 
<a name="l00350"></a>00350 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l00351"></a>00351     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7&gt;
<a name="l00352"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult7.html">00352</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AllOfResult7.html">AllOfResult7</a> {
<a name="l00353"></a>00353   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">BothOfMatcher</a>&lt;
<a name="l00354"></a>00354       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult3&lt;M1, M2, M3&gt;::type</a>,
<a name="l00355"></a>00355       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult4&lt;M4, M5, M6, M7&gt;::type</a>
<a name="l00356"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult7.html#a47ab0d670258434b0e65530591948e8c">00356</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AllOfResult7.html#a47ab0d670258434b0e65530591948e8c">type</a>;
<a name="l00357"></a>00357 };
<a name="l00358"></a>00358 
<a name="l00359"></a>00359 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l00360"></a>00360     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7, <span class="keyword">typename</span> M8&gt;
<a name="l00361"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult8.html">00361</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AllOfResult8.html">AllOfResult8</a> {
<a name="l00362"></a>00362   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">BothOfMatcher</a>&lt;
<a name="l00363"></a>00363       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult4&lt;M1, M2, M3, M4&gt;::type</a>,
<a name="l00364"></a>00364       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult4&lt;M5, M6, M7, M8&gt;::type</a>
<a name="l00365"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult8.html#a7103892a28c35221b9e62e871c577727">00365</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AllOfResult8.html#a7103892a28c35221b9e62e871c577727">type</a>;
<a name="l00366"></a>00366 };
<a name="l00367"></a>00367 
<a name="l00368"></a>00368 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l00369"></a>00369     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7, <span class="keyword">typename</span> M8, <span class="keyword">typename</span> M9&gt;
<a name="l00370"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult9.html">00370</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AllOfResult9.html">AllOfResult9</a> {
<a name="l00371"></a>00371   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">BothOfMatcher</a>&lt;
<a name="l00372"></a>00372       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult4&lt;M1, M2, M3, M4&gt;::type</a>,
<a name="l00373"></a>00373       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult5&lt;M5, M6, M7, M8, M9&gt;::type</a>
<a name="l00374"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult9.html#ade56e18d2e0b745968b87fc394710edc">00374</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AllOfResult9.html#ade56e18d2e0b745968b87fc394710edc">type</a>;
<a name="l00375"></a>00375 };
<a name="l00376"></a>00376 
<a name="l00377"></a>00377 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l00378"></a>00378     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7, <span class="keyword">typename</span> M8, <span class="keyword">typename</span> M9, <span class="keyword">typename</span> M10&gt;
<a name="l00379"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult10.html">00379</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AllOfResult10.html">AllOfResult10</a> {
<a name="l00380"></a>00380   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">BothOfMatcher</a>&lt;
<a name="l00381"></a>00381       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult5&lt;M1, M2, M3, M4, M5&gt;::type</a>,
<a name="l00382"></a>00382       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1BothOfMatcher.html">AllOfResult5&lt;M6, M7, M8, M9, M10&gt;::type</a>
<a name="l00383"></a><a class="code" href="structtesting_1_1internal_1_1AllOfResult10.html#a48d6c6de6d0d5445b212119e1f536af5">00383</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AllOfResult10.html#a48d6c6de6d0d5445b212119e1f536af5">type</a>;
<a name="l00384"></a>00384 };
<a name="l00385"></a>00385 
<a name="l00386"></a>00386 <span class="comment">// A set of metafunctions for computing the result type of AnyOf.</span>
<a name="l00387"></a>00387 <span class="comment">// AnyOf(m1, ..., mN) returns</span>
<a name="l00388"></a>00388 <span class="comment">// AnyOfResultN&lt;decltype(m1), ..., decltype(mN)&gt;::type.</span>
<a name="l00389"></a>00389 
<a name="l00390"></a>00390 <span class="comment">// Although AnyOf isn&#39;t defined for one argument, AnyOfResult1 is defined</span>
<a name="l00391"></a>00391 <span class="comment">// to simplify the implementation.</span>
<a name="l00392"></a>00392 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1&gt;
<a name="l00393"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult1.html">00393</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AnyOfResult1.html">AnyOfResult1</a> {
<a name="l00394"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult1.html#a4c55b5cf196c93e2a822bc99625f6797">00394</a>   <span class="keyword">typedef</span> M1 <a class="code" href="structtesting_1_1internal_1_1AnyOfResult1.html#a4c55b5cf196c93e2a822bc99625f6797">type</a>;
<a name="l00395"></a>00395 };
<a name="l00396"></a>00396 
<a name="l00397"></a>00397 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2&gt;
<a name="l00398"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult2.html">00398</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AnyOfResult2.html">AnyOfResult2</a> {
<a name="l00399"></a>00399   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">EitherOfMatcher</a>&lt;
<a name="l00400"></a>00400       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AnyOfResult1.html#a4c55b5cf196c93e2a822bc99625f6797">AnyOfResult1&lt;M1&gt;::type</a>,
<a name="l00401"></a>00401       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AnyOfResult1.html#a4c55b5cf196c93e2a822bc99625f6797">AnyOfResult1&lt;M2&gt;::type</a>
<a name="l00402"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult2.html#a6d9eba508021f8e652c7c154a649073f">00402</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AnyOfResult2.html#a6d9eba508021f8e652c7c154a649073f">type</a>;
<a name="l00403"></a>00403 };
<a name="l00404"></a>00404 
<a name="l00405"></a>00405 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3&gt;
<a name="l00406"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult3.html">00406</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AnyOfResult3.html">AnyOfResult3</a> {
<a name="l00407"></a>00407   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">EitherOfMatcher</a>&lt;
<a name="l00408"></a>00408       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AnyOfResult1.html#a4c55b5cf196c93e2a822bc99625f6797">AnyOfResult1&lt;M1&gt;::type</a>,
<a name="l00409"></a>00409       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult2&lt;M2, M3&gt;::type</a>
<a name="l00410"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult3.html#a232b20553cc0a33a6741e85e19ef4b0c">00410</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AnyOfResult3.html#a232b20553cc0a33a6741e85e19ef4b0c">type</a>;
<a name="l00411"></a>00411 };
<a name="l00412"></a>00412 
<a name="l00413"></a>00413 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4&gt;
<a name="l00414"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult4.html">00414</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AnyOfResult4.html">AnyOfResult4</a> {
<a name="l00415"></a>00415   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">EitherOfMatcher</a>&lt;
<a name="l00416"></a>00416       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult2&lt;M1, M2&gt;::type</a>,
<a name="l00417"></a>00417       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult2&lt;M3, M4&gt;::type</a>
<a name="l00418"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult4.html#a4f3c9aebb4f7fc24287b59a0bdf1a4a6">00418</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AnyOfResult4.html#a4f3c9aebb4f7fc24287b59a0bdf1a4a6">type</a>;
<a name="l00419"></a>00419 };
<a name="l00420"></a>00420 
<a name="l00421"></a>00421 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5&gt;
<a name="l00422"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult5.html">00422</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AnyOfResult5.html">AnyOfResult5</a> {
<a name="l00423"></a>00423   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">EitherOfMatcher</a>&lt;
<a name="l00424"></a>00424       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult2&lt;M1, M2&gt;::type</a>,
<a name="l00425"></a>00425       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult3&lt;M3, M4, M5&gt;::type</a>
<a name="l00426"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult5.html#a459a06dc5791313dce942668714f0c99">00426</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AnyOfResult5.html#a459a06dc5791313dce942668714f0c99">type</a>;
<a name="l00427"></a>00427 };
<a name="l00428"></a>00428 
<a name="l00429"></a>00429 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l00430"></a>00430     <span class="keyword">typename</span> M6&gt;
<a name="l00431"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult6.html">00431</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AnyOfResult6.html">AnyOfResult6</a> {
<a name="l00432"></a>00432   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">EitherOfMatcher</a>&lt;
<a name="l00433"></a>00433       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult3&lt;M1, M2, M3&gt;::type</a>,
<a name="l00434"></a>00434       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult3&lt;M4, M5, M6&gt;::type</a>
<a name="l00435"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult6.html#a15837eb05d9ac5a76c20d344a4988dd1">00435</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AnyOfResult6.html#a15837eb05d9ac5a76c20d344a4988dd1">type</a>;
<a name="l00436"></a>00436 };
<a name="l00437"></a>00437 
<a name="l00438"></a>00438 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l00439"></a>00439     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7&gt;
<a name="l00440"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult7.html">00440</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AnyOfResult7.html">AnyOfResult7</a> {
<a name="l00441"></a>00441   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">EitherOfMatcher</a>&lt;
<a name="l00442"></a>00442       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult3&lt;M1, M2, M3&gt;::type</a>,
<a name="l00443"></a>00443       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult4&lt;M4, M5, M6, M7&gt;::type</a>
<a name="l00444"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult7.html#a976873478921520833464a86f840abe8">00444</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AnyOfResult7.html#a976873478921520833464a86f840abe8">type</a>;
<a name="l00445"></a>00445 };
<a name="l00446"></a>00446 
<a name="l00447"></a>00447 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l00448"></a>00448     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7, <span class="keyword">typename</span> M8&gt;
<a name="l00449"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult8.html">00449</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AnyOfResult8.html">AnyOfResult8</a> {
<a name="l00450"></a>00450   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">EitherOfMatcher</a>&lt;
<a name="l00451"></a>00451       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult4&lt;M1, M2, M3, M4&gt;::type</a>,
<a name="l00452"></a>00452       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult4&lt;M5, M6, M7, M8&gt;::type</a>
<a name="l00453"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult8.html#a8f8a1e78a019965c24bd22c78885747d">00453</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AnyOfResult8.html#a8f8a1e78a019965c24bd22c78885747d">type</a>;
<a name="l00454"></a>00454 };
<a name="l00455"></a>00455 
<a name="l00456"></a>00456 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l00457"></a>00457     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7, <span class="keyword">typename</span> M8, <span class="keyword">typename</span> M9&gt;
<a name="l00458"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult9.html">00458</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AnyOfResult9.html">AnyOfResult9</a> {
<a name="l00459"></a>00459   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">EitherOfMatcher</a>&lt;
<a name="l00460"></a>00460       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult4&lt;M1, M2, M3, M4&gt;::type</a>,
<a name="l00461"></a>00461       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult5&lt;M5, M6, M7, M8, M9&gt;::type</a>
<a name="l00462"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult9.html#a308935fb02c62f502044dcc7b0a2b464">00462</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AnyOfResult9.html#a308935fb02c62f502044dcc7b0a2b464">type</a>;
<a name="l00463"></a>00463 };
<a name="l00464"></a>00464 
<a name="l00465"></a>00465 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l00466"></a>00466     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7, <span class="keyword">typename</span> M8, <span class="keyword">typename</span> M9, <span class="keyword">typename</span> M10&gt;
<a name="l00467"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult10.html">00467</a> <span class="keyword">struct </span><a class="code" href="structtesting_1_1internal_1_1AnyOfResult10.html">AnyOfResult10</a> {
<a name="l00468"></a>00468   <span class="keyword">typedef</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">EitherOfMatcher</a>&lt;
<a name="l00469"></a>00469       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult5&lt;M1, M2, M3, M4, M5&gt;::type</a>,
<a name="l00470"></a>00470       <span class="keyword">typename</span> <a class="code" href="classtesting_1_1internal_1_1EitherOfMatcher.html">AnyOfResult5&lt;M6, M7, M8, M9, M10&gt;::type</a>
<a name="l00471"></a><a class="code" href="structtesting_1_1internal_1_1AnyOfResult10.html#aa1cb3d733f29716f2015db8a2b6c1c94">00471</a>   &gt; <a class="code" href="structtesting_1_1internal_1_1AnyOfResult10.html#aa1cb3d733f29716f2015db8a2b6c1c94">type</a>;
<a name="l00472"></a>00472 };
<a name="l00473"></a>00473 
<a name="l00474"></a>00474 }  <span class="comment">// namespace internal</span>
<a name="l00475"></a>00475 
<a name="l00476"></a>00476 <span class="comment">// Args&lt;N1, N2, ..., Nk&gt;(a_matcher) matches a tuple if the selected</span>
<a name="l00477"></a>00477 <span class="comment">// fields of it matches a_matcher.  C++ doesn&#39;t support default</span>
<a name="l00478"></a>00478 <span class="comment">// arguments for function templates, so we have to overload it.</span>
<a name="l00479"></a>00479 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> InnerMatcher&gt;
<a name="l00480"></a>00480 <span class="keyword">inline</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">internal::ArgsMatcher&lt;InnerMatcher&gt;</a>
<a name="l00481"></a><a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">00481</a> <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(<span class="keyword">const</span> InnerMatcher&amp; matcher) {
<a name="l00482"></a>00482   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">internal::ArgsMatcher&lt;InnerMatcher&gt;</a>(matcher);
<a name="l00483"></a>00483 }
<a name="l00484"></a>00484 
<a name="l00485"></a>00485 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> k1, <span class="keyword">typename</span> InnerMatcher&gt;
<a name="l00486"></a>00486 <span class="keyword">inline</span> internal::ArgsMatcher&lt;InnerMatcher, k1&gt;
<a name="l00487"></a><a class="code" href="namespacetesting.html#af67bac6da407df7586f60cfa2c9b602d">00487</a> <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(<span class="keyword">const</span> InnerMatcher&amp; matcher) {
<a name="l00488"></a>00488   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">internal::ArgsMatcher&lt;InnerMatcher, k1&gt;</a>(matcher);
<a name="l00489"></a>00489 }
<a name="l00490"></a>00490 
<a name="l00491"></a>00491 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keyword">typename</span> InnerMatcher&gt;
<a name="l00492"></a>00492 <span class="keyword">inline</span> internal::ArgsMatcher&lt;InnerMatcher, k1, k2&gt;
<a name="l00493"></a><a class="code" href="namespacetesting.html#a663409e441584c81f496e9c98fd3453c">00493</a> <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(<span class="keyword">const</span> InnerMatcher&amp; matcher) {
<a name="l00494"></a>00494   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">internal::ArgsMatcher&lt;InnerMatcher, k1, k2&gt;</a>(matcher);
<a name="l00495"></a>00495 }
<a name="l00496"></a>00496 
<a name="l00497"></a>00497 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keyword">typename</span> InnerMatcher&gt;
<a name="l00498"></a>00498 <span class="keyword">inline</span> internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3&gt;
<a name="l00499"></a><a class="code" href="namespacetesting.html#abd3ddae153e1c452b7625808cc4d820b">00499</a> <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(<span class="keyword">const</span> InnerMatcher&amp; matcher) {
<a name="l00500"></a>00500   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3&gt;</a>(matcher);
<a name="l00501"></a>00501 }
<a name="l00502"></a>00502 
<a name="l00503"></a>00503 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4, <span class="keyword">typename</span> InnerMatcher&gt;
<a name="l00504"></a>00504 <span class="keyword">inline</span> internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4&gt;
<a name="l00505"></a><a class="code" href="namespacetesting.html#aeff7e644fd00516c3519fe8c0dc1aee2">00505</a> <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(<span class="keyword">const</span> InnerMatcher&amp; matcher) {
<a name="l00506"></a>00506   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4&gt;</a>(matcher);
<a name="l00507"></a>00507 }
<a name="l00508"></a>00508 
<a name="l00509"></a>00509 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4, <span class="keywordtype">int</span> k5, <span class="keyword">typename</span> InnerMatcher&gt;
<a name="l00510"></a>00510 <span class="keyword">inline</span> internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5&gt;
<a name="l00511"></a><a class="code" href="namespacetesting.html#aede9fd33cce0d21f5e31ba10a0706827">00511</a> <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(<span class="keyword">const</span> InnerMatcher&amp; matcher) {
<a name="l00512"></a>00512   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5&gt;</a>(matcher);
<a name="l00513"></a>00513 }
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4, <span class="keywordtype">int</span> k5, <span class="keywordtype">int</span> k6, <span class="keyword">typename</span> InnerMatcher&gt;
<a name="l00516"></a>00516 <span class="keyword">inline</span> internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6&gt;
<a name="l00517"></a><a class="code" href="namespacetesting.html#abc92e87b4a9cad372b082d81479f3d48">00517</a> <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(<span class="keyword">const</span> InnerMatcher&amp; matcher) {
<a name="l00518"></a>00518   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6&gt;</a>(matcher);
<a name="l00519"></a>00519 }
<a name="l00520"></a>00520 
<a name="l00521"></a>00521 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4, <span class="keywordtype">int</span> k5, <span class="keywordtype">int</span> k6, <span class="keywordtype">int</span> k7,
<a name="l00522"></a>00522     <span class="keyword">typename</span> InnerMatcher&gt;
<a name="l00523"></a>00523 <span class="keyword">inline</span> internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7&gt;
<a name="l00524"></a><a class="code" href="namespacetesting.html#a9a9ef7a866b397430527076e342817f9">00524</a> <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(<span class="keyword">const</span> InnerMatcher&amp; matcher) {
<a name="l00525"></a>00525   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">internal::ArgsMatcher</a>&lt;InnerMatcher, k1, k2, k3, k4, k5, k6,
<a name="l00526"></a>00526       k7&gt;(matcher);
<a name="l00527"></a>00527 }
<a name="l00528"></a>00528 
<a name="l00529"></a>00529 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4, <span class="keywordtype">int</span> k5, <span class="keywordtype">int</span> k6, <span class="keywordtype">int</span> k7, <span class="keywordtype">int</span> k8,
<a name="l00530"></a>00530     <span class="keyword">typename</span> InnerMatcher&gt;
<a name="l00531"></a>00531 <span class="keyword">inline</span> internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8&gt;
<a name="l00532"></a><a class="code" href="namespacetesting.html#ae8a4e8e1b8eb87c9f1e5f02519da7fce">00532</a> <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(<span class="keyword">const</span> InnerMatcher&amp; matcher) {
<a name="l00533"></a>00533   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">internal::ArgsMatcher</a>&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7,
<a name="l00534"></a>00534       k8&gt;(matcher);
<a name="l00535"></a>00535 }
<a name="l00536"></a>00536 
<a name="l00537"></a>00537 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4, <span class="keywordtype">int</span> k5, <span class="keywordtype">int</span> k6, <span class="keywordtype">int</span> k7, <span class="keywordtype">int</span> k8,
<a name="l00538"></a>00538     <span class="keywordtype">int</span> k9, <span class="keyword">typename</span> InnerMatcher&gt;
<a name="l00539"></a>00539 <span class="keyword">inline</span> internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8, k9&gt;
<a name="l00540"></a><a class="code" href="namespacetesting.html#a62c877e01fb9098cd3c399f921bf4e3e">00540</a> <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(<span class="keyword">const</span> InnerMatcher&amp; matcher) {
<a name="l00541"></a>00541   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">internal::ArgsMatcher</a>&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8,
<a name="l00542"></a>00542       k9&gt;(matcher);
<a name="l00543"></a>00543 }
<a name="l00544"></a>00544 
<a name="l00545"></a>00545 <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> k1, <span class="keywordtype">int</span> k2, <span class="keywordtype">int</span> k3, <span class="keywordtype">int</span> k4, <span class="keywordtype">int</span> k5, <span class="keywordtype">int</span> k6, <span class="keywordtype">int</span> k7, <span class="keywordtype">int</span> k8,
<a name="l00546"></a>00546     <span class="keywordtype">int</span> k9, <span class="keywordtype">int</span> k10, <span class="keyword">typename</span> InnerMatcher&gt;
<a name="l00547"></a>00547 <span class="keyword">inline</span> internal::ArgsMatcher&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8, k9,
<a name="l00548"></a>00548     k10&gt;
<a name="l00549"></a><a class="code" href="namespacetesting.html#a09ac462e8d6ed468cbfaa9c767aee0aa">00549</a> <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(<span class="keyword">const</span> InnerMatcher&amp; matcher) {
<a name="l00550"></a>00550   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ArgsMatcher.html">internal::ArgsMatcher</a>&lt;InnerMatcher, k1, k2, k3, k4, k5, k6, k7, k8,
<a name="l00551"></a>00551       k9, k10&gt;(matcher);
<a name="l00552"></a>00552 }
<a name="l00553"></a>00553 
<a name="l00554"></a>00554 <span class="comment">// ElementsAre(e_1, e_2, ... e_n) matches an STL-style container with</span>
<a name="l00555"></a>00555 <span class="comment">// n elements, where the i-th element in the container must</span>
<a name="l00556"></a>00556 <span class="comment">// match the i-th argument in the list.  Each argument of</span>
<a name="l00557"></a>00557 <span class="comment">// ElementsAre() can be either a value or a matcher.  We support up to</span>
<a name="l00558"></a>00558 <span class="comment">// 10 arguments.</span>
<a name="l00559"></a>00559 <span class="comment">//</span>
<a name="l00560"></a>00560 <span class="comment">// The use of DecayArray in the implementation allows ElementsAre()</span>
<a name="l00561"></a>00561 <span class="comment">// to accept string literals, whose type is const char[N], but we</span>
<a name="l00562"></a>00562 <span class="comment">// want to treat them as const char*.</span>
<a name="l00563"></a>00563 <span class="comment">//</span>
<a name="l00564"></a>00564 <span class="comment">// NOTE: Since ElementsAre() cares about the order of the elements, it</span>
<a name="l00565"></a>00565 <span class="comment">// must not be used with containers whose elements&#39;s order is</span>
<a name="l00566"></a>00566 <span class="comment">// undefined (e.g. hash_map).</span>
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 <span class="keyword">inline</span> internal::ElementsAreMatcher&lt;
<a name="l00569"></a>00569     ::testing::tuple&lt;&gt; &gt;
<a name="l00570"></a><a class="code" href="namespacetesting.html#a79cf4ae694bf8231dcf283b325405f27">00570</a> <a class="code" href="namespacetesting.html#a79cf4ae694bf8231dcf283b325405f27">ElementsAre</a>() {
<a name="l00571"></a>00571   typedef ::testing::tuple&lt;&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00572"></a>00572   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ElementsAreMatcher.html">internal::ElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>());
<a name="l00573"></a>00573 }
<a name="l00574"></a>00574 
<a name="l00575"></a>00575 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;
<a name="l00576"></a>00576 <span class="keyword">inline</span> internal::ElementsAreMatcher&lt;
<a name="l00577"></a>00577     ::testing::tuple&lt;
<a name="l00578"></a>00578         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type&gt; &gt;
<a name="l00579"></a><a class="code" href="namespacetesting.html#aa35aa6c9638d989e9f4aaa6009f60589">00579</a> <a class="code" href="namespacetesting.html#a79cf4ae694bf8231dcf283b325405f27">ElementsAre</a>(<span class="keyword">const</span> T1&amp; e1) {
<a name="l00580"></a>00580   typedef ::testing::tuple&lt;
<a name="l00581"></a>00581       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00582"></a>00582   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ElementsAreMatcher.html">internal::ElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1));
<a name="l00583"></a>00583 }
<a name="l00584"></a>00584 
<a name="l00585"></a>00585 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l00586"></a>00586 <span class="keyword">inline</span> internal::ElementsAreMatcher&lt;
<a name="l00587"></a>00587     ::testing::tuple&lt;
<a name="l00588"></a>00588         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00589"></a>00589         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type&gt; &gt;
<a name="l00590"></a><a class="code" href="namespacetesting.html#a864f77fe7774308d4c54f1f52f9040cf">00590</a> <a class="code" href="namespacetesting.html#a79cf4ae694bf8231dcf283b325405f27">ElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2) {
<a name="l00591"></a>00591   typedef ::testing::tuple&lt;
<a name="l00592"></a>00592       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00593"></a>00593       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00594"></a>00594   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ElementsAreMatcher.html">internal::ElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2));
<a name="l00595"></a>00595 }
<a name="l00596"></a>00596 
<a name="l00597"></a>00597 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;
<a name="l00598"></a>00598 <span class="keyword">inline</span> internal::ElementsAreMatcher&lt;
<a name="l00599"></a>00599     ::testing::tuple&lt;
<a name="l00600"></a>00600         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00601"></a>00601         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00602"></a>00602         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type&gt; &gt;
<a name="l00603"></a><a class="code" href="namespacetesting.html#a0be8a0ad5d7461fd1da13ecac4e21e2a">00603</a> <a class="code" href="namespacetesting.html#a79cf4ae694bf8231dcf283b325405f27">ElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3) {
<a name="l00604"></a>00604   typedef ::testing::tuple&lt;
<a name="l00605"></a>00605       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00606"></a>00606       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00607"></a>00607       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00608"></a>00608   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ElementsAreMatcher.html">internal::ElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3));
<a name="l00609"></a>00609 }
<a name="l00610"></a>00610 
<a name="l00611"></a>00611 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4&gt;
<a name="l00612"></a>00612 <span class="keyword">inline</span> internal::ElementsAreMatcher&lt;
<a name="l00613"></a>00613     ::testing::tuple&lt;
<a name="l00614"></a>00614         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00615"></a>00615         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00616"></a>00616         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00617"></a>00617         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type&gt; &gt;
<a name="l00618"></a><a class="code" href="namespacetesting.html#a4109ce480e0145bfce7c46120afb36d3">00618</a> <a class="code" href="namespacetesting.html#a79cf4ae694bf8231dcf283b325405f27">ElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4) {
<a name="l00619"></a>00619   typedef ::testing::tuple&lt;
<a name="l00620"></a>00620       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00621"></a>00621       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00622"></a>00622       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00623"></a>00623       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00624"></a>00624   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ElementsAreMatcher.html">internal::ElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4));
<a name="l00625"></a>00625 }
<a name="l00626"></a>00626 
<a name="l00627"></a>00627 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5&gt;
<a name="l00628"></a>00628 <span class="keyword">inline</span> internal::ElementsAreMatcher&lt;
<a name="l00629"></a>00629     ::testing::tuple&lt;
<a name="l00630"></a>00630         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00631"></a>00631         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00632"></a>00632         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00633"></a>00633         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type,
<a name="l00634"></a>00634         <span class="keyword">typename</span> internal::DecayArray&lt;T5&gt;::type&gt; &gt;
<a name="l00635"></a><a class="code" href="namespacetesting.html#aa075d52e84310659ca8636c6e7d5c9b2">00635</a> <a class="code" href="namespacetesting.html#a79cf4ae694bf8231dcf283b325405f27">ElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4,
<a name="l00636"></a>00636     <span class="keyword">const</span> T5&amp; e5) {
<a name="l00637"></a>00637   typedef ::testing::tuple&lt;
<a name="l00638"></a>00638       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00639"></a>00639       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00640"></a>00640       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00641"></a>00641       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>,
<a name="l00642"></a>00642       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T5&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00643"></a>00643   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ElementsAreMatcher.html">internal::ElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4, e5));
<a name="l00644"></a>00644 }
<a name="l00645"></a>00645 
<a name="l00646"></a>00646 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5,
<a name="l00647"></a>00647     <span class="keyword">typename</span> T6&gt;
<a name="l00648"></a>00648 <span class="keyword">inline</span> internal::ElementsAreMatcher&lt;
<a name="l00649"></a>00649     ::testing::tuple&lt;
<a name="l00650"></a>00650         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00651"></a>00651         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00652"></a>00652         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00653"></a>00653         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type,
<a name="l00654"></a>00654         <span class="keyword">typename</span> internal::DecayArray&lt;T5&gt;::type,
<a name="l00655"></a>00655         <span class="keyword">typename</span> internal::DecayArray&lt;T6&gt;::type&gt; &gt;
<a name="l00656"></a><a class="code" href="namespacetesting.html#a725b7a52e5eea9fe8f4ce46be6fd7159">00656</a> <a class="code" href="namespacetesting.html#a79cf4ae694bf8231dcf283b325405f27">ElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4,
<a name="l00657"></a>00657     <span class="keyword">const</span> T5&amp; e5, <span class="keyword">const</span> T6&amp; e6) {
<a name="l00658"></a>00658   typedef ::testing::tuple&lt;
<a name="l00659"></a>00659       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00660"></a>00660       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00661"></a>00661       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00662"></a>00662       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>,
<a name="l00663"></a>00663       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T5&gt;::type</a>,
<a name="l00664"></a>00664       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T6&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00665"></a>00665   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ElementsAreMatcher.html">internal::ElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4, e5, e6));
<a name="l00666"></a>00666 }
<a name="l00667"></a>00667 
<a name="l00668"></a>00668 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5,
<a name="l00669"></a>00669     <span class="keyword">typename</span> T6, <span class="keyword">typename</span> T7&gt;
<a name="l00670"></a>00670 <span class="keyword">inline</span> internal::ElementsAreMatcher&lt;
<a name="l00671"></a>00671     ::testing::tuple&lt;
<a name="l00672"></a>00672         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00673"></a>00673         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00674"></a>00674         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00675"></a>00675         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type,
<a name="l00676"></a>00676         <span class="keyword">typename</span> internal::DecayArray&lt;T5&gt;::type,
<a name="l00677"></a>00677         <span class="keyword">typename</span> internal::DecayArray&lt;T6&gt;::type,
<a name="l00678"></a>00678         <span class="keyword">typename</span> internal::DecayArray&lt;T7&gt;::type&gt; &gt;
<a name="l00679"></a><a class="code" href="namespacetesting.html#a3af9f549d951a4961825f821e6d47da9">00679</a> <a class="code" href="namespacetesting.html#a79cf4ae694bf8231dcf283b325405f27">ElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4,
<a name="l00680"></a>00680     <span class="keyword">const</span> T5&amp; e5, <span class="keyword">const</span> T6&amp; e6, <span class="keyword">const</span> T7&amp; e7) {
<a name="l00681"></a>00681   typedef ::testing::tuple&lt;
<a name="l00682"></a>00682       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00683"></a>00683       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00684"></a>00684       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00685"></a>00685       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>,
<a name="l00686"></a>00686       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T5&gt;::type</a>,
<a name="l00687"></a>00687       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T6&gt;::type</a>,
<a name="l00688"></a>00688       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T7&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00689"></a>00689   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ElementsAreMatcher.html">internal::ElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4, e5, e6, e7));
<a name="l00690"></a>00690 }
<a name="l00691"></a>00691 
<a name="l00692"></a>00692 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5,
<a name="l00693"></a>00693     <span class="keyword">typename</span> T6, <span class="keyword">typename</span> T7, <span class="keyword">typename</span> T8&gt;
<a name="l00694"></a>00694 <span class="keyword">inline</span> internal::ElementsAreMatcher&lt;
<a name="l00695"></a>00695     ::testing::tuple&lt;
<a name="l00696"></a>00696         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00697"></a>00697         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00698"></a>00698         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00699"></a>00699         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type,
<a name="l00700"></a>00700         <span class="keyword">typename</span> internal::DecayArray&lt;T5&gt;::type,
<a name="l00701"></a>00701         <span class="keyword">typename</span> internal::DecayArray&lt;T6&gt;::type,
<a name="l00702"></a>00702         <span class="keyword">typename</span> internal::DecayArray&lt;T7&gt;::type,
<a name="l00703"></a>00703         <span class="keyword">typename</span> internal::DecayArray&lt;T8&gt;::type&gt; &gt;
<a name="l00704"></a><a class="code" href="namespacetesting.html#a8d498031827c1d089dc84f5f14b7df12">00704</a> <a class="code" href="namespacetesting.html#a79cf4ae694bf8231dcf283b325405f27">ElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4,
<a name="l00705"></a>00705     <span class="keyword">const</span> T5&amp; e5, <span class="keyword">const</span> T6&amp; e6, <span class="keyword">const</span> T7&amp; e7, <span class="keyword">const</span> T8&amp; e8) {
<a name="l00706"></a>00706   typedef ::testing::tuple&lt;
<a name="l00707"></a>00707       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00708"></a>00708       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00709"></a>00709       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00710"></a>00710       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>,
<a name="l00711"></a>00711       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T5&gt;::type</a>,
<a name="l00712"></a>00712       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T6&gt;::type</a>,
<a name="l00713"></a>00713       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T7&gt;::type</a>,
<a name="l00714"></a>00714       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T8&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00715"></a>00715   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ElementsAreMatcher.html">internal::ElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4, e5, e6, e7,
<a name="l00716"></a>00716       e8));
<a name="l00717"></a>00717 }
<a name="l00718"></a>00718 
<a name="l00719"></a>00719 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5,
<a name="l00720"></a>00720     <span class="keyword">typename</span> T6, <span class="keyword">typename</span> T7, <span class="keyword">typename</span> T8, <span class="keyword">typename</span> T9&gt;
<a name="l00721"></a>00721 <span class="keyword">inline</span> internal::ElementsAreMatcher&lt;
<a name="l00722"></a>00722     ::testing::tuple&lt;
<a name="l00723"></a>00723         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00724"></a>00724         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00725"></a>00725         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00726"></a>00726         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type,
<a name="l00727"></a>00727         <span class="keyword">typename</span> internal::DecayArray&lt;T5&gt;::type,
<a name="l00728"></a>00728         <span class="keyword">typename</span> internal::DecayArray&lt;T6&gt;::type,
<a name="l00729"></a>00729         <span class="keyword">typename</span> internal::DecayArray&lt;T7&gt;::type,
<a name="l00730"></a>00730         <span class="keyword">typename</span> internal::DecayArray&lt;T8&gt;::type,
<a name="l00731"></a>00731         <span class="keyword">typename</span> internal::DecayArray&lt;T9&gt;::type&gt; &gt;
<a name="l00732"></a><a class="code" href="namespacetesting.html#aa39ad709c933dbbbe3cbaececa8b4577">00732</a> <a class="code" href="namespacetesting.html#a79cf4ae694bf8231dcf283b325405f27">ElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4,
<a name="l00733"></a>00733     <span class="keyword">const</span> T5&amp; e5, <span class="keyword">const</span> T6&amp; e6, <span class="keyword">const</span> T7&amp; e7, <span class="keyword">const</span> T8&amp; e8, <span class="keyword">const</span> T9&amp; e9) {
<a name="l00734"></a>00734   typedef ::testing::tuple&lt;
<a name="l00735"></a>00735       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00736"></a>00736       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00737"></a>00737       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00738"></a>00738       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>,
<a name="l00739"></a>00739       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T5&gt;::type</a>,
<a name="l00740"></a>00740       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T6&gt;::type</a>,
<a name="l00741"></a>00741       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T7&gt;::type</a>,
<a name="l00742"></a>00742       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T8&gt;::type</a>,
<a name="l00743"></a>00743       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T9&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00744"></a>00744   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ElementsAreMatcher.html">internal::ElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4, e5, e6, e7,
<a name="l00745"></a>00745       e8, e9));
<a name="l00746"></a>00746 }
<a name="l00747"></a>00747 
<a name="l00748"></a>00748 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5,
<a name="l00749"></a>00749     <span class="keyword">typename</span> T6, <span class="keyword">typename</span> T7, <span class="keyword">typename</span> T8, <span class="keyword">typename</span> T9, <span class="keyword">typename</span> T10&gt;
<a name="l00750"></a>00750 <span class="keyword">inline</span> internal::ElementsAreMatcher&lt;
<a name="l00751"></a>00751     ::testing::tuple&lt;
<a name="l00752"></a>00752         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00753"></a>00753         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00754"></a>00754         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00755"></a>00755         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type,
<a name="l00756"></a>00756         <span class="keyword">typename</span> internal::DecayArray&lt;T5&gt;::type,
<a name="l00757"></a>00757         <span class="keyword">typename</span> internal::DecayArray&lt;T6&gt;::type,
<a name="l00758"></a>00758         <span class="keyword">typename</span> internal::DecayArray&lt;T7&gt;::type,
<a name="l00759"></a>00759         <span class="keyword">typename</span> internal::DecayArray&lt;T8&gt;::type,
<a name="l00760"></a>00760         <span class="keyword">typename</span> internal::DecayArray&lt;T9&gt;::type,
<a name="l00761"></a>00761         <span class="keyword">typename</span> internal::DecayArray&lt;T10&gt;::type&gt; &gt;
<a name="l00762"></a><a class="code" href="namespacetesting.html#a047f5f5a28c156a70002668323009ae9">00762</a> <a class="code" href="namespacetesting.html#a79cf4ae694bf8231dcf283b325405f27">ElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4,
<a name="l00763"></a>00763     <span class="keyword">const</span> T5&amp; e5, <span class="keyword">const</span> T6&amp; e6, <span class="keyword">const</span> T7&amp; e7, <span class="keyword">const</span> T8&amp; e8, <span class="keyword">const</span> T9&amp; e9,
<a name="l00764"></a>00764     <span class="keyword">const</span> T10&amp; e10) {
<a name="l00765"></a>00765   typedef ::testing::tuple&lt;
<a name="l00766"></a>00766       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00767"></a>00767       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00768"></a>00768       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00769"></a>00769       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>,
<a name="l00770"></a>00770       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T5&gt;::type</a>,
<a name="l00771"></a>00771       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T6&gt;::type</a>,
<a name="l00772"></a>00772       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T7&gt;::type</a>,
<a name="l00773"></a>00773       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T8&gt;::type</a>,
<a name="l00774"></a>00774       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T9&gt;::type</a>,
<a name="l00775"></a>00775       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T10&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00776"></a>00776   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1ElementsAreMatcher.html">internal::ElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4, e5, e6, e7,
<a name="l00777"></a>00777       e8, e9, e10));
<a name="l00778"></a>00778 }
<a name="l00779"></a>00779 
<a name="l00780"></a>00780 <span class="comment">// UnorderedElementsAre(e_1, e_2, ..., e_n) is an ElementsAre extension</span>
<a name="l00781"></a>00781 <span class="comment">// that matches n elements in any order.  We support up to n=10 arguments.</span>
<a name="l00782"></a>00782 
<a name="l00783"></a>00783 <span class="keyword">inline</span> internal::UnorderedElementsAreMatcher&lt;
<a name="l00784"></a>00784     ::testing::tuple&lt;&gt; &gt;
<a name="l00785"></a><a class="code" href="namespacetesting.html#a8622c12aadfa0e60f7d68683eeb21115">00785</a> <a class="code" href="namespacetesting.html#a8622c12aadfa0e60f7d68683eeb21115">UnorderedElementsAre</a>() {
<a name="l00786"></a>00786   typedef ::testing::tuple&lt;&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00787"></a>00787   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1UnorderedElementsAreMatcher.html">internal::UnorderedElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>());
<a name="l00788"></a>00788 }
<a name="l00789"></a>00789 
<a name="l00790"></a>00790 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1&gt;
<a name="l00791"></a>00791 <span class="keyword">inline</span> internal::UnorderedElementsAreMatcher&lt;
<a name="l00792"></a>00792     ::testing::tuple&lt;
<a name="l00793"></a>00793         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type&gt; &gt;
<a name="l00794"></a><a class="code" href="namespacetesting.html#a0b81dd5584a3588cc2516b29ef166b7d">00794</a> <a class="code" href="namespacetesting.html#a8622c12aadfa0e60f7d68683eeb21115">UnorderedElementsAre</a>(<span class="keyword">const</span> T1&amp; e1) {
<a name="l00795"></a>00795   typedef ::testing::tuple&lt;
<a name="l00796"></a>00796       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00797"></a>00797   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1UnorderedElementsAreMatcher.html">internal::UnorderedElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1));
<a name="l00798"></a>00798 }
<a name="l00799"></a>00799 
<a name="l00800"></a>00800 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;
<a name="l00801"></a>00801 <span class="keyword">inline</span> internal::UnorderedElementsAreMatcher&lt;
<a name="l00802"></a>00802     ::testing::tuple&lt;
<a name="l00803"></a>00803         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00804"></a>00804         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type&gt; &gt;
<a name="l00805"></a><a class="code" href="namespacetesting.html#aedcecfa2107e03f5e2837f7124f73a87">00805</a> <a class="code" href="namespacetesting.html#a8622c12aadfa0e60f7d68683eeb21115">UnorderedElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2) {
<a name="l00806"></a>00806   typedef ::testing::tuple&lt;
<a name="l00807"></a>00807       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00808"></a>00808       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00809"></a>00809   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1UnorderedElementsAreMatcher.html">internal::UnorderedElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2));
<a name="l00810"></a>00810 }
<a name="l00811"></a>00811 
<a name="l00812"></a>00812 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;
<a name="l00813"></a>00813 <span class="keyword">inline</span> internal::UnorderedElementsAreMatcher&lt;
<a name="l00814"></a>00814     ::testing::tuple&lt;
<a name="l00815"></a>00815         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00816"></a>00816         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00817"></a>00817         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type&gt; &gt;
<a name="l00818"></a><a class="code" href="namespacetesting.html#aec0f9ede2dc05de791c61eae0504a757">00818</a> <a class="code" href="namespacetesting.html#a8622c12aadfa0e60f7d68683eeb21115">UnorderedElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3) {
<a name="l00819"></a>00819   typedef ::testing::tuple&lt;
<a name="l00820"></a>00820       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00821"></a>00821       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00822"></a>00822       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00823"></a>00823   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1UnorderedElementsAreMatcher.html">internal::UnorderedElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3));
<a name="l00824"></a>00824 }
<a name="l00825"></a>00825 
<a name="l00826"></a>00826 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4&gt;
<a name="l00827"></a>00827 <span class="keyword">inline</span> internal::UnorderedElementsAreMatcher&lt;
<a name="l00828"></a>00828     ::testing::tuple&lt;
<a name="l00829"></a>00829         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00830"></a>00830         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00831"></a>00831         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00832"></a>00832         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type&gt; &gt;
<a name="l00833"></a><a class="code" href="namespacetesting.html#a8dfb2b88d0cacb8ececc069b0b015991">00833</a> <a class="code" href="namespacetesting.html#a8622c12aadfa0e60f7d68683eeb21115">UnorderedElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4) {
<a name="l00834"></a>00834   typedef ::testing::tuple&lt;
<a name="l00835"></a>00835       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00836"></a>00836       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00837"></a>00837       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00838"></a>00838       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00839"></a>00839   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1UnorderedElementsAreMatcher.html">internal::UnorderedElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4));
<a name="l00840"></a>00840 }
<a name="l00841"></a>00841 
<a name="l00842"></a>00842 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5&gt;
<a name="l00843"></a>00843 <span class="keyword">inline</span> internal::UnorderedElementsAreMatcher&lt;
<a name="l00844"></a>00844     ::testing::tuple&lt;
<a name="l00845"></a>00845         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00846"></a>00846         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00847"></a>00847         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00848"></a>00848         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type,
<a name="l00849"></a>00849         <span class="keyword">typename</span> internal::DecayArray&lt;T5&gt;::type&gt; &gt;
<a name="l00850"></a><a class="code" href="namespacetesting.html#a5e0ff76eb3f61b6c79b60311ceca73d3">00850</a> <a class="code" href="namespacetesting.html#a8622c12aadfa0e60f7d68683eeb21115">UnorderedElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4,
<a name="l00851"></a>00851     <span class="keyword">const</span> T5&amp; e5) {
<a name="l00852"></a>00852   typedef ::testing::tuple&lt;
<a name="l00853"></a>00853       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00854"></a>00854       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00855"></a>00855       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00856"></a>00856       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>,
<a name="l00857"></a>00857       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T5&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00858"></a>00858   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1UnorderedElementsAreMatcher.html">internal::UnorderedElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4, e5));
<a name="l00859"></a>00859 }
<a name="l00860"></a>00860 
<a name="l00861"></a>00861 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5,
<a name="l00862"></a>00862     <span class="keyword">typename</span> T6&gt;
<a name="l00863"></a>00863 <span class="keyword">inline</span> internal::UnorderedElementsAreMatcher&lt;
<a name="l00864"></a>00864     ::testing::tuple&lt;
<a name="l00865"></a>00865         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00866"></a>00866         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00867"></a>00867         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00868"></a>00868         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type,
<a name="l00869"></a>00869         <span class="keyword">typename</span> internal::DecayArray&lt;T5&gt;::type,
<a name="l00870"></a>00870         <span class="keyword">typename</span> internal::DecayArray&lt;T6&gt;::type&gt; &gt;
<a name="l00871"></a><a class="code" href="namespacetesting.html#aff1859501ecd94dd1bc428d146a66fdc">00871</a> <a class="code" href="namespacetesting.html#a8622c12aadfa0e60f7d68683eeb21115">UnorderedElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4,
<a name="l00872"></a>00872     <span class="keyword">const</span> T5&amp; e5, <span class="keyword">const</span> T6&amp; e6) {
<a name="l00873"></a>00873   typedef ::testing::tuple&lt;
<a name="l00874"></a>00874       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00875"></a>00875       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00876"></a>00876       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00877"></a>00877       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>,
<a name="l00878"></a>00878       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T5&gt;::type</a>,
<a name="l00879"></a>00879       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T6&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00880"></a>00880   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1UnorderedElementsAreMatcher.html">internal::UnorderedElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4, e5,
<a name="l00881"></a>00881       e6));
<a name="l00882"></a>00882 }
<a name="l00883"></a>00883 
<a name="l00884"></a>00884 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5,
<a name="l00885"></a>00885     <span class="keyword">typename</span> T6, <span class="keyword">typename</span> T7&gt;
<a name="l00886"></a>00886 <span class="keyword">inline</span> internal::UnorderedElementsAreMatcher&lt;
<a name="l00887"></a>00887     ::testing::tuple&lt;
<a name="l00888"></a>00888         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00889"></a>00889         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00890"></a>00890         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00891"></a>00891         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type,
<a name="l00892"></a>00892         <span class="keyword">typename</span> internal::DecayArray&lt;T5&gt;::type,
<a name="l00893"></a>00893         <span class="keyword">typename</span> internal::DecayArray&lt;T6&gt;::type,
<a name="l00894"></a>00894         <span class="keyword">typename</span> internal::DecayArray&lt;T7&gt;::type&gt; &gt;
<a name="l00895"></a><a class="code" href="namespacetesting.html#add6e16fe24c45e39e92c0d19c04acf11">00895</a> <a class="code" href="namespacetesting.html#a8622c12aadfa0e60f7d68683eeb21115">UnorderedElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4,
<a name="l00896"></a>00896     <span class="keyword">const</span> T5&amp; e5, <span class="keyword">const</span> T6&amp; e6, <span class="keyword">const</span> T7&amp; e7) {
<a name="l00897"></a>00897   typedef ::testing::tuple&lt;
<a name="l00898"></a>00898       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00899"></a>00899       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00900"></a>00900       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00901"></a>00901       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>,
<a name="l00902"></a>00902       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T5&gt;::type</a>,
<a name="l00903"></a>00903       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T6&gt;::type</a>,
<a name="l00904"></a>00904       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T7&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00905"></a>00905   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1UnorderedElementsAreMatcher.html">internal::UnorderedElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4, e5,
<a name="l00906"></a>00906       e6, e7));
<a name="l00907"></a>00907 }
<a name="l00908"></a>00908 
<a name="l00909"></a>00909 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5,
<a name="l00910"></a>00910     <span class="keyword">typename</span> T6, <span class="keyword">typename</span> T7, <span class="keyword">typename</span> T8&gt;
<a name="l00911"></a>00911 <span class="keyword">inline</span> internal::UnorderedElementsAreMatcher&lt;
<a name="l00912"></a>00912     ::testing::tuple&lt;
<a name="l00913"></a>00913         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00914"></a>00914         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00915"></a>00915         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00916"></a>00916         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type,
<a name="l00917"></a>00917         <span class="keyword">typename</span> internal::DecayArray&lt;T5&gt;::type,
<a name="l00918"></a>00918         <span class="keyword">typename</span> internal::DecayArray&lt;T6&gt;::type,
<a name="l00919"></a>00919         <span class="keyword">typename</span> internal::DecayArray&lt;T7&gt;::type,
<a name="l00920"></a>00920         <span class="keyword">typename</span> internal::DecayArray&lt;T8&gt;::type&gt; &gt;
<a name="l00921"></a><a class="code" href="namespacetesting.html#a0f30358234947d21c7f39f15a8395d04">00921</a> <a class="code" href="namespacetesting.html#a8622c12aadfa0e60f7d68683eeb21115">UnorderedElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4,
<a name="l00922"></a>00922     <span class="keyword">const</span> T5&amp; e5, <span class="keyword">const</span> T6&amp; e6, <span class="keyword">const</span> T7&amp; e7, <span class="keyword">const</span> T8&amp; e8) {
<a name="l00923"></a>00923   typedef ::testing::tuple&lt;
<a name="l00924"></a>00924       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00925"></a>00925       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00926"></a>00926       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00927"></a>00927       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>,
<a name="l00928"></a>00928       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T5&gt;::type</a>,
<a name="l00929"></a>00929       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T6&gt;::type</a>,
<a name="l00930"></a>00930       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T7&gt;::type</a>,
<a name="l00931"></a>00931       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T8&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00932"></a>00932   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1UnorderedElementsAreMatcher.html">internal::UnorderedElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4, e5,
<a name="l00933"></a>00933       e6, e7, e8));
<a name="l00934"></a>00934 }
<a name="l00935"></a>00935 
<a name="l00936"></a>00936 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5,
<a name="l00937"></a>00937     <span class="keyword">typename</span> T6, <span class="keyword">typename</span> T7, <span class="keyword">typename</span> T8, <span class="keyword">typename</span> T9&gt;
<a name="l00938"></a>00938 <span class="keyword">inline</span> internal::UnorderedElementsAreMatcher&lt;
<a name="l00939"></a>00939     ::testing::tuple&lt;
<a name="l00940"></a>00940         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00941"></a>00941         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00942"></a>00942         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00943"></a>00943         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type,
<a name="l00944"></a>00944         <span class="keyword">typename</span> internal::DecayArray&lt;T5&gt;::type,
<a name="l00945"></a>00945         <span class="keyword">typename</span> internal::DecayArray&lt;T6&gt;::type,
<a name="l00946"></a>00946         <span class="keyword">typename</span> internal::DecayArray&lt;T7&gt;::type,
<a name="l00947"></a>00947         <span class="keyword">typename</span> internal::DecayArray&lt;T8&gt;::type,
<a name="l00948"></a>00948         <span class="keyword">typename</span> internal::DecayArray&lt;T9&gt;::type&gt; &gt;
<a name="l00949"></a><a class="code" href="namespacetesting.html#a2e03e363e193ef512bf9fa964c484375">00949</a> <a class="code" href="namespacetesting.html#a8622c12aadfa0e60f7d68683eeb21115">UnorderedElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4,
<a name="l00950"></a>00950     <span class="keyword">const</span> T5&amp; e5, <span class="keyword">const</span> T6&amp; e6, <span class="keyword">const</span> T7&amp; e7, <span class="keyword">const</span> T8&amp; e8, <span class="keyword">const</span> T9&amp; e9) {
<a name="l00951"></a>00951   typedef ::testing::tuple&lt;
<a name="l00952"></a>00952       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00953"></a>00953       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00954"></a>00954       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00955"></a>00955       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>,
<a name="l00956"></a>00956       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T5&gt;::type</a>,
<a name="l00957"></a>00957       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T6&gt;::type</a>,
<a name="l00958"></a>00958       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T7&gt;::type</a>,
<a name="l00959"></a>00959       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T8&gt;::type</a>,
<a name="l00960"></a>00960       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T9&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00961"></a>00961   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1UnorderedElementsAreMatcher.html">internal::UnorderedElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4, e5,
<a name="l00962"></a>00962       e6, e7, e8, e9));
<a name="l00963"></a>00963 }
<a name="l00964"></a>00964 
<a name="l00965"></a>00965 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3, <span class="keyword">typename</span> T4, <span class="keyword">typename</span> T5,
<a name="l00966"></a>00966     <span class="keyword">typename</span> T6, <span class="keyword">typename</span> T7, <span class="keyword">typename</span> T8, <span class="keyword">typename</span> T9, <span class="keyword">typename</span> T10&gt;
<a name="l00967"></a>00967 <span class="keyword">inline</span> internal::UnorderedElementsAreMatcher&lt;
<a name="l00968"></a>00968     ::testing::tuple&lt;
<a name="l00969"></a>00969         <span class="keyword">typename</span> internal::DecayArray&lt;T1&gt;::type,
<a name="l00970"></a>00970         <span class="keyword">typename</span> internal::DecayArray&lt;T2&gt;::type,
<a name="l00971"></a>00971         <span class="keyword">typename</span> internal::DecayArray&lt;T3&gt;::type,
<a name="l00972"></a>00972         <span class="keyword">typename</span> internal::DecayArray&lt;T4&gt;::type,
<a name="l00973"></a>00973         <span class="keyword">typename</span> internal::DecayArray&lt;T5&gt;::type,
<a name="l00974"></a>00974         <span class="keyword">typename</span> internal::DecayArray&lt;T6&gt;::type,
<a name="l00975"></a>00975         <span class="keyword">typename</span> internal::DecayArray&lt;T7&gt;::type,
<a name="l00976"></a>00976         <span class="keyword">typename</span> internal::DecayArray&lt;T8&gt;::type,
<a name="l00977"></a>00977         <span class="keyword">typename</span> internal::DecayArray&lt;T9&gt;::type,
<a name="l00978"></a>00978         <span class="keyword">typename</span> internal::DecayArray&lt;T10&gt;::type&gt; &gt;
<a name="l00979"></a><a class="code" href="namespacetesting.html#ae0e6c9754b17623a64358da8d38c4d13">00979</a> <a class="code" href="namespacetesting.html#a8622c12aadfa0e60f7d68683eeb21115">UnorderedElementsAre</a>(<span class="keyword">const</span> T1&amp; e1, <span class="keyword">const</span> T2&amp; e2, <span class="keyword">const</span> T3&amp; e3, <span class="keyword">const</span> T4&amp; e4,
<a name="l00980"></a>00980     <span class="keyword">const</span> T5&amp; e5, <span class="keyword">const</span> T6&amp; e6, <span class="keyword">const</span> T7&amp; e7, <span class="keyword">const</span> T8&amp; e8, <span class="keyword">const</span> T9&amp; e9,
<a name="l00981"></a>00981     <span class="keyword">const</span> T10&amp; e10) {
<a name="l00982"></a>00982   typedef ::testing::tuple&lt;
<a name="l00983"></a>00983       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T1&gt;::type</a>,
<a name="l00984"></a>00984       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T2&gt;::type</a>,
<a name="l00985"></a>00985       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T3&gt;::type</a>,
<a name="l00986"></a>00986       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T4&gt;::type</a>,
<a name="l00987"></a>00987       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T5&gt;::type</a>,
<a name="l00988"></a>00988       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T6&gt;::type</a>,
<a name="l00989"></a>00989       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T7&gt;::type</a>,
<a name="l00990"></a>00990       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T8&gt;::type</a>,
<a name="l00991"></a>00991       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T9&gt;::type</a>,
<a name="l00992"></a>00992       <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1DecayArray.html#a39803f9bafd56bc4531f86eb34fe9c0f">internal::DecayArray&lt;T10&gt;::type</a>&gt; <a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>;
<a name="l00993"></a>00993   <span class="keywordflow">return</span> <a class="code" href="classtesting_1_1internal_1_1UnorderedElementsAreMatcher.html">internal::UnorderedElementsAreMatcher&lt;Args&gt;</a>(<a class="code" href="namespacetesting.html#aaca153f67b689b8b9d5b8c67ecf8cee4">Args</a>(e1, e2, e3, e4, e5,
<a name="l00994"></a>00994       e6, e7, e8, e9, e10));
<a name="l00995"></a>00995 }
<a name="l00996"></a>00996 
<a name="l00997"></a>00997 <span class="comment">// AllOf(m1, m2, ..., mk) matches any value that matches all of the given</span>
<a name="l00998"></a>00998 <span class="comment">// sub-matchers.  AllOf is called fully qualified to prevent ADL from firing.</span>
<a name="l00999"></a>00999 
<a name="l01000"></a>01000 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2&gt;
<a name="l01001"></a>01001 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AllOfResult2&lt;M1, M2&gt;::type
<a name="l01002"></a><a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">01002</a> <a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">AllOf</a>(M1 m1, M2 m2) {
<a name="l01003"></a>01003   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AllOfResult2.html#adec0b0ce2fdd07d398e1fdd2cdb88392">internal::AllOfResult2&lt;M1, M2&gt;::type</a>(
<a name="l01004"></a>01004       m1,
<a name="l01005"></a>01005       m2);
<a name="l01006"></a>01006 }
<a name="l01007"></a>01007 
<a name="l01008"></a>01008 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3&gt;
<a name="l01009"></a>01009 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AllOfResult3&lt;M1, M2, M3&gt;::type
<a name="l01010"></a><a class="code" href="namespacetesting.html#a75934d8ea6b986d2157a5ebfe68f9904">01010</a> <a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">AllOf</a>(M1 m1, M2 m2, M3 m3) {
<a name="l01011"></a>01011   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AllOfResult3.html#a18073a23acd542bccf3a6c5d7f72f957">internal::AllOfResult3&lt;M1, M2, M3&gt;::type</a>(
<a name="l01012"></a>01012       m1,
<a name="l01013"></a>01013       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m2, m3));
<a name="l01014"></a>01014 }
<a name="l01015"></a>01015 
<a name="l01016"></a>01016 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4&gt;
<a name="l01017"></a>01017 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AllOfResult4&lt;M1, M2, M3, M4&gt;::type
<a name="l01018"></a><a class="code" href="namespacetesting.html#a4a9a119cde16e43b364f3573136857a1">01018</a> <a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">AllOf</a>(M1 m1, M2 m2, M3 m3, M4 m4) {
<a name="l01019"></a>01019   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AllOfResult4.html#ab277e20178bac632d4e5a39a1a407bbf">internal::AllOfResult4&lt;M1, M2, M3, M4&gt;::type</a>(
<a name="l01020"></a>01020       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m1, m2),
<a name="l01021"></a>01021       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m3, m4));
<a name="l01022"></a>01022 }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5&gt;
<a name="l01025"></a>01025 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AllOfResult5&lt;M1, M2, M3, M4, M5&gt;::type
<a name="l01026"></a><a class="code" href="namespacetesting.html#ab8f5e6cf1c22acf51a2b9b376b0ef03a">01026</a> <a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">AllOf</a>(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5) {
<a name="l01027"></a>01027   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AllOfResult5.html#aee2e1fb803f428741d147347b692d108">internal::AllOfResult5&lt;M1, M2, M3, M4, M5&gt;::type</a>(
<a name="l01028"></a>01028       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m1, m2),
<a name="l01029"></a>01029       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m3, m4, m5));
<a name="l01030"></a>01030 }
<a name="l01031"></a>01031 
<a name="l01032"></a>01032 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l01033"></a>01033     <span class="keyword">typename</span> M6&gt;
<a name="l01034"></a>01034 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AllOfResult6&lt;M1, M2, M3, M4, M5, M6&gt;::type
<a name="l01035"></a><a class="code" href="namespacetesting.html#afc8e2d405f80e7d3df32842ddb648125">01035</a> <a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">AllOf</a>(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6) {
<a name="l01036"></a>01036   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AllOfResult6.html#a5385655911ce2c1d3fccd802c1754139">internal::AllOfResult6&lt;M1, M2, M3, M4, M5, M6&gt;::type</a>(
<a name="l01037"></a>01037       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m1, m2, m3),
<a name="l01038"></a>01038       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m4, m5, m6));
<a name="l01039"></a>01039 }
<a name="l01040"></a>01040 
<a name="l01041"></a>01041 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l01042"></a>01042     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7&gt;
<a name="l01043"></a>01043 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AllOfResult7&lt;M1, M2, M3, M4, M5, M6, M7&gt;::type
<a name="l01044"></a><a class="code" href="namespacetesting.html#acbd4eef50126ff6db5b93ac5faa71b45">01044</a> <a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">AllOf</a>(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7) {
<a name="l01045"></a>01045   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AllOfResult7.html#a47ab0d670258434b0e65530591948e8c">internal::AllOfResult7&lt;M1, M2, M3, M4, M5, M6, M7&gt;::type</a>(
<a name="l01046"></a>01046       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m1, m2, m3),
<a name="l01047"></a>01047       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m4, m5, m6, m7));
<a name="l01048"></a>01048 }
<a name="l01049"></a>01049 
<a name="l01050"></a>01050 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l01051"></a>01051     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7, <span class="keyword">typename</span> M8&gt;
<a name="l01052"></a>01052 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AllOfResult8&lt;M1, M2, M3, M4, M5, M6, M7, M8&gt;::type
<a name="l01053"></a><a class="code" href="namespacetesting.html#a7ec0bc4eca9805e85b9b34bbbf3d3ae2">01053</a> <a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">AllOf</a>(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8) {
<a name="l01054"></a>01054   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AllOfResult8.html#a7103892a28c35221b9e62e871c577727">internal::AllOfResult8&lt;M1, M2, M3, M4, M5, M6, M7, M8&gt;::type</a>(
<a name="l01055"></a>01055       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m1, m2, m3, m4),
<a name="l01056"></a>01056       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m5, m6, m7, m8));
<a name="l01057"></a>01057 }
<a name="l01058"></a>01058 
<a name="l01059"></a>01059 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l01060"></a>01060     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7, <span class="keyword">typename</span> M8, <span class="keyword">typename</span> M9&gt;
<a name="l01061"></a>01061 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AllOfResult9&lt;M1, M2, M3, M4, M5, M6, M7, M8, M9&gt;::type
<a name="l01062"></a><a class="code" href="namespacetesting.html#aaecf2bd8eb7c68b119f9b81a01942b7f">01062</a> <a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">AllOf</a>(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9) {
<a name="l01063"></a>01063   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AllOfResult9.html">internal::AllOfResult9</a>&lt;M1, M2, M3, M4, M5, M6, M7, M8,
<a name="l01064"></a>01064       M9&gt;::type(
<a name="l01065"></a>01065       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m1, m2, m3, m4),
<a name="l01066"></a>01066       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m5, m6, m7, m8, m9));
<a name="l01067"></a>01067 }
<a name="l01068"></a>01068 
<a name="l01069"></a>01069 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l01070"></a>01070     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7, <span class="keyword">typename</span> M8, <span class="keyword">typename</span> M9, <span class="keyword">typename</span> M10&gt;
<a name="l01071"></a>01071 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AllOfResult10&lt;M1, M2, M3, M4, M5, M6, M7, M8, M9,
<a name="l01072"></a>01072     M10&gt;::type
<a name="l01073"></a><a class="code" href="namespacetesting.html#a9939c08664efeed0c1983090115f7ecb">01073</a> <a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">AllOf</a>(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {
<a name="l01074"></a>01074   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AllOfResult10.html">internal::AllOfResult10</a>&lt;M1, M2, M3, M4, M5, M6, M7, M8, M9,
<a name="l01075"></a>01075       M10&gt;::type(
<a name="l01076"></a>01076       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m1, m2, m3, m4, m5),
<a name="l01077"></a>01077       ::<a class="code" href="namespacetesting.html#af7618e8606c1cb45738163688944e2b7">testing::AllOf</a>(m6, m7, m8, m9, m10));
<a name="l01078"></a>01078 }
<a name="l01079"></a>01079 
<a name="l01080"></a>01080 <span class="comment">// AnyOf(m1, m2, ..., mk) matches any value that matches any of the given</span>
<a name="l01081"></a>01081 <span class="comment">// sub-matchers.  AnyOf is called fully qualified to prevent ADL from firing.</span>
<a name="l01082"></a>01082 
<a name="l01083"></a>01083 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2&gt;
<a name="l01084"></a>01084 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AnyOfResult2&lt;M1, M2&gt;::type
<a name="l01085"></a><a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">01085</a> <a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">AnyOf</a>(M1 m1, M2 m2) {
<a name="l01086"></a>01086   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AnyOfResult2.html#a6d9eba508021f8e652c7c154a649073f">internal::AnyOfResult2&lt;M1, M2&gt;::type</a>(
<a name="l01087"></a>01087       m1,
<a name="l01088"></a>01088       m2);
<a name="l01089"></a>01089 }
<a name="l01090"></a>01090 
<a name="l01091"></a>01091 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3&gt;
<a name="l01092"></a>01092 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AnyOfResult3&lt;M1, M2, M3&gt;::type
<a name="l01093"></a><a class="code" href="namespacetesting.html#a3ccbde3ba01189587676d44a4333c0a5">01093</a> <a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">AnyOf</a>(M1 m1, M2 m2, M3 m3) {
<a name="l01094"></a>01094   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AnyOfResult3.html#a232b20553cc0a33a6741e85e19ef4b0c">internal::AnyOfResult3&lt;M1, M2, M3&gt;::type</a>(
<a name="l01095"></a>01095       m1,
<a name="l01096"></a>01096       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m2, m3));
<a name="l01097"></a>01097 }
<a name="l01098"></a>01098 
<a name="l01099"></a>01099 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4&gt;
<a name="l01100"></a>01100 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AnyOfResult4&lt;M1, M2, M3, M4&gt;::type
<a name="l01101"></a><a class="code" href="namespacetesting.html#a1cfcacf2cf19543b86445e3585d5356f">01101</a> <a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">AnyOf</a>(M1 m1, M2 m2, M3 m3, M4 m4) {
<a name="l01102"></a>01102   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AnyOfResult4.html#a4f3c9aebb4f7fc24287b59a0bdf1a4a6">internal::AnyOfResult4&lt;M1, M2, M3, M4&gt;::type</a>(
<a name="l01103"></a>01103       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m1, m2),
<a name="l01104"></a>01104       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m3, m4));
<a name="l01105"></a>01105 }
<a name="l01106"></a>01106 
<a name="l01107"></a>01107 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5&gt;
<a name="l01108"></a>01108 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AnyOfResult5&lt;M1, M2, M3, M4, M5&gt;::type
<a name="l01109"></a><a class="code" href="namespacetesting.html#a049ea436e52c242adc44b2b42dc03e50">01109</a> <a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">AnyOf</a>(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5) {
<a name="l01110"></a>01110   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AnyOfResult5.html#a459a06dc5791313dce942668714f0c99">internal::AnyOfResult5&lt;M1, M2, M3, M4, M5&gt;::type</a>(
<a name="l01111"></a>01111       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m1, m2),
<a name="l01112"></a>01112       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m3, m4, m5));
<a name="l01113"></a>01113 }
<a name="l01114"></a>01114 
<a name="l01115"></a>01115 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l01116"></a>01116     <span class="keyword">typename</span> M6&gt;
<a name="l01117"></a>01117 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AnyOfResult6&lt;M1, M2, M3, M4, M5, M6&gt;::type
<a name="l01118"></a><a class="code" href="namespacetesting.html#a747189264a49a426004366371f1a2575">01118</a> <a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">AnyOf</a>(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6) {
<a name="l01119"></a>01119   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AnyOfResult6.html#a15837eb05d9ac5a76c20d344a4988dd1">internal::AnyOfResult6&lt;M1, M2, M3, M4, M5, M6&gt;::type</a>(
<a name="l01120"></a>01120       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m1, m2, m3),
<a name="l01121"></a>01121       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m4, m5, m6));
<a name="l01122"></a>01122 }
<a name="l01123"></a>01123 
<a name="l01124"></a>01124 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l01125"></a>01125     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7&gt;
<a name="l01126"></a>01126 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AnyOfResult7&lt;M1, M2, M3, M4, M5, M6, M7&gt;::type
<a name="l01127"></a><a class="code" href="namespacetesting.html#a754d1bddb237e79613f6834af3329efa">01127</a> <a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">AnyOf</a>(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7) {
<a name="l01128"></a>01128   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AnyOfResult7.html#a976873478921520833464a86f840abe8">internal::AnyOfResult7&lt;M1, M2, M3, M4, M5, M6, M7&gt;::type</a>(
<a name="l01129"></a>01129       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m1, m2, m3),
<a name="l01130"></a>01130       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m4, m5, m6, m7));
<a name="l01131"></a>01131 }
<a name="l01132"></a>01132 
<a name="l01133"></a>01133 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l01134"></a>01134     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7, <span class="keyword">typename</span> M8&gt;
<a name="l01135"></a>01135 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AnyOfResult8&lt;M1, M2, M3, M4, M5, M6, M7, M8&gt;::type
<a name="l01136"></a><a class="code" href="namespacetesting.html#a9c979c62cc004664b14e0ce444e531d5">01136</a> <a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">AnyOf</a>(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8) {
<a name="l01137"></a>01137   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AnyOfResult8.html#a8f8a1e78a019965c24bd22c78885747d">internal::AnyOfResult8&lt;M1, M2, M3, M4, M5, M6, M7, M8&gt;::type</a>(
<a name="l01138"></a>01138       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m1, m2, m3, m4),
<a name="l01139"></a>01139       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m5, m6, m7, m8));
<a name="l01140"></a>01140 }
<a name="l01141"></a>01141 
<a name="l01142"></a>01142 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l01143"></a>01143     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7, <span class="keyword">typename</span> M8, <span class="keyword">typename</span> M9&gt;
<a name="l01144"></a>01144 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AnyOfResult9&lt;M1, M2, M3, M4, M5, M6, M7, M8, M9&gt;::type
<a name="l01145"></a><a class="code" href="namespacetesting.html#a873c812db953aebd4bf2ffbff0e8d770">01145</a> <a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">AnyOf</a>(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9) {
<a name="l01146"></a>01146   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AnyOfResult9.html">internal::AnyOfResult9</a>&lt;M1, M2, M3, M4, M5, M6, M7, M8,
<a name="l01147"></a>01147       M9&gt;::type(
<a name="l01148"></a>01148       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m1, m2, m3, m4),
<a name="l01149"></a>01149       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m5, m6, m7, m8, m9));
<a name="l01150"></a>01150 }
<a name="l01151"></a>01151 
<a name="l01152"></a>01152 <span class="keyword">template</span> &lt;<span class="keyword">typename</span> M1, <span class="keyword">typename</span> M2, <span class="keyword">typename</span> M3, <span class="keyword">typename</span> M4, <span class="keyword">typename</span> M5,
<a name="l01153"></a>01153     <span class="keyword">typename</span> M6, <span class="keyword">typename</span> M7, <span class="keyword">typename</span> M8, <span class="keyword">typename</span> M9, <span class="keyword">typename</span> M10&gt;
<a name="l01154"></a>01154 <span class="keyword">inline</span> <span class="keyword">typename</span> internal::AnyOfResult10&lt;M1, M2, M3, M4, M5, M6, M7, M8, M9,
<a name="l01155"></a>01155     M10&gt;::type
<a name="l01156"></a><a class="code" href="namespacetesting.html#a1797921d3ed04c7f13dfa8f36bf0bf1c">01156</a> <a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">AnyOf</a>(M1 m1, M2 m2, M3 m3, M4 m4, M5 m5, M6 m6, M7 m7, M8 m8, M9 m9, M10 m10) {
<a name="l01157"></a>01157   <span class="keywordflow">return</span> <span class="keyword">typename</span> <a class="code" href="structtesting_1_1internal_1_1AnyOfResult10.html">internal::AnyOfResult10</a>&lt;M1, M2, M3, M4, M5, M6, M7, M8, M9,
<a name="l01158"></a>01158       M10&gt;::type(
<a name="l01159"></a>01159       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m1, m2, m3, m4, m5),
<a name="l01160"></a>01160       ::<a class="code" href="namespacetesting.html#a81cfefd9f75cdce827d5bc873cf73aac">testing::AnyOf</a>(m6, m7, m8, m9, m10));
<a name="l01161"></a>01161 }
<a name="l01162"></a>01162 
<a name="l01163"></a>01163 }  <span class="comment">// namespace testing</span>
<a name="l01164"></a>01164 
<a name="l01165"></a>01165 
<a name="l01166"></a>01166 <span class="comment">// The MATCHER* family of macros can be used in a namespace scope to</span>
<a name="l01167"></a>01167 <span class="comment">// define custom matchers easily.</span>
<a name="l01168"></a>01168 <span class="comment">//</span>
<a name="l01169"></a>01169 <span class="comment">// Basic Usage</span>
<a name="l01170"></a>01170 <span class="comment">// ===========</span>
<a name="l01171"></a>01171 <span class="comment">//</span>
<a name="l01172"></a>01172 <span class="comment">// The syntax</span>
<a name="l01173"></a>01173 <span class="comment">//</span>
<a name="l01174"></a>01174 <span class="comment">//   MATCHER(name, description_string) { statements; }</span>
<a name="l01175"></a>01175 <span class="comment">//</span>
<a name="l01176"></a>01176 <span class="comment">// defines a matcher with the given name that executes the statements,</span>
<a name="l01177"></a>01177 <span class="comment">// which must return a bool to indicate if the match succeeds.  Inside</span>
<a name="l01178"></a>01178 <span class="comment">// the statements, you can refer to the value being matched by &#39;arg&#39;,</span>
<a name="l01179"></a>01179 <span class="comment">// and refer to its type by &#39;arg_type&#39;.</span>
<a name="l01180"></a>01180 <span class="comment">//</span>
<a name="l01181"></a>01181 <span class="comment">// The description string documents what the matcher does, and is used</span>
<a name="l01182"></a>01182 <span class="comment">// to generate the failure message when the match fails.  Since a</span>
<a name="l01183"></a>01183 <span class="comment">// MATCHER() is usually defined in a header file shared by multiple</span>
<a name="l01184"></a>01184 <span class="comment">// C++ source files, we require the description to be a C-string</span>
<a name="l01185"></a>01185 <span class="comment">// literal to avoid possible side effects.  It can be empty, in which</span>
<a name="l01186"></a>01186 <span class="comment">// case we&#39;ll use the sequence of words in the matcher name as the</span>
<a name="l01187"></a>01187 <span class="comment">// description.</span>
<a name="l01188"></a>01188 <span class="comment">//</span>
<a name="l01189"></a>01189 <span class="comment">// For example:</span>
<a name="l01190"></a>01190 <span class="comment">//</span>
<a name="l01191"></a>01191 <span class="comment">//   MATCHER(IsEven, &quot;&quot;) { return (arg % 2) == 0; }</span>
<a name="l01192"></a>01192 <span class="comment">//</span>
<a name="l01193"></a>01193 <span class="comment">// allows you to write</span>
<a name="l01194"></a>01194 <span class="comment">//</span>
<a name="l01195"></a>01195 <span class="comment">//   // Expects mock_foo.Bar(n) to be called where n is even.</span>
<a name="l01196"></a>01196 <span class="comment">//   EXPECT_CALL(mock_foo, Bar(IsEven()));</span>
<a name="l01197"></a>01197 <span class="comment">//</span>
<a name="l01198"></a>01198 <span class="comment">// or,</span>
<a name="l01199"></a>01199 <span class="comment">//</span>
<a name="l01200"></a>01200 <span class="comment">//   // Verifies that the value of some_expression is even.</span>
<a name="l01201"></a>01201 <span class="comment">//   EXPECT_THAT(some_expression, IsEven());</span>
<a name="l01202"></a>01202 <span class="comment">//</span>
<a name="l01203"></a>01203 <span class="comment">// If the above assertion fails, it will print something like:</span>
<a name="l01204"></a>01204 <span class="comment">//</span>
<a name="l01205"></a>01205 <span class="comment">//   Value of: some_expression</span>
<a name="l01206"></a>01206 <span class="comment">//   Expected: is even</span>
<a name="l01207"></a>01207 <span class="comment">//     Actual: 7</span>
<a name="l01208"></a>01208 <span class="comment">//</span>
<a name="l01209"></a>01209 <span class="comment">// where the description &quot;is even&quot; is automatically calculated from the</span>
<a name="l01210"></a>01210 <span class="comment">// matcher name IsEven.</span>
<a name="l01211"></a>01211 <span class="comment">//</span>
<a name="l01212"></a>01212 <span class="comment">// Argument Type</span>
<a name="l01213"></a>01213 <span class="comment">// =============</span>
<a name="l01214"></a>01214 <span class="comment">//</span>
<a name="l01215"></a>01215 <span class="comment">// Note that the type of the value being matched (arg_type) is</span>
<a name="l01216"></a>01216 <span class="comment">// determined by the context in which you use the matcher and is</span>
<a name="l01217"></a>01217 <span class="comment">// supplied to you by the compiler, so you don&#39;t need to worry about</span>
<a name="l01218"></a>01218 <span class="comment">// declaring it (nor can you).  This allows the matcher to be</span>
<a name="l01219"></a>01219 <span class="comment">// polymorphic.  For example, IsEven() can be used to match any type</span>
<a name="l01220"></a>01220 <span class="comment">// where the value of &quot;(arg % 2) == 0&quot; can be implicitly converted to</span>
<a name="l01221"></a>01221 <span class="comment">// a bool.  In the &quot;Bar(IsEven())&quot; example above, if method Bar()</span>
<a name="l01222"></a>01222 <span class="comment">// takes an int, &#39;arg_type&#39; will be int; if it takes an unsigned long,</span>
<a name="l01223"></a>01223 <span class="comment">// &#39;arg_type&#39; will be unsigned long; and so on.</span>
<a name="l01224"></a>01224 <span class="comment">//</span>
<a name="l01225"></a>01225 <span class="comment">// Parameterizing Matchers</span>
<a name="l01226"></a>01226 <span class="comment">// =======================</span>
<a name="l01227"></a>01227 <span class="comment">//</span>
<a name="l01228"></a>01228 <span class="comment">// Sometimes you&#39;ll want to parameterize the matcher.  For that you</span>
<a name="l01229"></a>01229 <span class="comment">// can use another macro:</span>
<a name="l01230"></a>01230 <span class="comment">//</span>
<a name="l01231"></a>01231 <span class="comment">//   MATCHER_P(name, param_name, description_string) { statements; }</span>
<a name="l01232"></a>01232 <span class="comment">//</span>
<a name="l01233"></a>01233 <span class="comment">// For example:</span>
<a name="l01234"></a>01234 <span class="comment">//</span>
<a name="l01235"></a>01235 <span class="comment">//   MATCHER_P(HasAbsoluteValue, value, &quot;&quot;) { return abs(arg) == value; }</span>
<a name="l01236"></a>01236 <span class="comment">//</span>
<a name="l01237"></a>01237 <span class="comment">// will allow you to write:</span>
<a name="l01238"></a>01238 <span class="comment">//</span>
<a name="l01239"></a>01239 <span class="comment">//   EXPECT_THAT(Blah(&quot;a&quot;), HasAbsoluteValue(n));</span>
<a name="l01240"></a>01240 <span class="comment">//</span>
<a name="l01241"></a>01241 <span class="comment">// which may lead to this message (assuming n is 10):</span>
<a name="l01242"></a>01242 <span class="comment">//</span>
<a name="l01243"></a>01243 <span class="comment">//   Value of: Blah(&quot;a&quot;)</span>
<a name="l01244"></a>01244 <span class="comment">//   Expected: has absolute value 10</span>
<a name="l01245"></a>01245 <span class="comment">//     Actual: -9</span>
<a name="l01246"></a>01246 <span class="comment">//</span>
<a name="l01247"></a>01247 <span class="comment">// Note that both the matcher description and its parameter are</span>
<a name="l01248"></a>01248 <span class="comment">// printed, making the message human-friendly.</span>
<a name="l01249"></a>01249 <span class="comment">//</span>
<a name="l01250"></a>01250 <span class="comment">// In the matcher definition body, you can write &#39;foo_type&#39; to</span>
<a name="l01251"></a>01251 <span class="comment">// reference the type of a parameter named &#39;foo&#39;.  For example, in the</span>
<a name="l01252"></a>01252 <span class="comment">// body of MATCHER_P(HasAbsoluteValue, value) above, you can write</span>
<a name="l01253"></a>01253 <span class="comment">// &#39;value_type&#39; to refer to the type of &#39;value&#39;.</span>
<a name="l01254"></a>01254 <span class="comment">//</span>
<a name="l01255"></a>01255 <span class="comment">// We also provide MATCHER_P2, MATCHER_P3, ..., up to MATCHER_P10 to</span>
<a name="l01256"></a>01256 <span class="comment">// support multi-parameter matchers.</span>
<a name="l01257"></a>01257 <span class="comment">//</span>
<a name="l01258"></a>01258 <span class="comment">// Describing Parameterized Matchers</span>
<a name="l01259"></a>01259 <span class="comment">// =================================</span>
<a name="l01260"></a>01260 <span class="comment">//</span>
<a name="l01261"></a>01261 <span class="comment">// The last argument to MATCHER*() is a string-typed expression.  The</span>
<a name="l01262"></a>01262 <span class="comment">// expression can reference all of the matcher&#39;s parameters and a</span>
<a name="l01263"></a>01263 <span class="comment">// special bool-typed variable named &#39;negation&#39;.  When &#39;negation&#39; is</span>
<a name="l01264"></a>01264 <span class="comment">// false, the expression should evaluate to the matcher&#39;s description;</span>
<a name="l01265"></a>01265 <span class="comment">// otherwise it should evaluate to the description of the negation of</span>
<a name="l01266"></a>01266 <span class="comment">// the matcher.  For example,</span>
<a name="l01267"></a>01267 <span class="comment">//</span>
<a name="l01268"></a>01268 <span class="comment">//   using testing::PrintToString;</span>
<a name="l01269"></a>01269 <span class="comment">//</span>
<a name="l01270"></a>01270 <span class="comment">//   MATCHER_P2(InClosedRange, low, hi,</span>
<a name="l01271"></a>01271 <span class="comment">//       string(negation ? &quot;is not&quot; : &quot;is&quot;) + &quot; in range [&quot; +</span>
<a name="l01272"></a>01272 <span class="comment">//       PrintToString(low) + &quot;, &quot; + PrintToString(hi) + &quot;]&quot;) {</span>
<a name="l01273"></a>01273 <span class="comment">//     return low &lt;= arg &amp;&amp; arg &lt;= hi;</span>
<a name="l01274"></a>01274 <span class="comment">//   }</span>
<a name="l01275"></a>01275 <span class="comment">//   ...</span>
<a name="l01276"></a>01276 <span class="comment">//   EXPECT_THAT(3, InClosedRange(4, 6));</span>
<a name="l01277"></a>01277 <span class="comment">//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));</span>
<a name="l01278"></a>01278 <span class="comment">//</span>
<a name="l01279"></a>01279 <span class="comment">// would generate two failures that contain the text:</span>
<a name="l01280"></a>01280 <span class="comment">//</span>
<a name="l01281"></a>01281 <span class="comment">//   Expected: is in range [4, 6]</span>
<a name="l01282"></a>01282 <span class="comment">//   ...</span>
<a name="l01283"></a>01283 <span class="comment">//   Expected: is not in range [2, 4]</span>
<a name="l01284"></a>01284 <span class="comment">//</span>
<a name="l01285"></a>01285 <span class="comment">// If you specify &quot;&quot; as the description, the failure message will</span>
<a name="l01286"></a>01286 <span class="comment">// contain the sequence of words in the matcher name followed by the</span>
<a name="l01287"></a>01287 <span class="comment">// parameter values printed as a tuple.  For example,</span>
<a name="l01288"></a>01288 <span class="comment">//</span>
<a name="l01289"></a>01289 <span class="comment">//   MATCHER_P2(InClosedRange, low, hi, &quot;&quot;) { ... }</span>
<a name="l01290"></a>01290 <span class="comment">//   ...</span>
<a name="l01291"></a>01291 <span class="comment">//   EXPECT_THAT(3, InClosedRange(4, 6));</span>
<a name="l01292"></a>01292 <span class="comment">//   EXPECT_THAT(3, Not(InClosedRange(2, 4)));</span>
<a name="l01293"></a>01293 <span class="comment">//</span>
<a name="l01294"></a>01294 <span class="comment">// would generate two failures that contain the text:</span>
<a name="l01295"></a>01295 <span class="comment">//</span>
<a name="l01296"></a>01296 <span class="comment">//   Expected: in closed range (4, 6)</span>
<a name="l01297"></a>01297 <span class="comment">//   ...</span>
<a name="l01298"></a>01298 <span class="comment">//   Expected: not (in closed range (2, 4))</span>
<a name="l01299"></a>01299 <span class="comment">//</span>
<a name="l01300"></a>01300 <span class="comment">// Types of Matcher Parameters</span>
<a name="l01301"></a>01301 <span class="comment">// ===========================</span>
<a name="l01302"></a>01302 <span class="comment">//</span>
<a name="l01303"></a>01303 <span class="comment">// For the purpose of typing, you can view</span>
<a name="l01304"></a>01304 <span class="comment">//</span>
<a name="l01305"></a>01305 <span class="comment">//   MATCHER_Pk(Foo, p1, ..., pk, description_string) { ... }</span>
<a name="l01306"></a>01306 <span class="comment">//</span>
<a name="l01307"></a>01307 <span class="comment">// as shorthand for</span>
<a name="l01308"></a>01308 <span class="comment">//</span>
<a name="l01309"></a>01309 <span class="comment">//   template &lt;typename p1_type, ..., typename pk_type&gt;</span>
<a name="l01310"></a>01310 <span class="comment">//   FooMatcherPk&lt;p1_type, ..., pk_type&gt;</span>
<a name="l01311"></a>01311 <span class="comment">//   Foo(p1_type p1, ..., pk_type pk) { ... }</span>
<a name="l01312"></a>01312 <span class="comment">//</span>
<a name="l01313"></a>01313 <span class="comment">// When you write Foo(v1, ..., vk), the compiler infers the types of</span>
<a name="l01314"></a>01314 <span class="comment">// the parameters v1, ..., and vk for you.  If you are not happy with</span>
<a name="l01315"></a>01315 <span class="comment">// the result of the type inference, you can specify the types by</span>
<a name="l01316"></a>01316 <span class="comment">// explicitly instantiating the template, as in Foo&lt;long, bool&gt;(5,</span>
<a name="l01317"></a>01317 <span class="comment">// false).  As said earlier, you don&#39;t get to (or need to) specify</span>
<a name="l01318"></a>01318 <span class="comment">// &#39;arg_type&#39; as that&#39;s determined by the context in which the matcher</span>
<a name="l01319"></a>01319 <span class="comment">// is used.  You can assign the result of expression Foo(p1, ..., pk)</span>
<a name="l01320"></a>01320 <span class="comment">// to a variable of type FooMatcherPk&lt;p1_type, ..., pk_type&gt;.  This</span>
<a name="l01321"></a>01321 <span class="comment">// can be useful when composing matchers.</span>
<a name="l01322"></a>01322 <span class="comment">//</span>
<a name="l01323"></a>01323 <span class="comment">// While you can instantiate a matcher template with reference types,</span>
<a name="l01324"></a>01324 <span class="comment">// passing the parameters by pointer usually makes your code more</span>
<a name="l01325"></a>01325 <span class="comment">// readable.  If, however, you still want to pass a parameter by</span>
<a name="l01326"></a>01326 <span class="comment">// reference, be aware that in the failure message generated by the</span>
<a name="l01327"></a>01327 <span class="comment">// matcher you will see the value of the referenced object but not its</span>
<a name="l01328"></a>01328 <span class="comment">// address.</span>
<a name="l01329"></a>01329 <span class="comment">//</span>
<a name="l01330"></a>01330 <span class="comment">// Explaining Match Results</span>
<a name="l01331"></a>01331 <span class="comment">// ========================</span>
<a name="l01332"></a>01332 <span class="comment">//</span>
<a name="l01333"></a>01333 <span class="comment">// Sometimes the matcher description alone isn&#39;t enough to explain why</span>
<a name="l01334"></a>01334 <span class="comment">// the match has failed or succeeded.  For example, when expecting a</span>
<a name="l01335"></a>01335 <span class="comment">// long string, it can be very helpful to also print the diff between</span>
<a name="l01336"></a>01336 <span class="comment">// the expected string and the actual one.  To achieve that, you can</span>
<a name="l01337"></a>01337 <span class="comment">// optionally stream additional information to a special variable</span>
<a name="l01338"></a>01338 <span class="comment">// named result_listener, whose type is a pointer to class</span>
<a name="l01339"></a>01339 <span class="comment">// MatchResultListener:</span>
<a name="l01340"></a>01340 <span class="comment">//</span>
<a name="l01341"></a>01341 <span class="comment">//   MATCHER_P(EqualsLongString, str, &quot;&quot;) {</span>
<a name="l01342"></a>01342 <span class="comment">//     if (arg == str) return true;</span>
<a name="l01343"></a>01343 <span class="comment">//</span>
<a name="l01344"></a>01344 <span class="comment">//     *result_listener &lt;&lt; &quot;the difference: &quot;</span>
<a name="l01346"></a>01346 <span class="comment"></span><span class="comment">//     return false;</span>
<a name="l01347"></a>01347 <span class="comment">//   }</span>
<a name="l01348"></a>01348 <span class="comment">//</span>
<a name="l01349"></a>01349 <span class="comment">// Overloading Matchers</span>
<a name="l01350"></a>01350 <span class="comment">// ====================</span>
<a name="l01351"></a>01351 <span class="comment">//</span>
<a name="l01352"></a>01352 <span class="comment">// You can overload matchers with different numbers of parameters:</span>
<a name="l01353"></a>01353 <span class="comment">//</span>
<a name="l01354"></a>01354 <span class="comment">//   MATCHER_P(Blah, a, description_string1) { ... }</span>
<a name="l01355"></a>01355 <span class="comment">//   MATCHER_P2(Blah, a, b, description_string2) { ... }</span>
<a name="l01356"></a>01356 <span class="comment">//</span>
<a name="l01357"></a>01357 <span class="comment">// Caveats</span>
<a name="l01358"></a>01358 <span class="comment">// =======</span>
<a name="l01359"></a>01359 <span class="comment">//</span>
<a name="l01360"></a>01360 <span class="comment">// When defining a new matcher, you should also consider implementing</span>
<a name="l01361"></a>01361 <span class="comment">// MatcherInterface or using MakePolymorphicMatcher().  These</span>
<a name="l01362"></a>01362 <span class="comment">// approaches require more work than the MATCHER* macros, but also</span>
<a name="l01363"></a>01363 <span class="comment">// give you more control on the types of the value being matched and</span>
<a name="l01364"></a>01364 <span class="comment">// the matcher parameters, which may leads to better compiler error</span>
<a name="l01365"></a>01365 <span class="comment">// messages when the matcher is used wrong.  They also allow</span>
<a name="l01366"></a>01366 <span class="comment">// overloading matchers based on parameter types (as opposed to just</span>
<a name="l01367"></a>01367 <span class="comment">// based on the number of parameters).</span>
<a name="l01368"></a>01368 <span class="comment">//</span>
<a name="l01369"></a>01369 <span class="comment">// MATCHER*() can only be used in a namespace scope.  The reason is</span>
<a name="l01370"></a>01370 <span class="comment">// that C++ doesn&#39;t yet allow function-local types to be used to</span>
<a name="l01371"></a>01371 <span class="comment">// instantiate templates.  The up-coming C++0x standard will fix this.</span>
<a name="l01372"></a>01372 <span class="comment">// Once that&#39;s done, we&#39;ll consider supporting using MATCHER*() inside</span>
<a name="l01373"></a>01373 <span class="comment">// a function.</span>
<a name="l01374"></a>01374 <span class="comment">//</span>
<a name="l01375"></a>01375 <span class="comment">// More Information</span>
<a name="l01376"></a>01376 <span class="comment">// ================</span>
<a name="l01377"></a>01377 <span class="comment">//</span>
<a name="l01378"></a>01378 <span class="comment">// To learn more about using these macros, please search for &#39;MATCHER&#39;</span>
<a name="l01379"></a>01379 <span class="comment">// on http://code.google.com/p/googlemock/wiki/CookBook.</span>
<a name="l01380"></a>01380 
<a name="l01381"></a><a class="code" href="gmock-generated-matchers_8h.html#af4fe73ff8e2b0494f4970b575b65ddff">01381</a> <span class="preprocessor">#define MATCHER(name, description)\</span>
<a name="l01382"></a>01382 <span class="preprocessor">  class name##Matcher {\</span>
<a name="l01383"></a>01383 <span class="preprocessor">   public:\</span>
<a name="l01384"></a>01384 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01385"></a>01385 <span class="preprocessor">    class gmock_Impl : public ::testing::MatcherInterface&lt;arg_type&gt; {\</span>
<a name="l01386"></a>01386 <span class="preprocessor">     public:\</span>
<a name="l01387"></a>01387 <span class="preprocessor">      gmock_Impl()\</span>
<a name="l01388"></a>01388 <span class="preprocessor">           {}\</span>
<a name="l01389"></a>01389 <span class="preprocessor">      virtual bool MatchAndExplain(\</span>
<a name="l01390"></a>01390 <span class="preprocessor">          arg_type arg, ::testing::MatchResultListener* result_listener) const;\</span>
<a name="l01391"></a>01391 <span class="preprocessor">      virtual void DescribeTo(::std::ostream* gmock_os) const {\</span>
<a name="l01392"></a>01392 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(false);\</span>
<a name="l01393"></a>01393 <span class="preprocessor">      }\</span>
<a name="l01394"></a>01394 <span class="preprocessor">      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\</span>
<a name="l01395"></a>01395 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(true);\</span>
<a name="l01396"></a>01396 <span class="preprocessor">      }\</span>
<a name="l01397"></a>01397 <span class="preprocessor">     private:\</span>
<a name="l01398"></a>01398 <span class="preprocessor">      ::testing::internal::string FormatDescription(bool negation) const {\</span>
<a name="l01399"></a>01399 <span class="preprocessor">        const ::testing::internal::string gmock_description = (description);\</span>
<a name="l01400"></a>01400 <span class="preprocessor">        if (!gmock_description.empty())\</span>
<a name="l01401"></a>01401 <span class="preprocessor">          return gmock_description;\</span>
<a name="l01402"></a>01402 <span class="preprocessor">        return ::testing::internal::FormatMatcherDescription(\</span>
<a name="l01403"></a>01403 <span class="preprocessor">            negation, #name, \</span>
<a name="l01404"></a>01404 <span class="preprocessor">            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\</span>
<a name="l01405"></a>01405 <span class="preprocessor">                ::testing::tuple&lt;&gt;()));\</span>
<a name="l01406"></a>01406 <span class="preprocessor">      }\</span>
<a name="l01407"></a>01407 <span class="preprocessor">      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\</span>
<a name="l01408"></a>01408 <span class="preprocessor">    };\</span>
<a name="l01409"></a>01409 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01410"></a>01410 <span class="preprocessor">    operator ::testing::Matcher&lt;arg_type&gt;() const {\</span>
<a name="l01411"></a>01411 <span class="preprocessor">      return ::testing::Matcher&lt;arg_type&gt;(\</span>
<a name="l01412"></a>01412 <span class="preprocessor">          new gmock_Impl&lt;arg_type&gt;());\</span>
<a name="l01413"></a>01413 <span class="preprocessor">    }\</span>
<a name="l01414"></a>01414 <span class="preprocessor">    name##Matcher() {\</span>
<a name="l01415"></a>01415 <span class="preprocessor">    }\</span>
<a name="l01416"></a>01416 <span class="preprocessor">   private:\</span>
<a name="l01417"></a>01417 <span class="preprocessor">    GTEST_DISALLOW_ASSIGN_(name##Matcher);\</span>
<a name="l01418"></a>01418 <span class="preprocessor">  };\</span>
<a name="l01419"></a>01419 <span class="preprocessor">  inline name##Matcher name() {\</span>
<a name="l01420"></a>01420 <span class="preprocessor">    return name##Matcher();\</span>
<a name="l01421"></a>01421 <span class="preprocessor">  }\</span>
<a name="l01422"></a>01422 <span class="preprocessor">  template &lt;typename arg_type&gt;\</span>
<a name="l01423"></a>01423 <span class="preprocessor">  bool name##Matcher::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\</span>
<a name="l01424"></a>01424 <span class="preprocessor">      arg_type arg, \</span>
<a name="l01425"></a>01425 <span class="preprocessor">      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\</span>
<a name="l01426"></a>01426 <span class="preprocessor">          const</span>
<a name="l01427"></a>01427 <span class="preprocessor"></span>
<a name="l01428"></a><a class="code" href="gmock-generated-matchers_8h.html#acb7ae915efa2fd8d3f6ea7313198afb6">01428</a> <span class="preprocessor">#define MATCHER_P(name, p0, description)\</span>
<a name="l01429"></a>01429 <span class="preprocessor">  template &lt;typename p0##_type&gt;\</span>
<a name="l01430"></a>01430 <span class="preprocessor">  class name##MatcherP {\</span>
<a name="l01431"></a>01431 <span class="preprocessor">   public:\</span>
<a name="l01432"></a>01432 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01433"></a>01433 <span class="preprocessor">    class gmock_Impl : public ::testing::MatcherInterface&lt;arg_type&gt; {\</span>
<a name="l01434"></a>01434 <span class="preprocessor">     public:\</span>
<a name="l01435"></a>01435 <span class="preprocessor">      explicit gmock_Impl(p0##_type gmock_p0)\</span>
<a name="l01436"></a>01436 <span class="preprocessor">           : p0(gmock_p0) {}\</span>
<a name="l01437"></a>01437 <span class="preprocessor">      virtual bool MatchAndExplain(\</span>
<a name="l01438"></a>01438 <span class="preprocessor">          arg_type arg, ::testing::MatchResultListener* result_listener) const;\</span>
<a name="l01439"></a>01439 <span class="preprocessor">      virtual void DescribeTo(::std::ostream* gmock_os) const {\</span>
<a name="l01440"></a>01440 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(false);\</span>
<a name="l01441"></a>01441 <span class="preprocessor">      }\</span>
<a name="l01442"></a>01442 <span class="preprocessor">      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\</span>
<a name="l01443"></a>01443 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(true);\</span>
<a name="l01444"></a>01444 <span class="preprocessor">      }\</span>
<a name="l01445"></a>01445 <span class="preprocessor">      p0##_type p0;\</span>
<a name="l01446"></a>01446 <span class="preprocessor">     private:\</span>
<a name="l01447"></a>01447 <span class="preprocessor">      ::testing::internal::string FormatDescription(bool negation) const {\</span>
<a name="l01448"></a>01448 <span class="preprocessor">        const ::testing::internal::string gmock_description = (description);\</span>
<a name="l01449"></a>01449 <span class="preprocessor">        if (!gmock_description.empty())\</span>
<a name="l01450"></a>01450 <span class="preprocessor">          return gmock_description;\</span>
<a name="l01451"></a>01451 <span class="preprocessor">        return ::testing::internal::FormatMatcherDescription(\</span>
<a name="l01452"></a>01452 <span class="preprocessor">            negation, #name, \</span>
<a name="l01453"></a>01453 <span class="preprocessor">            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\</span>
<a name="l01454"></a>01454 <span class="preprocessor">                ::testing::tuple&lt;p0##_type&gt;(p0)));\</span>
<a name="l01455"></a>01455 <span class="preprocessor">      }\</span>
<a name="l01456"></a>01456 <span class="preprocessor">      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\</span>
<a name="l01457"></a>01457 <span class="preprocessor">    };\</span>
<a name="l01458"></a>01458 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01459"></a>01459 <span class="preprocessor">    operator ::testing::Matcher&lt;arg_type&gt;() const {\</span>
<a name="l01460"></a>01460 <span class="preprocessor">      return ::testing::Matcher&lt;arg_type&gt;(\</span>
<a name="l01461"></a>01461 <span class="preprocessor">          new gmock_Impl&lt;arg_type&gt;(p0));\</span>
<a name="l01462"></a>01462 <span class="preprocessor">    }\</span>
<a name="l01463"></a>01463 <span class="preprocessor">    explicit name##MatcherP(p0##_type gmock_p0) : p0(gmock_p0) {\</span>
<a name="l01464"></a>01464 <span class="preprocessor">    }\</span>
<a name="l01465"></a>01465 <span class="preprocessor">    p0##_type p0;\</span>
<a name="l01466"></a>01466 <span class="preprocessor">   private:\</span>
<a name="l01467"></a>01467 <span class="preprocessor">    GTEST_DISALLOW_ASSIGN_(name##MatcherP);\</span>
<a name="l01468"></a>01468 <span class="preprocessor">  };\</span>
<a name="l01469"></a>01469 <span class="preprocessor">  template &lt;typename p0##_type&gt;\</span>
<a name="l01470"></a>01470 <span class="preprocessor">  inline name##MatcherP&lt;p0##_type&gt; name(p0##_type p0) {\</span>
<a name="l01471"></a>01471 <span class="preprocessor">    return name##MatcherP&lt;p0##_type&gt;(p0);\</span>
<a name="l01472"></a>01472 <span class="preprocessor">  }\</span>
<a name="l01473"></a>01473 <span class="preprocessor">  template &lt;typename p0##_type&gt;\</span>
<a name="l01474"></a>01474 <span class="preprocessor">  template &lt;typename arg_type&gt;\</span>
<a name="l01475"></a>01475 <span class="preprocessor">  bool name##MatcherP&lt;p0##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\</span>
<a name="l01476"></a>01476 <span class="preprocessor">      arg_type arg, \</span>
<a name="l01477"></a>01477 <span class="preprocessor">      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\</span>
<a name="l01478"></a>01478 <span class="preprocessor">          const</span>
<a name="l01479"></a>01479 <span class="preprocessor"></span>
<a name="l01480"></a><a class="code" href="gmock-generated-matchers_8h.html#a78efce3ad21c8f68223f5c2d09f2e79d">01480</a> <span class="preprocessor">#define MATCHER_P2(name, p0, p1, description)\</span>
<a name="l01481"></a>01481 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type&gt;\</span>
<a name="l01482"></a>01482 <span class="preprocessor">  class name##MatcherP2 {\</span>
<a name="l01483"></a>01483 <span class="preprocessor">   public:\</span>
<a name="l01484"></a>01484 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01485"></a>01485 <span class="preprocessor">    class gmock_Impl : public ::testing::MatcherInterface&lt;arg_type&gt; {\</span>
<a name="l01486"></a>01486 <span class="preprocessor">     public:\</span>
<a name="l01487"></a>01487 <span class="preprocessor">      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1)\</span>
<a name="l01488"></a>01488 <span class="preprocessor">           : p0(gmock_p0), p1(gmock_p1) {}\</span>
<a name="l01489"></a>01489 <span class="preprocessor">      virtual bool MatchAndExplain(\</span>
<a name="l01490"></a>01490 <span class="preprocessor">          arg_type arg, ::testing::MatchResultListener* result_listener) const;\</span>
<a name="l01491"></a>01491 <span class="preprocessor">      virtual void DescribeTo(::std::ostream* gmock_os) const {\</span>
<a name="l01492"></a>01492 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(false);\</span>
<a name="l01493"></a>01493 <span class="preprocessor">      }\</span>
<a name="l01494"></a>01494 <span class="preprocessor">      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\</span>
<a name="l01495"></a>01495 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(true);\</span>
<a name="l01496"></a>01496 <span class="preprocessor">      }\</span>
<a name="l01497"></a>01497 <span class="preprocessor">      p0##_type p0;\</span>
<a name="l01498"></a>01498 <span class="preprocessor">      p1##_type p1;\</span>
<a name="l01499"></a>01499 <span class="preprocessor">     private:\</span>
<a name="l01500"></a>01500 <span class="preprocessor">      ::testing::internal::string FormatDescription(bool negation) const {\</span>
<a name="l01501"></a>01501 <span class="preprocessor">        const ::testing::internal::string gmock_description = (description);\</span>
<a name="l01502"></a>01502 <span class="preprocessor">        if (!gmock_description.empty())\</span>
<a name="l01503"></a>01503 <span class="preprocessor">          return gmock_description;\</span>
<a name="l01504"></a>01504 <span class="preprocessor">        return ::testing::internal::FormatMatcherDescription(\</span>
<a name="l01505"></a>01505 <span class="preprocessor">            negation, #name, \</span>
<a name="l01506"></a>01506 <span class="preprocessor">            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\</span>
<a name="l01507"></a>01507 <span class="preprocessor">                ::testing::tuple&lt;p0##_type, p1##_type&gt;(p0, p1)));\</span>
<a name="l01508"></a>01508 <span class="preprocessor">      }\</span>
<a name="l01509"></a>01509 <span class="preprocessor">      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\</span>
<a name="l01510"></a>01510 <span class="preprocessor">    };\</span>
<a name="l01511"></a>01511 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01512"></a>01512 <span class="preprocessor">    operator ::testing::Matcher&lt;arg_type&gt;() const {\</span>
<a name="l01513"></a>01513 <span class="preprocessor">      return ::testing::Matcher&lt;arg_type&gt;(\</span>
<a name="l01514"></a>01514 <span class="preprocessor">          new gmock_Impl&lt;arg_type&gt;(p0, p1));\</span>
<a name="l01515"></a>01515 <span class="preprocessor">    }\</span>
<a name="l01516"></a>01516 <span class="preprocessor">    name##MatcherP2(p0##_type gmock_p0, p1##_type gmock_p1) : p0(gmock_p0), \</span>
<a name="l01517"></a>01517 <span class="preprocessor">        p1(gmock_p1) {\</span>
<a name="l01518"></a>01518 <span class="preprocessor">    }\</span>
<a name="l01519"></a>01519 <span class="preprocessor">    p0##_type p0;\</span>
<a name="l01520"></a>01520 <span class="preprocessor">    p1##_type p1;\</span>
<a name="l01521"></a>01521 <span class="preprocessor">   private:\</span>
<a name="l01522"></a>01522 <span class="preprocessor">    GTEST_DISALLOW_ASSIGN_(name##MatcherP2);\</span>
<a name="l01523"></a>01523 <span class="preprocessor">  };\</span>
<a name="l01524"></a>01524 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type&gt;\</span>
<a name="l01525"></a>01525 <span class="preprocessor">  inline name##MatcherP2&lt;p0##_type, p1##_type&gt; name(p0##_type p0, \</span>
<a name="l01526"></a>01526 <span class="preprocessor">      p1##_type p1) {\</span>
<a name="l01527"></a>01527 <span class="preprocessor">    return name##MatcherP2&lt;p0##_type, p1##_type&gt;(p0, p1);\</span>
<a name="l01528"></a>01528 <span class="preprocessor">  }\</span>
<a name="l01529"></a>01529 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type&gt;\</span>
<a name="l01530"></a>01530 <span class="preprocessor">  template &lt;typename arg_type&gt;\</span>
<a name="l01531"></a>01531 <span class="preprocessor">  bool name##MatcherP2&lt;p0##_type, \</span>
<a name="l01532"></a>01532 <span class="preprocessor">      p1##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\</span>
<a name="l01533"></a>01533 <span class="preprocessor">      arg_type arg, \</span>
<a name="l01534"></a>01534 <span class="preprocessor">      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\</span>
<a name="l01535"></a>01535 <span class="preprocessor">          const</span>
<a name="l01536"></a>01536 <span class="preprocessor"></span>
<a name="l01537"></a><a class="code" href="gmock-generated-matchers_8h.html#a507103c6251f8bf4393ec119d9e34d34">01537</a> <span class="preprocessor">#define MATCHER_P3(name, p0, p1, p2, description)\</span>
<a name="l01538"></a>01538 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type&gt;\</span>
<a name="l01539"></a>01539 <span class="preprocessor">  class name##MatcherP3 {\</span>
<a name="l01540"></a>01540 <span class="preprocessor">   public:\</span>
<a name="l01541"></a>01541 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01542"></a>01542 <span class="preprocessor">    class gmock_Impl : public ::testing::MatcherInterface&lt;arg_type&gt; {\</span>
<a name="l01543"></a>01543 <span class="preprocessor">     public:\</span>
<a name="l01544"></a>01544 <span class="preprocessor">      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2)\</span>
<a name="l01545"></a>01545 <span class="preprocessor">           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {}\</span>
<a name="l01546"></a>01546 <span class="preprocessor">      virtual bool MatchAndExplain(\</span>
<a name="l01547"></a>01547 <span class="preprocessor">          arg_type arg, ::testing::MatchResultListener* result_listener) const;\</span>
<a name="l01548"></a>01548 <span class="preprocessor">      virtual void DescribeTo(::std::ostream* gmock_os) const {\</span>
<a name="l01549"></a>01549 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(false);\</span>
<a name="l01550"></a>01550 <span class="preprocessor">      }\</span>
<a name="l01551"></a>01551 <span class="preprocessor">      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\</span>
<a name="l01552"></a>01552 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(true);\</span>
<a name="l01553"></a>01553 <span class="preprocessor">      }\</span>
<a name="l01554"></a>01554 <span class="preprocessor">      p0##_type p0;\</span>
<a name="l01555"></a>01555 <span class="preprocessor">      p1##_type p1;\</span>
<a name="l01556"></a>01556 <span class="preprocessor">      p2##_type p2;\</span>
<a name="l01557"></a>01557 <span class="preprocessor">     private:\</span>
<a name="l01558"></a>01558 <span class="preprocessor">      ::testing::internal::string FormatDescription(bool negation) const {\</span>
<a name="l01559"></a>01559 <span class="preprocessor">        const ::testing::internal::string gmock_description = (description);\</span>
<a name="l01560"></a>01560 <span class="preprocessor">        if (!gmock_description.empty())\</span>
<a name="l01561"></a>01561 <span class="preprocessor">          return gmock_description;\</span>
<a name="l01562"></a>01562 <span class="preprocessor">        return ::testing::internal::FormatMatcherDescription(\</span>
<a name="l01563"></a>01563 <span class="preprocessor">            negation, #name, \</span>
<a name="l01564"></a>01564 <span class="preprocessor">            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\</span>
<a name="l01565"></a>01565 <span class="preprocessor">                ::testing::tuple&lt;p0##_type, p1##_type, p2##_type&gt;(p0, p1, \</span>
<a name="l01566"></a>01566 <span class="preprocessor">                    p2)));\</span>
<a name="l01567"></a>01567 <span class="preprocessor">      }\</span>
<a name="l01568"></a>01568 <span class="preprocessor">      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\</span>
<a name="l01569"></a>01569 <span class="preprocessor">    };\</span>
<a name="l01570"></a>01570 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01571"></a>01571 <span class="preprocessor">    operator ::testing::Matcher&lt;arg_type&gt;() const {\</span>
<a name="l01572"></a>01572 <span class="preprocessor">      return ::testing::Matcher&lt;arg_type&gt;(\</span>
<a name="l01573"></a>01573 <span class="preprocessor">          new gmock_Impl&lt;arg_type&gt;(p0, p1, p2));\</span>
<a name="l01574"></a>01574 <span class="preprocessor">    }\</span>
<a name="l01575"></a>01575 <span class="preprocessor">    name##MatcherP3(p0##_type gmock_p0, p1##_type gmock_p1, \</span>
<a name="l01576"></a>01576 <span class="preprocessor">        p2##_type gmock_p2) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2) {\</span>
<a name="l01577"></a>01577 <span class="preprocessor">    }\</span>
<a name="l01578"></a>01578 <span class="preprocessor">    p0##_type p0;\</span>
<a name="l01579"></a>01579 <span class="preprocessor">    p1##_type p1;\</span>
<a name="l01580"></a>01580 <span class="preprocessor">    p2##_type p2;\</span>
<a name="l01581"></a>01581 <span class="preprocessor">   private:\</span>
<a name="l01582"></a>01582 <span class="preprocessor">    GTEST_DISALLOW_ASSIGN_(name##MatcherP3);\</span>
<a name="l01583"></a>01583 <span class="preprocessor">  };\</span>
<a name="l01584"></a>01584 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type&gt;\</span>
<a name="l01585"></a>01585 <span class="preprocessor">  inline name##MatcherP3&lt;p0##_type, p1##_type, p2##_type&gt; name(p0##_type p0, \</span>
<a name="l01586"></a>01586 <span class="preprocessor">      p1##_type p1, p2##_type p2) {\</span>
<a name="l01587"></a>01587 <span class="preprocessor">    return name##MatcherP3&lt;p0##_type, p1##_type, p2##_type&gt;(p0, p1, p2);\</span>
<a name="l01588"></a>01588 <span class="preprocessor">  }\</span>
<a name="l01589"></a>01589 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type&gt;\</span>
<a name="l01590"></a>01590 <span class="preprocessor">  template &lt;typename arg_type&gt;\</span>
<a name="l01591"></a>01591 <span class="preprocessor">  bool name##MatcherP3&lt;p0##_type, p1##_type, \</span>
<a name="l01592"></a>01592 <span class="preprocessor">      p2##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\</span>
<a name="l01593"></a>01593 <span class="preprocessor">      arg_type arg, \</span>
<a name="l01594"></a>01594 <span class="preprocessor">      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\</span>
<a name="l01595"></a>01595 <span class="preprocessor">          const</span>
<a name="l01596"></a>01596 <span class="preprocessor"></span>
<a name="l01597"></a><a class="code" href="gmock-generated-matchers_8h.html#a6ec420ed6bc3ad073f19a4e32dd1f38f">01597</a> <span class="preprocessor">#define MATCHER_P4(name, p0, p1, p2, p3, description)\</span>
<a name="l01598"></a>01598 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01599"></a>01599 <span class="preprocessor">      typename p3##_type&gt;\</span>
<a name="l01600"></a>01600 <span class="preprocessor">  class name##MatcherP4 {\</span>
<a name="l01601"></a>01601 <span class="preprocessor">   public:\</span>
<a name="l01602"></a>01602 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01603"></a>01603 <span class="preprocessor">    class gmock_Impl : public ::testing::MatcherInterface&lt;arg_type&gt; {\</span>
<a name="l01604"></a>01604 <span class="preprocessor">     public:\</span>
<a name="l01605"></a>01605 <span class="preprocessor">      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \</span>
<a name="l01606"></a>01606 <span class="preprocessor">          p3##_type gmock_p3)\</span>
<a name="l01607"></a>01607 <span class="preprocessor">           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3) {}\</span>
<a name="l01608"></a>01608 <span class="preprocessor">      virtual bool MatchAndExplain(\</span>
<a name="l01609"></a>01609 <span class="preprocessor">          arg_type arg, ::testing::MatchResultListener* result_listener) const;\</span>
<a name="l01610"></a>01610 <span class="preprocessor">      virtual void DescribeTo(::std::ostream* gmock_os) const {\</span>
<a name="l01611"></a>01611 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(false);\</span>
<a name="l01612"></a>01612 <span class="preprocessor">      }\</span>
<a name="l01613"></a>01613 <span class="preprocessor">      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\</span>
<a name="l01614"></a>01614 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(true);\</span>
<a name="l01615"></a>01615 <span class="preprocessor">      }\</span>
<a name="l01616"></a>01616 <span class="preprocessor">      p0##_type p0;\</span>
<a name="l01617"></a>01617 <span class="preprocessor">      p1##_type p1;\</span>
<a name="l01618"></a>01618 <span class="preprocessor">      p2##_type p2;\</span>
<a name="l01619"></a>01619 <span class="preprocessor">      p3##_type p3;\</span>
<a name="l01620"></a>01620 <span class="preprocessor">     private:\</span>
<a name="l01621"></a>01621 <span class="preprocessor">      ::testing::internal::string FormatDescription(bool negation) const {\</span>
<a name="l01622"></a>01622 <span class="preprocessor">        const ::testing::internal::string gmock_description = (description);\</span>
<a name="l01623"></a>01623 <span class="preprocessor">        if (!gmock_description.empty())\</span>
<a name="l01624"></a>01624 <span class="preprocessor">          return gmock_description;\</span>
<a name="l01625"></a>01625 <span class="preprocessor">        return ::testing::internal::FormatMatcherDescription(\</span>
<a name="l01626"></a>01626 <span class="preprocessor">            negation, #name, \</span>
<a name="l01627"></a>01627 <span class="preprocessor">            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\</span>
<a name="l01628"></a>01628 <span class="preprocessor">                ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, \</span>
<a name="l01629"></a>01629 <span class="preprocessor">                    p3##_type&gt;(p0, p1, p2, p3)));\</span>
<a name="l01630"></a>01630 <span class="preprocessor">      }\</span>
<a name="l01631"></a>01631 <span class="preprocessor">      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\</span>
<a name="l01632"></a>01632 <span class="preprocessor">    };\</span>
<a name="l01633"></a>01633 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01634"></a>01634 <span class="preprocessor">    operator ::testing::Matcher&lt;arg_type&gt;() const {\</span>
<a name="l01635"></a>01635 <span class="preprocessor">      return ::testing::Matcher&lt;arg_type&gt;(\</span>
<a name="l01636"></a>01636 <span class="preprocessor">          new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3));\</span>
<a name="l01637"></a>01637 <span class="preprocessor">    }\</span>
<a name="l01638"></a>01638 <span class="preprocessor">    name##MatcherP4(p0##_type gmock_p0, p1##_type gmock_p1, \</span>
<a name="l01639"></a>01639 <span class="preprocessor">        p2##_type gmock_p2, p3##_type gmock_p3) : p0(gmock_p0), p1(gmock_p1), \</span>
<a name="l01640"></a>01640 <span class="preprocessor">        p2(gmock_p2), p3(gmock_p3) {\</span>
<a name="l01641"></a>01641 <span class="preprocessor">    }\</span>
<a name="l01642"></a>01642 <span class="preprocessor">    p0##_type p0;\</span>
<a name="l01643"></a>01643 <span class="preprocessor">    p1##_type p1;\</span>
<a name="l01644"></a>01644 <span class="preprocessor">    p2##_type p2;\</span>
<a name="l01645"></a>01645 <span class="preprocessor">    p3##_type p3;\</span>
<a name="l01646"></a>01646 <span class="preprocessor">   private:\</span>
<a name="l01647"></a>01647 <span class="preprocessor">    GTEST_DISALLOW_ASSIGN_(name##MatcherP4);\</span>
<a name="l01648"></a>01648 <span class="preprocessor">  };\</span>
<a name="l01649"></a>01649 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01650"></a>01650 <span class="preprocessor">      typename p3##_type&gt;\</span>
<a name="l01651"></a>01651 <span class="preprocessor">  inline name##MatcherP4&lt;p0##_type, p1##_type, p2##_type, \</span>
<a name="l01652"></a>01652 <span class="preprocessor">      p3##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, \</span>
<a name="l01653"></a>01653 <span class="preprocessor">      p3##_type p3) {\</span>
<a name="l01654"></a>01654 <span class="preprocessor">    return name##MatcherP4&lt;p0##_type, p1##_type, p2##_type, p3##_type&gt;(p0, \</span>
<a name="l01655"></a>01655 <span class="preprocessor">        p1, p2, p3);\</span>
<a name="l01656"></a>01656 <span class="preprocessor">  }\</span>
<a name="l01657"></a>01657 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01658"></a>01658 <span class="preprocessor">      typename p3##_type&gt;\</span>
<a name="l01659"></a>01659 <span class="preprocessor">  template &lt;typename arg_type&gt;\</span>
<a name="l01660"></a>01660 <span class="preprocessor">  bool name##MatcherP4&lt;p0##_type, p1##_type, p2##_type, \</span>
<a name="l01661"></a>01661 <span class="preprocessor">      p3##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\</span>
<a name="l01662"></a>01662 <span class="preprocessor">      arg_type arg, \</span>
<a name="l01663"></a>01663 <span class="preprocessor">      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\</span>
<a name="l01664"></a>01664 <span class="preprocessor">          const</span>
<a name="l01665"></a>01665 <span class="preprocessor"></span>
<a name="l01666"></a><a class="code" href="gmock-generated-matchers_8h.html#a3a9589cd79e2dbdb4e09981510c9c42e">01666</a> <span class="preprocessor">#define MATCHER_P5(name, p0, p1, p2, p3, p4, description)\</span>
<a name="l01667"></a>01667 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01668"></a>01668 <span class="preprocessor">      typename p3##_type, typename p4##_type&gt;\</span>
<a name="l01669"></a>01669 <span class="preprocessor">  class name##MatcherP5 {\</span>
<a name="l01670"></a>01670 <span class="preprocessor">   public:\</span>
<a name="l01671"></a>01671 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01672"></a>01672 <span class="preprocessor">    class gmock_Impl : public ::testing::MatcherInterface&lt;arg_type&gt; {\</span>
<a name="l01673"></a>01673 <span class="preprocessor">     public:\</span>
<a name="l01674"></a>01674 <span class="preprocessor">      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \</span>
<a name="l01675"></a>01675 <span class="preprocessor">          p3##_type gmock_p3, p4##_type gmock_p4)\</span>
<a name="l01676"></a>01676 <span class="preprocessor">           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \</span>
<a name="l01677"></a>01677 <span class="preprocessor">               p4(gmock_p4) {}\</span>
<a name="l01678"></a>01678 <span class="preprocessor">      virtual bool MatchAndExplain(\</span>
<a name="l01679"></a>01679 <span class="preprocessor">          arg_type arg, ::testing::MatchResultListener* result_listener) const;\</span>
<a name="l01680"></a>01680 <span class="preprocessor">      virtual void DescribeTo(::std::ostream* gmock_os) const {\</span>
<a name="l01681"></a>01681 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(false);\</span>
<a name="l01682"></a>01682 <span class="preprocessor">      }\</span>
<a name="l01683"></a>01683 <span class="preprocessor">      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\</span>
<a name="l01684"></a>01684 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(true);\</span>
<a name="l01685"></a>01685 <span class="preprocessor">      }\</span>
<a name="l01686"></a>01686 <span class="preprocessor">      p0##_type p0;\</span>
<a name="l01687"></a>01687 <span class="preprocessor">      p1##_type p1;\</span>
<a name="l01688"></a>01688 <span class="preprocessor">      p2##_type p2;\</span>
<a name="l01689"></a>01689 <span class="preprocessor">      p3##_type p3;\</span>
<a name="l01690"></a>01690 <span class="preprocessor">      p4##_type p4;\</span>
<a name="l01691"></a>01691 <span class="preprocessor">     private:\</span>
<a name="l01692"></a>01692 <span class="preprocessor">      ::testing::internal::string FormatDescription(bool negation) const {\</span>
<a name="l01693"></a>01693 <span class="preprocessor">        const ::testing::internal::string gmock_description = (description);\</span>
<a name="l01694"></a>01694 <span class="preprocessor">        if (!gmock_description.empty())\</span>
<a name="l01695"></a>01695 <span class="preprocessor">          return gmock_description;\</span>
<a name="l01696"></a>01696 <span class="preprocessor">        return ::testing::internal::FormatMatcherDescription(\</span>
<a name="l01697"></a>01697 <span class="preprocessor">            negation, #name, \</span>
<a name="l01698"></a>01698 <span class="preprocessor">            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\</span>
<a name="l01699"></a>01699 <span class="preprocessor">                ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01700"></a>01700 <span class="preprocessor">                    p4##_type&gt;(p0, p1, p2, p3, p4)));\</span>
<a name="l01701"></a>01701 <span class="preprocessor">      }\</span>
<a name="l01702"></a>01702 <span class="preprocessor">      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\</span>
<a name="l01703"></a>01703 <span class="preprocessor">    };\</span>
<a name="l01704"></a>01704 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01705"></a>01705 <span class="preprocessor">    operator ::testing::Matcher&lt;arg_type&gt;() const {\</span>
<a name="l01706"></a>01706 <span class="preprocessor">      return ::testing::Matcher&lt;arg_type&gt;(\</span>
<a name="l01707"></a>01707 <span class="preprocessor">          new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4));\</span>
<a name="l01708"></a>01708 <span class="preprocessor">    }\</span>
<a name="l01709"></a>01709 <span class="preprocessor">    name##MatcherP5(p0##_type gmock_p0, p1##_type gmock_p1, \</span>
<a name="l01710"></a>01710 <span class="preprocessor">        p2##_type gmock_p2, p3##_type gmock_p3, \</span>
<a name="l01711"></a>01711 <span class="preprocessor">        p4##_type gmock_p4) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \</span>
<a name="l01712"></a>01712 <span class="preprocessor">        p3(gmock_p3), p4(gmock_p4) {\</span>
<a name="l01713"></a>01713 <span class="preprocessor">    }\</span>
<a name="l01714"></a>01714 <span class="preprocessor">    p0##_type p0;\</span>
<a name="l01715"></a>01715 <span class="preprocessor">    p1##_type p1;\</span>
<a name="l01716"></a>01716 <span class="preprocessor">    p2##_type p2;\</span>
<a name="l01717"></a>01717 <span class="preprocessor">    p3##_type p3;\</span>
<a name="l01718"></a>01718 <span class="preprocessor">    p4##_type p4;\</span>
<a name="l01719"></a>01719 <span class="preprocessor">   private:\</span>
<a name="l01720"></a>01720 <span class="preprocessor">    GTEST_DISALLOW_ASSIGN_(name##MatcherP5);\</span>
<a name="l01721"></a>01721 <span class="preprocessor">  };\</span>
<a name="l01722"></a>01722 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01723"></a>01723 <span class="preprocessor">      typename p3##_type, typename p4##_type&gt;\</span>
<a name="l01724"></a>01724 <span class="preprocessor">  inline name##MatcherP5&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01725"></a>01725 <span class="preprocessor">      p4##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \</span>
<a name="l01726"></a>01726 <span class="preprocessor">      p4##_type p4) {\</span>
<a name="l01727"></a>01727 <span class="preprocessor">    return name##MatcherP5&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01728"></a>01728 <span class="preprocessor">        p4##_type&gt;(p0, p1, p2, p3, p4);\</span>
<a name="l01729"></a>01729 <span class="preprocessor">  }\</span>
<a name="l01730"></a>01730 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01731"></a>01731 <span class="preprocessor">      typename p3##_type, typename p4##_type&gt;\</span>
<a name="l01732"></a>01732 <span class="preprocessor">  template &lt;typename arg_type&gt;\</span>
<a name="l01733"></a>01733 <span class="preprocessor">  bool name##MatcherP5&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01734"></a>01734 <span class="preprocessor">      p4##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\</span>
<a name="l01735"></a>01735 <span class="preprocessor">      arg_type arg, \</span>
<a name="l01736"></a>01736 <span class="preprocessor">      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\</span>
<a name="l01737"></a>01737 <span class="preprocessor">          const</span>
<a name="l01738"></a>01738 <span class="preprocessor"></span>
<a name="l01739"></a><a class="code" href="gmock-generated-matchers_8h.html#aceda758bb064965b2b9a7e0e96085861">01739</a> <span class="preprocessor">#define MATCHER_P6(name, p0, p1, p2, p3, p4, p5, description)\</span>
<a name="l01740"></a>01740 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01741"></a>01741 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type&gt;\</span>
<a name="l01742"></a>01742 <span class="preprocessor">  class name##MatcherP6 {\</span>
<a name="l01743"></a>01743 <span class="preprocessor">   public:\</span>
<a name="l01744"></a>01744 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01745"></a>01745 <span class="preprocessor">    class gmock_Impl : public ::testing::MatcherInterface&lt;arg_type&gt; {\</span>
<a name="l01746"></a>01746 <span class="preprocessor">     public:\</span>
<a name="l01747"></a>01747 <span class="preprocessor">      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \</span>
<a name="l01748"></a>01748 <span class="preprocessor">          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5)\</span>
<a name="l01749"></a>01749 <span class="preprocessor">           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \</span>
<a name="l01750"></a>01750 <span class="preprocessor">               p4(gmock_p4), p5(gmock_p5) {}\</span>
<a name="l01751"></a>01751 <span class="preprocessor">      virtual bool MatchAndExplain(\</span>
<a name="l01752"></a>01752 <span class="preprocessor">          arg_type arg, ::testing::MatchResultListener* result_listener) const;\</span>
<a name="l01753"></a>01753 <span class="preprocessor">      virtual void DescribeTo(::std::ostream* gmock_os) const {\</span>
<a name="l01754"></a>01754 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(false);\</span>
<a name="l01755"></a>01755 <span class="preprocessor">      }\</span>
<a name="l01756"></a>01756 <span class="preprocessor">      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\</span>
<a name="l01757"></a>01757 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(true);\</span>
<a name="l01758"></a>01758 <span class="preprocessor">      }\</span>
<a name="l01759"></a>01759 <span class="preprocessor">      p0##_type p0;\</span>
<a name="l01760"></a>01760 <span class="preprocessor">      p1##_type p1;\</span>
<a name="l01761"></a>01761 <span class="preprocessor">      p2##_type p2;\</span>
<a name="l01762"></a>01762 <span class="preprocessor">      p3##_type p3;\</span>
<a name="l01763"></a>01763 <span class="preprocessor">      p4##_type p4;\</span>
<a name="l01764"></a>01764 <span class="preprocessor">      p5##_type p5;\</span>
<a name="l01765"></a>01765 <span class="preprocessor">     private:\</span>
<a name="l01766"></a>01766 <span class="preprocessor">      ::testing::internal::string FormatDescription(bool negation) const {\</span>
<a name="l01767"></a>01767 <span class="preprocessor">        const ::testing::internal::string gmock_description = (description);\</span>
<a name="l01768"></a>01768 <span class="preprocessor">        if (!gmock_description.empty())\</span>
<a name="l01769"></a>01769 <span class="preprocessor">          return gmock_description;\</span>
<a name="l01770"></a>01770 <span class="preprocessor">        return ::testing::internal::FormatMatcherDescription(\</span>
<a name="l01771"></a>01771 <span class="preprocessor">            negation, #name, \</span>
<a name="l01772"></a>01772 <span class="preprocessor">            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\</span>
<a name="l01773"></a>01773 <span class="preprocessor">                ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01774"></a>01774 <span class="preprocessor">                    p4##_type, p5##_type&gt;(p0, p1, p2, p3, p4, p5)));\</span>
<a name="l01775"></a>01775 <span class="preprocessor">      }\</span>
<a name="l01776"></a>01776 <span class="preprocessor">      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\</span>
<a name="l01777"></a>01777 <span class="preprocessor">    };\</span>
<a name="l01778"></a>01778 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01779"></a>01779 <span class="preprocessor">    operator ::testing::Matcher&lt;arg_type&gt;() const {\</span>
<a name="l01780"></a>01780 <span class="preprocessor">      return ::testing::Matcher&lt;arg_type&gt;(\</span>
<a name="l01781"></a>01781 <span class="preprocessor">          new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5));\</span>
<a name="l01782"></a>01782 <span class="preprocessor">    }\</span>
<a name="l01783"></a>01783 <span class="preprocessor">    name##MatcherP6(p0##_type gmock_p0, p1##_type gmock_p1, \</span>
<a name="l01784"></a>01784 <span class="preprocessor">        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \</span>
<a name="l01785"></a>01785 <span class="preprocessor">        p5##_type gmock_p5) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \</span>
<a name="l01786"></a>01786 <span class="preprocessor">        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5) {\</span>
<a name="l01787"></a>01787 <span class="preprocessor">    }\</span>
<a name="l01788"></a>01788 <span class="preprocessor">    p0##_type p0;\</span>
<a name="l01789"></a>01789 <span class="preprocessor">    p1##_type p1;\</span>
<a name="l01790"></a>01790 <span class="preprocessor">    p2##_type p2;\</span>
<a name="l01791"></a>01791 <span class="preprocessor">    p3##_type p3;\</span>
<a name="l01792"></a>01792 <span class="preprocessor">    p4##_type p4;\</span>
<a name="l01793"></a>01793 <span class="preprocessor">    p5##_type p5;\</span>
<a name="l01794"></a>01794 <span class="preprocessor">   private:\</span>
<a name="l01795"></a>01795 <span class="preprocessor">    GTEST_DISALLOW_ASSIGN_(name##MatcherP6);\</span>
<a name="l01796"></a>01796 <span class="preprocessor">  };\</span>
<a name="l01797"></a>01797 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01798"></a>01798 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type&gt;\</span>
<a name="l01799"></a>01799 <span class="preprocessor">  inline name##MatcherP6&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01800"></a>01800 <span class="preprocessor">      p4##_type, p5##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, \</span>
<a name="l01801"></a>01801 <span class="preprocessor">      p3##_type p3, p4##_type p4, p5##_type p5) {\</span>
<a name="l01802"></a>01802 <span class="preprocessor">    return name##MatcherP6&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01803"></a>01803 <span class="preprocessor">        p4##_type, p5##_type&gt;(p0, p1, p2, p3, p4, p5);\</span>
<a name="l01804"></a>01804 <span class="preprocessor">  }\</span>
<a name="l01805"></a>01805 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01806"></a>01806 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type&gt;\</span>
<a name="l01807"></a>01807 <span class="preprocessor">  template &lt;typename arg_type&gt;\</span>
<a name="l01808"></a>01808 <span class="preprocessor">  bool name##MatcherP6&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \</span>
<a name="l01809"></a>01809 <span class="preprocessor">      p5##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\</span>
<a name="l01810"></a>01810 <span class="preprocessor">      arg_type arg, \</span>
<a name="l01811"></a>01811 <span class="preprocessor">      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\</span>
<a name="l01812"></a>01812 <span class="preprocessor">          const</span>
<a name="l01813"></a>01813 <span class="preprocessor"></span>
<a name="l01814"></a><a class="code" href="gmock-generated-matchers_8h.html#a2948ce54387a83c33fa98ba0c73eb11f">01814</a> <span class="preprocessor">#define MATCHER_P7(name, p0, p1, p2, p3, p4, p5, p6, description)\</span>
<a name="l01815"></a>01815 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01816"></a>01816 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type, \</span>
<a name="l01817"></a>01817 <span class="preprocessor">      typename p6##_type&gt;\</span>
<a name="l01818"></a>01818 <span class="preprocessor">  class name##MatcherP7 {\</span>
<a name="l01819"></a>01819 <span class="preprocessor">   public:\</span>
<a name="l01820"></a>01820 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01821"></a>01821 <span class="preprocessor">    class gmock_Impl : public ::testing::MatcherInterface&lt;arg_type&gt; {\</span>
<a name="l01822"></a>01822 <span class="preprocessor">     public:\</span>
<a name="l01823"></a>01823 <span class="preprocessor">      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \</span>
<a name="l01824"></a>01824 <span class="preprocessor">          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \</span>
<a name="l01825"></a>01825 <span class="preprocessor">          p6##_type gmock_p6)\</span>
<a name="l01826"></a>01826 <span class="preprocessor">           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \</span>
<a name="l01827"></a>01827 <span class="preprocessor">               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6) {}\</span>
<a name="l01828"></a>01828 <span class="preprocessor">      virtual bool MatchAndExplain(\</span>
<a name="l01829"></a>01829 <span class="preprocessor">          arg_type arg, ::testing::MatchResultListener* result_listener) const;\</span>
<a name="l01830"></a>01830 <span class="preprocessor">      virtual void DescribeTo(::std::ostream* gmock_os) const {\</span>
<a name="l01831"></a>01831 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(false);\</span>
<a name="l01832"></a>01832 <span class="preprocessor">      }\</span>
<a name="l01833"></a>01833 <span class="preprocessor">      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\</span>
<a name="l01834"></a>01834 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(true);\</span>
<a name="l01835"></a>01835 <span class="preprocessor">      }\</span>
<a name="l01836"></a>01836 <span class="preprocessor">      p0##_type p0;\</span>
<a name="l01837"></a>01837 <span class="preprocessor">      p1##_type p1;\</span>
<a name="l01838"></a>01838 <span class="preprocessor">      p2##_type p2;\</span>
<a name="l01839"></a>01839 <span class="preprocessor">      p3##_type p3;\</span>
<a name="l01840"></a>01840 <span class="preprocessor">      p4##_type p4;\</span>
<a name="l01841"></a>01841 <span class="preprocessor">      p5##_type p5;\</span>
<a name="l01842"></a>01842 <span class="preprocessor">      p6##_type p6;\</span>
<a name="l01843"></a>01843 <span class="preprocessor">     private:\</span>
<a name="l01844"></a>01844 <span class="preprocessor">      ::testing::internal::string FormatDescription(bool negation) const {\</span>
<a name="l01845"></a>01845 <span class="preprocessor">        const ::testing::internal::string gmock_description = (description);\</span>
<a name="l01846"></a>01846 <span class="preprocessor">        if (!gmock_description.empty())\</span>
<a name="l01847"></a>01847 <span class="preprocessor">          return gmock_description;\</span>
<a name="l01848"></a>01848 <span class="preprocessor">        return ::testing::internal::FormatMatcherDescription(\</span>
<a name="l01849"></a>01849 <span class="preprocessor">            negation, #name, \</span>
<a name="l01850"></a>01850 <span class="preprocessor">            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\</span>
<a name="l01851"></a>01851 <span class="preprocessor">                ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01852"></a>01852 <span class="preprocessor">                    p4##_type, p5##_type, p6##_type&gt;(p0, p1, p2, p3, p4, p5, \</span>
<a name="l01853"></a>01853 <span class="preprocessor">                    p6)));\</span>
<a name="l01854"></a>01854 <span class="preprocessor">      }\</span>
<a name="l01855"></a>01855 <span class="preprocessor">      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\</span>
<a name="l01856"></a>01856 <span class="preprocessor">    };\</span>
<a name="l01857"></a>01857 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01858"></a>01858 <span class="preprocessor">    operator ::testing::Matcher&lt;arg_type&gt;() const {\</span>
<a name="l01859"></a>01859 <span class="preprocessor">      return ::testing::Matcher&lt;arg_type&gt;(\</span>
<a name="l01860"></a>01860 <span class="preprocessor">          new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5, p6));\</span>
<a name="l01861"></a>01861 <span class="preprocessor">    }\</span>
<a name="l01862"></a>01862 <span class="preprocessor">    name##MatcherP7(p0##_type gmock_p0, p1##_type gmock_p1, \</span>
<a name="l01863"></a>01863 <span class="preprocessor">        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \</span>
<a name="l01864"></a>01864 <span class="preprocessor">        p5##_type gmock_p5, p6##_type gmock_p6) : p0(gmock_p0), p1(gmock_p1), \</span>
<a name="l01865"></a>01865 <span class="preprocessor">        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), \</span>
<a name="l01866"></a>01866 <span class="preprocessor">        p6(gmock_p6) {\</span>
<a name="l01867"></a>01867 <span class="preprocessor">    }\</span>
<a name="l01868"></a>01868 <span class="preprocessor">    p0##_type p0;\</span>
<a name="l01869"></a>01869 <span class="preprocessor">    p1##_type p1;\</span>
<a name="l01870"></a>01870 <span class="preprocessor">    p2##_type p2;\</span>
<a name="l01871"></a>01871 <span class="preprocessor">    p3##_type p3;\</span>
<a name="l01872"></a>01872 <span class="preprocessor">    p4##_type p4;\</span>
<a name="l01873"></a>01873 <span class="preprocessor">    p5##_type p5;\</span>
<a name="l01874"></a>01874 <span class="preprocessor">    p6##_type p6;\</span>
<a name="l01875"></a>01875 <span class="preprocessor">   private:\</span>
<a name="l01876"></a>01876 <span class="preprocessor">    GTEST_DISALLOW_ASSIGN_(name##MatcherP7);\</span>
<a name="l01877"></a>01877 <span class="preprocessor">  };\</span>
<a name="l01878"></a>01878 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01879"></a>01879 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type, \</span>
<a name="l01880"></a>01880 <span class="preprocessor">      typename p6##_type&gt;\</span>
<a name="l01881"></a>01881 <span class="preprocessor">  inline name##MatcherP7&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01882"></a>01882 <span class="preprocessor">      p4##_type, p5##_type, p6##_type&gt; name(p0##_type p0, p1##_type p1, \</span>
<a name="l01883"></a>01883 <span class="preprocessor">      p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \</span>
<a name="l01884"></a>01884 <span class="preprocessor">      p6##_type p6) {\</span>
<a name="l01885"></a>01885 <span class="preprocessor">    return name##MatcherP7&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01886"></a>01886 <span class="preprocessor">        p4##_type, p5##_type, p6##_type&gt;(p0, p1, p2, p3, p4, p5, p6);\</span>
<a name="l01887"></a>01887 <span class="preprocessor">  }\</span>
<a name="l01888"></a>01888 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01889"></a>01889 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type, \</span>
<a name="l01890"></a>01890 <span class="preprocessor">      typename p6##_type&gt;\</span>
<a name="l01891"></a>01891 <span class="preprocessor">  template &lt;typename arg_type&gt;\</span>
<a name="l01892"></a>01892 <span class="preprocessor">  bool name##MatcherP7&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \</span>
<a name="l01893"></a>01893 <span class="preprocessor">      p5##_type, p6##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\</span>
<a name="l01894"></a>01894 <span class="preprocessor">      arg_type arg, \</span>
<a name="l01895"></a>01895 <span class="preprocessor">      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\</span>
<a name="l01896"></a>01896 <span class="preprocessor">          const</span>
<a name="l01897"></a>01897 <span class="preprocessor"></span>
<a name="l01898"></a><a class="code" href="gmock-generated-matchers_8h.html#ad86c95b03df37fada38e18d8eb9e53bc">01898</a> <span class="preprocessor">#define MATCHER_P8(name, p0, p1, p2, p3, p4, p5, p6, p7, description)\</span>
<a name="l01899"></a>01899 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01900"></a>01900 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type, \</span>
<a name="l01901"></a>01901 <span class="preprocessor">      typename p6##_type, typename p7##_type&gt;\</span>
<a name="l01902"></a>01902 <span class="preprocessor">  class name##MatcherP8 {\</span>
<a name="l01903"></a>01903 <span class="preprocessor">   public:\</span>
<a name="l01904"></a>01904 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01905"></a>01905 <span class="preprocessor">    class gmock_Impl : public ::testing::MatcherInterface&lt;arg_type&gt; {\</span>
<a name="l01906"></a>01906 <span class="preprocessor">     public:\</span>
<a name="l01907"></a>01907 <span class="preprocessor">      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \</span>
<a name="l01908"></a>01908 <span class="preprocessor">          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \</span>
<a name="l01909"></a>01909 <span class="preprocessor">          p6##_type gmock_p6, p7##_type gmock_p7)\</span>
<a name="l01910"></a>01910 <span class="preprocessor">           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \</span>
<a name="l01911"></a>01911 <span class="preprocessor">               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7) {}\</span>
<a name="l01912"></a>01912 <span class="preprocessor">      virtual bool MatchAndExplain(\</span>
<a name="l01913"></a>01913 <span class="preprocessor">          arg_type arg, ::testing::MatchResultListener* result_listener) const;\</span>
<a name="l01914"></a>01914 <span class="preprocessor">      virtual void DescribeTo(::std::ostream* gmock_os) const {\</span>
<a name="l01915"></a>01915 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(false);\</span>
<a name="l01916"></a>01916 <span class="preprocessor">      }\</span>
<a name="l01917"></a>01917 <span class="preprocessor">      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\</span>
<a name="l01918"></a>01918 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(true);\</span>
<a name="l01919"></a>01919 <span class="preprocessor">      }\</span>
<a name="l01920"></a>01920 <span class="preprocessor">      p0##_type p0;\</span>
<a name="l01921"></a>01921 <span class="preprocessor">      p1##_type p1;\</span>
<a name="l01922"></a>01922 <span class="preprocessor">      p2##_type p2;\</span>
<a name="l01923"></a>01923 <span class="preprocessor">      p3##_type p3;\</span>
<a name="l01924"></a>01924 <span class="preprocessor">      p4##_type p4;\</span>
<a name="l01925"></a>01925 <span class="preprocessor">      p5##_type p5;\</span>
<a name="l01926"></a>01926 <span class="preprocessor">      p6##_type p6;\</span>
<a name="l01927"></a>01927 <span class="preprocessor">      p7##_type p7;\</span>
<a name="l01928"></a>01928 <span class="preprocessor">     private:\</span>
<a name="l01929"></a>01929 <span class="preprocessor">      ::testing::internal::string FormatDescription(bool negation) const {\</span>
<a name="l01930"></a>01930 <span class="preprocessor">        const ::testing::internal::string gmock_description = (description);\</span>
<a name="l01931"></a>01931 <span class="preprocessor">        if (!gmock_description.empty())\</span>
<a name="l01932"></a>01932 <span class="preprocessor">          return gmock_description;\</span>
<a name="l01933"></a>01933 <span class="preprocessor">        return ::testing::internal::FormatMatcherDescription(\</span>
<a name="l01934"></a>01934 <span class="preprocessor">            negation, #name, \</span>
<a name="l01935"></a>01935 <span class="preprocessor">            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\</span>
<a name="l01936"></a>01936 <span class="preprocessor">                ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01937"></a>01937 <span class="preprocessor">                    p4##_type, p5##_type, p6##_type, p7##_type&gt;(p0, p1, p2, \</span>
<a name="l01938"></a>01938 <span class="preprocessor">                    p3, p4, p5, p6, p7)));\</span>
<a name="l01939"></a>01939 <span class="preprocessor">      }\</span>
<a name="l01940"></a>01940 <span class="preprocessor">      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\</span>
<a name="l01941"></a>01941 <span class="preprocessor">    };\</span>
<a name="l01942"></a>01942 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01943"></a>01943 <span class="preprocessor">    operator ::testing::Matcher&lt;arg_type&gt;() const {\</span>
<a name="l01944"></a>01944 <span class="preprocessor">      return ::testing::Matcher&lt;arg_type&gt;(\</span>
<a name="l01945"></a>01945 <span class="preprocessor">          new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7));\</span>
<a name="l01946"></a>01946 <span class="preprocessor">    }\</span>
<a name="l01947"></a>01947 <span class="preprocessor">    name##MatcherP8(p0##_type gmock_p0, p1##_type gmock_p1, \</span>
<a name="l01948"></a>01948 <span class="preprocessor">        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \</span>
<a name="l01949"></a>01949 <span class="preprocessor">        p5##_type gmock_p5, p6##_type gmock_p6, \</span>
<a name="l01950"></a>01950 <span class="preprocessor">        p7##_type gmock_p7) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \</span>
<a name="l01951"></a>01951 <span class="preprocessor">        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \</span>
<a name="l01952"></a>01952 <span class="preprocessor">        p7(gmock_p7) {\</span>
<a name="l01953"></a>01953 <span class="preprocessor">    }\</span>
<a name="l01954"></a>01954 <span class="preprocessor">    p0##_type p0;\</span>
<a name="l01955"></a>01955 <span class="preprocessor">    p1##_type p1;\</span>
<a name="l01956"></a>01956 <span class="preprocessor">    p2##_type p2;\</span>
<a name="l01957"></a>01957 <span class="preprocessor">    p3##_type p3;\</span>
<a name="l01958"></a>01958 <span class="preprocessor">    p4##_type p4;\</span>
<a name="l01959"></a>01959 <span class="preprocessor">    p5##_type p5;\</span>
<a name="l01960"></a>01960 <span class="preprocessor">    p6##_type p6;\</span>
<a name="l01961"></a>01961 <span class="preprocessor">    p7##_type p7;\</span>
<a name="l01962"></a>01962 <span class="preprocessor">   private:\</span>
<a name="l01963"></a>01963 <span class="preprocessor">    GTEST_DISALLOW_ASSIGN_(name##MatcherP8);\</span>
<a name="l01964"></a>01964 <span class="preprocessor">  };\</span>
<a name="l01965"></a>01965 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01966"></a>01966 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type, \</span>
<a name="l01967"></a>01967 <span class="preprocessor">      typename p6##_type, typename p7##_type&gt;\</span>
<a name="l01968"></a>01968 <span class="preprocessor">  inline name##MatcherP8&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01969"></a>01969 <span class="preprocessor">      p4##_type, p5##_type, p6##_type, p7##_type&gt; name(p0##_type p0, \</span>
<a name="l01970"></a>01970 <span class="preprocessor">      p1##_type p1, p2##_type p2, p3##_type p3, p4##_type p4, p5##_type p5, \</span>
<a name="l01971"></a>01971 <span class="preprocessor">      p6##_type p6, p7##_type p7) {\</span>
<a name="l01972"></a>01972 <span class="preprocessor">    return name##MatcherP8&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l01973"></a>01973 <span class="preprocessor">        p4##_type, p5##_type, p6##_type, p7##_type&gt;(p0, p1, p2, p3, p4, p5, \</span>
<a name="l01974"></a>01974 <span class="preprocessor">        p6, p7);\</span>
<a name="l01975"></a>01975 <span class="preprocessor">  }\</span>
<a name="l01976"></a>01976 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01977"></a>01977 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type, \</span>
<a name="l01978"></a>01978 <span class="preprocessor">      typename p6##_type, typename p7##_type&gt;\</span>
<a name="l01979"></a>01979 <span class="preprocessor">  template &lt;typename arg_type&gt;\</span>
<a name="l01980"></a>01980 <span class="preprocessor">  bool name##MatcherP8&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \</span>
<a name="l01981"></a>01981 <span class="preprocessor">      p5##_type, p6##_type, \</span>
<a name="l01982"></a>01982 <span class="preprocessor">      p7##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\</span>
<a name="l01983"></a>01983 <span class="preprocessor">      arg_type arg, \</span>
<a name="l01984"></a>01984 <span class="preprocessor">      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\</span>
<a name="l01985"></a>01985 <span class="preprocessor">          const</span>
<a name="l01986"></a>01986 <span class="preprocessor"></span>
<a name="l01987"></a><a class="code" href="gmock-generated-matchers_8h.html#a2dc1db146d4112c9fde1c2708807e43e">01987</a> <span class="preprocessor">#define MATCHER_P9(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, description)\</span>
<a name="l01988"></a>01988 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l01989"></a>01989 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type, \</span>
<a name="l01990"></a>01990 <span class="preprocessor">      typename p6##_type, typename p7##_type, typename p8##_type&gt;\</span>
<a name="l01991"></a>01991 <span class="preprocessor">  class name##MatcherP9 {\</span>
<a name="l01992"></a>01992 <span class="preprocessor">   public:\</span>
<a name="l01993"></a>01993 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l01994"></a>01994 <span class="preprocessor">    class gmock_Impl : public ::testing::MatcherInterface&lt;arg_type&gt; {\</span>
<a name="l01995"></a>01995 <span class="preprocessor">     public:\</span>
<a name="l01996"></a>01996 <span class="preprocessor">      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \</span>
<a name="l01997"></a>01997 <span class="preprocessor">          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \</span>
<a name="l01998"></a>01998 <span class="preprocessor">          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8)\</span>
<a name="l01999"></a>01999 <span class="preprocessor">           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \</span>
<a name="l02000"></a>02000 <span class="preprocessor">               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \</span>
<a name="l02001"></a>02001 <span class="preprocessor">               p8(gmock_p8) {}\</span>
<a name="l02002"></a>02002 <span class="preprocessor">      virtual bool MatchAndExplain(\</span>
<a name="l02003"></a>02003 <span class="preprocessor">          arg_type arg, ::testing::MatchResultListener* result_listener) const;\</span>
<a name="l02004"></a>02004 <span class="preprocessor">      virtual void DescribeTo(::std::ostream* gmock_os) const {\</span>
<a name="l02005"></a>02005 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(false);\</span>
<a name="l02006"></a>02006 <span class="preprocessor">      }\</span>
<a name="l02007"></a>02007 <span class="preprocessor">      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\</span>
<a name="l02008"></a>02008 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(true);\</span>
<a name="l02009"></a>02009 <span class="preprocessor">      }\</span>
<a name="l02010"></a>02010 <span class="preprocessor">      p0##_type p0;\</span>
<a name="l02011"></a>02011 <span class="preprocessor">      p1##_type p1;\</span>
<a name="l02012"></a>02012 <span class="preprocessor">      p2##_type p2;\</span>
<a name="l02013"></a>02013 <span class="preprocessor">      p3##_type p3;\</span>
<a name="l02014"></a>02014 <span class="preprocessor">      p4##_type p4;\</span>
<a name="l02015"></a>02015 <span class="preprocessor">      p5##_type p5;\</span>
<a name="l02016"></a>02016 <span class="preprocessor">      p6##_type p6;\</span>
<a name="l02017"></a>02017 <span class="preprocessor">      p7##_type p7;\</span>
<a name="l02018"></a>02018 <span class="preprocessor">      p8##_type p8;\</span>
<a name="l02019"></a>02019 <span class="preprocessor">     private:\</span>
<a name="l02020"></a>02020 <span class="preprocessor">      ::testing::internal::string FormatDescription(bool negation) const {\</span>
<a name="l02021"></a>02021 <span class="preprocessor">        const ::testing::internal::string gmock_description = (description);\</span>
<a name="l02022"></a>02022 <span class="preprocessor">        if (!gmock_description.empty())\</span>
<a name="l02023"></a>02023 <span class="preprocessor">          return gmock_description;\</span>
<a name="l02024"></a>02024 <span class="preprocessor">        return ::testing::internal::FormatMatcherDescription(\</span>
<a name="l02025"></a>02025 <span class="preprocessor">            negation, #name, \</span>
<a name="l02026"></a>02026 <span class="preprocessor">            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\</span>
<a name="l02027"></a>02027 <span class="preprocessor">                ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l02028"></a>02028 <span class="preprocessor">                    p4##_type, p5##_type, p6##_type, p7##_type, \</span>
<a name="l02029"></a>02029 <span class="preprocessor">                    p8##_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8)));\</span>
<a name="l02030"></a>02030 <span class="preprocessor">      }\</span>
<a name="l02031"></a>02031 <span class="preprocessor">      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\</span>
<a name="l02032"></a>02032 <span class="preprocessor">    };\</span>
<a name="l02033"></a>02033 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l02034"></a>02034 <span class="preprocessor">    operator ::testing::Matcher&lt;arg_type&gt;() const {\</span>
<a name="l02035"></a>02035 <span class="preprocessor">      return ::testing::Matcher&lt;arg_type&gt;(\</span>
<a name="l02036"></a>02036 <span class="preprocessor">          new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8));\</span>
<a name="l02037"></a>02037 <span class="preprocessor">    }\</span>
<a name="l02038"></a>02038 <span class="preprocessor">    name##MatcherP9(p0##_type gmock_p0, p1##_type gmock_p1, \</span>
<a name="l02039"></a>02039 <span class="preprocessor">        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \</span>
<a name="l02040"></a>02040 <span class="preprocessor">        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \</span>
<a name="l02041"></a>02041 <span class="preprocessor">        p8##_type gmock_p8) : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), \</span>
<a name="l02042"></a>02042 <span class="preprocessor">        p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \</span>
<a name="l02043"></a>02043 <span class="preprocessor">        p8(gmock_p8) {\</span>
<a name="l02044"></a>02044 <span class="preprocessor">    }\</span>
<a name="l02045"></a>02045 <span class="preprocessor">    p0##_type p0;\</span>
<a name="l02046"></a>02046 <span class="preprocessor">    p1##_type p1;\</span>
<a name="l02047"></a>02047 <span class="preprocessor">    p2##_type p2;\</span>
<a name="l02048"></a>02048 <span class="preprocessor">    p3##_type p3;\</span>
<a name="l02049"></a>02049 <span class="preprocessor">    p4##_type p4;\</span>
<a name="l02050"></a>02050 <span class="preprocessor">    p5##_type p5;\</span>
<a name="l02051"></a>02051 <span class="preprocessor">    p6##_type p6;\</span>
<a name="l02052"></a>02052 <span class="preprocessor">    p7##_type p7;\</span>
<a name="l02053"></a>02053 <span class="preprocessor">    p8##_type p8;\</span>
<a name="l02054"></a>02054 <span class="preprocessor">   private:\</span>
<a name="l02055"></a>02055 <span class="preprocessor">    GTEST_DISALLOW_ASSIGN_(name##MatcherP9);\</span>
<a name="l02056"></a>02056 <span class="preprocessor">  };\</span>
<a name="l02057"></a>02057 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l02058"></a>02058 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type, \</span>
<a name="l02059"></a>02059 <span class="preprocessor">      typename p6##_type, typename p7##_type, typename p8##_type&gt;\</span>
<a name="l02060"></a>02060 <span class="preprocessor">  inline name##MatcherP9&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l02061"></a>02061 <span class="preprocessor">      p4##_type, p5##_type, p6##_type, p7##_type, \</span>
<a name="l02062"></a>02062 <span class="preprocessor">      p8##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \</span>
<a name="l02063"></a>02063 <span class="preprocessor">      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, \</span>
<a name="l02064"></a>02064 <span class="preprocessor">      p8##_type p8) {\</span>
<a name="l02065"></a>02065 <span class="preprocessor">    return name##MatcherP9&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l02066"></a>02066 <span class="preprocessor">        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type&gt;(p0, p1, p2, \</span>
<a name="l02067"></a>02067 <span class="preprocessor">        p3, p4, p5, p6, p7, p8);\</span>
<a name="l02068"></a>02068 <span class="preprocessor">  }\</span>
<a name="l02069"></a>02069 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l02070"></a>02070 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type, \</span>
<a name="l02071"></a>02071 <span class="preprocessor">      typename p6##_type, typename p7##_type, typename p8##_type&gt;\</span>
<a name="l02072"></a>02072 <span class="preprocessor">  template &lt;typename arg_type&gt;\</span>
<a name="l02073"></a>02073 <span class="preprocessor">  bool name##MatcherP9&lt;p0##_type, p1##_type, p2##_type, p3##_type, p4##_type, \</span>
<a name="l02074"></a>02074 <span class="preprocessor">      p5##_type, p6##_type, p7##_type, \</span>
<a name="l02075"></a>02075 <span class="preprocessor">      p8##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\</span>
<a name="l02076"></a>02076 <span class="preprocessor">      arg_type arg, \</span>
<a name="l02077"></a>02077 <span class="preprocessor">      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\</span>
<a name="l02078"></a>02078 <span class="preprocessor">          const</span>
<a name="l02079"></a>02079 <span class="preprocessor"></span>
<a name="l02080"></a><a class="code" href="gmock-generated-matchers_8h.html#aa6a3925eeb8bcb4b6b3465cc4ff26650">02080</a> <span class="preprocessor">#define MATCHER_P10(name, p0, p1, p2, p3, p4, p5, p6, p7, p8, p9, description)\</span>
<a name="l02081"></a>02081 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l02082"></a>02082 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type, \</span>
<a name="l02083"></a>02083 <span class="preprocessor">      typename p6##_type, typename p7##_type, typename p8##_type, \</span>
<a name="l02084"></a>02084 <span class="preprocessor">      typename p9##_type&gt;\</span>
<a name="l02085"></a>02085 <span class="preprocessor">  class name##MatcherP10 {\</span>
<a name="l02086"></a>02086 <span class="preprocessor">   public:\</span>
<a name="l02087"></a>02087 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l02088"></a>02088 <span class="preprocessor">    class gmock_Impl : public ::testing::MatcherInterface&lt;arg_type&gt; {\</span>
<a name="l02089"></a>02089 <span class="preprocessor">     public:\</span>
<a name="l02090"></a>02090 <span class="preprocessor">      gmock_Impl(p0##_type gmock_p0, p1##_type gmock_p1, p2##_type gmock_p2, \</span>
<a name="l02091"></a>02091 <span class="preprocessor">          p3##_type gmock_p3, p4##_type gmock_p4, p5##_type gmock_p5, \</span>
<a name="l02092"></a>02092 <span class="preprocessor">          p6##_type gmock_p6, p7##_type gmock_p7, p8##_type gmock_p8, \</span>
<a name="l02093"></a>02093 <span class="preprocessor">          p9##_type gmock_p9)\</span>
<a name="l02094"></a>02094 <span class="preprocessor">           : p0(gmock_p0), p1(gmock_p1), p2(gmock_p2), p3(gmock_p3), \</span>
<a name="l02095"></a>02095 <span class="preprocessor">               p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), p7(gmock_p7), \</span>
<a name="l02096"></a>02096 <span class="preprocessor">               p8(gmock_p8), p9(gmock_p9) {}\</span>
<a name="l02097"></a>02097 <span class="preprocessor">      virtual bool MatchAndExplain(\</span>
<a name="l02098"></a>02098 <span class="preprocessor">          arg_type arg, ::testing::MatchResultListener* result_listener) const;\</span>
<a name="l02099"></a>02099 <span class="preprocessor">      virtual void DescribeTo(::std::ostream* gmock_os) const {\</span>
<a name="l02100"></a>02100 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(false);\</span>
<a name="l02101"></a>02101 <span class="preprocessor">      }\</span>
<a name="l02102"></a>02102 <span class="preprocessor">      virtual void DescribeNegationTo(::std::ostream* gmock_os) const {\</span>
<a name="l02103"></a>02103 <span class="preprocessor">        *gmock_os &lt;&lt; FormatDescription(true);\</span>
<a name="l02104"></a>02104 <span class="preprocessor">      }\</span>
<a name="l02105"></a>02105 <span class="preprocessor">      p0##_type p0;\</span>
<a name="l02106"></a>02106 <span class="preprocessor">      p1##_type p1;\</span>
<a name="l02107"></a>02107 <span class="preprocessor">      p2##_type p2;\</span>
<a name="l02108"></a>02108 <span class="preprocessor">      p3##_type p3;\</span>
<a name="l02109"></a>02109 <span class="preprocessor">      p4##_type p4;\</span>
<a name="l02110"></a>02110 <span class="preprocessor">      p5##_type p5;\</span>
<a name="l02111"></a>02111 <span class="preprocessor">      p6##_type p6;\</span>
<a name="l02112"></a>02112 <span class="preprocessor">      p7##_type p7;\</span>
<a name="l02113"></a>02113 <span class="preprocessor">      p8##_type p8;\</span>
<a name="l02114"></a>02114 <span class="preprocessor">      p9##_type p9;\</span>
<a name="l02115"></a>02115 <span class="preprocessor">     private:\</span>
<a name="l02116"></a>02116 <span class="preprocessor">      ::testing::internal::string FormatDescription(bool negation) const {\</span>
<a name="l02117"></a>02117 <span class="preprocessor">        const ::testing::internal::string gmock_description = (description);\</span>
<a name="l02118"></a>02118 <span class="preprocessor">        if (!gmock_description.empty())\</span>
<a name="l02119"></a>02119 <span class="preprocessor">          return gmock_description;\</span>
<a name="l02120"></a>02120 <span class="preprocessor">        return ::testing::internal::FormatMatcherDescription(\</span>
<a name="l02121"></a>02121 <span class="preprocessor">            negation, #name, \</span>
<a name="l02122"></a>02122 <span class="preprocessor">            ::testing::internal::UniversalTersePrintTupleFieldsToStrings(\</span>
<a name="l02123"></a>02123 <span class="preprocessor">                ::testing::tuple&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l02124"></a>02124 <span class="preprocessor">                    p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \</span>
<a name="l02125"></a>02125 <span class="preprocessor">                    p9##_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9)));\</span>
<a name="l02126"></a>02126 <span class="preprocessor">      }\</span>
<a name="l02127"></a>02127 <span class="preprocessor">      GTEST_DISALLOW_ASSIGN_(gmock_Impl);\</span>
<a name="l02128"></a>02128 <span class="preprocessor">    };\</span>
<a name="l02129"></a>02129 <span class="preprocessor">    template &lt;typename arg_type&gt;\</span>
<a name="l02130"></a>02130 <span class="preprocessor">    operator ::testing::Matcher&lt;arg_type&gt;() const {\</span>
<a name="l02131"></a>02131 <span class="preprocessor">      return ::testing::Matcher&lt;arg_type&gt;(\</span>
<a name="l02132"></a>02132 <span class="preprocessor">          new gmock_Impl&lt;arg_type&gt;(p0, p1, p2, p3, p4, p5, p6, p7, p8, p9));\</span>
<a name="l02133"></a>02133 <span class="preprocessor">    }\</span>
<a name="l02134"></a>02134 <span class="preprocessor">    name##MatcherP10(p0##_type gmock_p0, p1##_type gmock_p1, \</span>
<a name="l02135"></a>02135 <span class="preprocessor">        p2##_type gmock_p2, p3##_type gmock_p3, p4##_type gmock_p4, \</span>
<a name="l02136"></a>02136 <span class="preprocessor">        p5##_type gmock_p5, p6##_type gmock_p6, p7##_type gmock_p7, \</span>
<a name="l02137"></a>02137 <span class="preprocessor">        p8##_type gmock_p8, p9##_type gmock_p9) : p0(gmock_p0), p1(gmock_p1), \</span>
<a name="l02138"></a>02138 <span class="preprocessor">        p2(gmock_p2), p3(gmock_p3), p4(gmock_p4), p5(gmock_p5), p6(gmock_p6), \</span>
<a name="l02139"></a>02139 <span class="preprocessor">        p7(gmock_p7), p8(gmock_p8), p9(gmock_p9) {\</span>
<a name="l02140"></a>02140 <span class="preprocessor">    }\</span>
<a name="l02141"></a>02141 <span class="preprocessor">    p0##_type p0;\</span>
<a name="l02142"></a>02142 <span class="preprocessor">    p1##_type p1;\</span>
<a name="l02143"></a>02143 <span class="preprocessor">    p2##_type p2;\</span>
<a name="l02144"></a>02144 <span class="preprocessor">    p3##_type p3;\</span>
<a name="l02145"></a>02145 <span class="preprocessor">    p4##_type p4;\</span>
<a name="l02146"></a>02146 <span class="preprocessor">    p5##_type p5;\</span>
<a name="l02147"></a>02147 <span class="preprocessor">    p6##_type p6;\</span>
<a name="l02148"></a>02148 <span class="preprocessor">    p7##_type p7;\</span>
<a name="l02149"></a>02149 <span class="preprocessor">    p8##_type p8;\</span>
<a name="l02150"></a>02150 <span class="preprocessor">    p9##_type p9;\</span>
<a name="l02151"></a>02151 <span class="preprocessor">   private:\</span>
<a name="l02152"></a>02152 <span class="preprocessor">    GTEST_DISALLOW_ASSIGN_(name##MatcherP10);\</span>
<a name="l02153"></a>02153 <span class="preprocessor">  };\</span>
<a name="l02154"></a>02154 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l02155"></a>02155 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type, \</span>
<a name="l02156"></a>02156 <span class="preprocessor">      typename p6##_type, typename p7##_type, typename p8##_type, \</span>
<a name="l02157"></a>02157 <span class="preprocessor">      typename p9##_type&gt;\</span>
<a name="l02158"></a>02158 <span class="preprocessor">  inline name##MatcherP10&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l02159"></a>02159 <span class="preprocessor">      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \</span>
<a name="l02160"></a>02160 <span class="preprocessor">      p9##_type&gt; name(p0##_type p0, p1##_type p1, p2##_type p2, p3##_type p3, \</span>
<a name="l02161"></a>02161 <span class="preprocessor">      p4##_type p4, p5##_type p5, p6##_type p6, p7##_type p7, p8##_type p8, \</span>
<a name="l02162"></a>02162 <span class="preprocessor">      p9##_type p9) {\</span>
<a name="l02163"></a>02163 <span class="preprocessor">    return name##MatcherP10&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l02164"></a>02164 <span class="preprocessor">        p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, p9##_type&gt;(p0, \</span>
<a name="l02165"></a>02165 <span class="preprocessor">        p1, p2, p3, p4, p5, p6, p7, p8, p9);\</span>
<a name="l02166"></a>02166 <span class="preprocessor">  }\</span>
<a name="l02167"></a>02167 <span class="preprocessor">  template &lt;typename p0##_type, typename p1##_type, typename p2##_type, \</span>
<a name="l02168"></a>02168 <span class="preprocessor">      typename p3##_type, typename p4##_type, typename p5##_type, \</span>
<a name="l02169"></a>02169 <span class="preprocessor">      typename p6##_type, typename p7##_type, typename p8##_type, \</span>
<a name="l02170"></a>02170 <span class="preprocessor">      typename p9##_type&gt;\</span>
<a name="l02171"></a>02171 <span class="preprocessor">  template &lt;typename arg_type&gt;\</span>
<a name="l02172"></a>02172 <span class="preprocessor">  bool name##MatcherP10&lt;p0##_type, p1##_type, p2##_type, p3##_type, \</span>
<a name="l02173"></a>02173 <span class="preprocessor">      p4##_type, p5##_type, p6##_type, p7##_type, p8##_type, \</span>
<a name="l02174"></a>02174 <span class="preprocessor">      p9##_type&gt;::gmock_Impl&lt;arg_type&gt;::MatchAndExplain(\</span>
<a name="l02175"></a>02175 <span class="preprocessor">      arg_type arg, \</span>
<a name="l02176"></a>02176 <span class="preprocessor">      ::testing::MatchResultListener* result_listener GTEST_ATTRIBUTE_UNUSED_)\</span>
<a name="l02177"></a>02177 <span class="preprocessor">          const</span>
<a name="l02178"></a>02178 <span class="preprocessor"></span>
<a name="l02179"></a>02179 <span class="preprocessor">#endif  // GMOCK_INCLUDE_GMOCK_GMOCK_GENERATED_MATCHERS_H_</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Sun Sep 6 2015 20:59:11 for ZNC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
